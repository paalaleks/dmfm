# Story 3.9: Implement Dynamic Fetching and Taste-Based Filtering of Playlists

**Status:** In Progress

**Dependencies:**
*   Story 3.1 (MusicContext setup) completed.
*   Auto-play logic for the first playlist in `tasteMatchedPlaylists` (implemented in recent interactions) should be functional.
*   Supabase tables (`profiles`, `user_top_artists`, `playlists`, `playlist_tracks`) must be populated with relevant test data.

## Goal & Context

**User Story:** As a user, I want the application to automatically suggest and potentially play playlists that match my musical taste when I enter a chat room, so I can discover relevant new music seamlessly.

**Context:** This story transitions the application from using mock playlists to a dynamic system for playlist suggestions, optimizing for client performance by leveraging Server Actions. It involves:
1.  `MusicContext` (Client Component) triggering a Server Action upon initialization.
2.  The Server Action performing the data-intensive work:
    a.  Fetching the current authenticated user's taste profile (initially based on their top artists from the `user_top_artists` table).
    b.  Querying candidate playlists from the `playlists` table, ensuring to exclude playlists submitted by the current user.
    c.  For each candidate playlist, determining its own "taste profile" by aggregating artist information from its tracks (via `playlist_tracks` table).
    d.  Calculating a taste similarity score (e.g., using Jaccard Index) between the user's profile and each candidate playlist's profile.
    e.  Returning a filtered and sorted list of taste-matched playlists.
3.  `MusicContext` receiving this list and updating its state.
The existing auto-play logic in `MusicContext` is expected to then handle the automatic playback of the first playlist from this dynamically generated list. This directly supports FR11.

## Detailed Requirements

*   **Server Action for Playlist Matching:**
    *   Create a new Server Action (e.g., `getTasteMatchedPlaylistsAction`).
    *   This action will encapsulate all data fetching from Supabase and taste comparison logic.
*   **User Taste Profile Acquisition (within Server Action):**
    *   Fetch the current user's top artists from `public.user_top_artists`.
    *   Represent user's taste as a `Set<string>` of artist Spotify IDs.
*   **Candidate Playlist Retrieval (within Server Action):**
    *   Fetch playlists from `public.playlists`, excluding those where `submitted_by_user_id` matches the current user.
*   **Playlist Taste Profiling (within Server Action):**
    *   For each candidate playlist, query `public.playlist_tracks` to get its tracks.
    *   Extract unique artist Spotify IDs from these tracks (from `track_artists` JSONB field).
    *   Represent playlist's taste as a `Set<string>` of artist Spotify IDs.
*   **Taste Similarity Calculation (within Server Action):**
    *   Utilize `calculateJaccardIndex` from `lib/utils/taste-comparison.ts` to compare user's artist set with each playlist's artist set.
*   **Filtering and Sorting Playlists (within Server Action):**
    *   Apply a similarity threshold; sort matching playlists by score.
    *   The Server Action will return this final list of `Playlist` objects.
*   **`MusicContext` Modifications:**
    *   On initialization (user authenticated, token valid, SDK ready), `MusicContext` will call the `getTasteMatchedPlaylistsAction` Server Action.
    *   It will use the returned list to update its `tasteMatchedPlaylists` state.
    *   The `MOCK_PLAYLISTS` usage for initial population must be removed.
    *   Ensure `currentPlaylistIndex` and `initialPlaylistAutoPlayedRef.current` are reset correctly when the new dynamic list is received to enable auto-play.

## Acceptance Criteria (ACs)

*   **AC1:** A Server Action (e.g., `getTasteMatchedPlaylistsAction`) is created and correctly performs data fetching and taste-matching logic on the server.
*   **AC2:** `MusicContext` successfully calls this Server Action upon initialization.
*   **AC3:** The Server Action correctly fetches the user's top artists and candidate playlists (excluding user's own submissions).
*   **AC4:** The Server Action correctly determines artist sets for candidate playlists and calculates Jaccard Index scores.
*   **AC5:** The Server Action returns a list of playlists filtered by a similarity threshold and sorted by score.
*   **AC6:** `MusicContext` state (`tasteMatchedPlaylists`) is populated with the list returned by the Server Action. `MOCK_PLAYLISTS` usage is removed.
*   **AC7:** If `tasteMatchedPlaylists` is populated, the existing auto-play logic in `MusicContext` initiates playback of the first playlist.
*   **AC8:** If the Server Action returns an empty list (no matches or error), `tasteMatchedPlaylists` is empty, and no taste-matched auto-play occurs.
*   **AC9:** The Server Action includes robust error handling; `MusicContext` handles potential errors from the Server Action call gracefully.
*   **AC10:** The process is triggered automatically after user login and SDK readiness without requiring manual user interaction.

## Technical Implementation Context

*   **Files to Create / Modify:**
    *   `app/actions/playlist-actions.ts` (or similar, for the Server Action `getTasteMatchedPlaylistsAction`, marked with `'use server'`).
    *   `music-context/music-context.tsx`: To call the Server Action and manage state.
    *   `lib/utils/taste-comparison.ts`: `calculateJaccardIndex` will be used by the Server Action.
    *   `lib/supabase/queries/playlist-queries.ts` (Recommended): To encapsulate Supabase queries for playlists, called by the Server Action.
    *   `lib/supabase/queries/user-profile-queries.ts` (Recommended): To encapsulate Supabase queries for user profiles/tastes, called by the Server Action.
*   **Key Technologies & Libraries:**
    *   Next.js Server Actions.
    *   React (`useContext`, `useState`, `useEffect`, `useCallback`).
    *   Supabase Client JS Library (server-side client for the Server Action, e.g., from `@supabase/ssr` or `createRouteHandlerClient`).
    *   TypeScript.
    *   JavaScript `Set` objects.
*   **Database Schema (refer to `docs/data-models.md`):** (Same tables as before, but accessed primarily by the Server Action)
    *   `public.profiles`, `public.user_top_artists`, `public.playlists`, `public.playlist_tracks`.

## Tasks / Subtasks

*   [x] **Task 1: Create Server Action (`getTasteMatchedPlaylistsAction`)**
    *   [x] Define the Server Action function in a new file (e.g., `app/actions/playlist-actions.ts`).
    *   [x] Implement logic within the Server Action to:
        *   [x] a. Get current authenticated user's ID (server-side Supabase auth).
        *   [x] b. Fetch user's top artists (from `user_top_artists`) into a `Set<string>`.
        *   [x] c. Fetch candidate playlists (from `playlists`, excluding user's own) into a list of `Playlist` objects (ensure type includes internal `id` and `spotify_playlist_id`).
        *   [x] d. For each candidate playlist, fetch its tracks (from `playlist_tracks`) and aggregate unique artist Spotify IDs (from `track_artists` JSONB) into a `Set<string>`.
        *   [x] e. Calculate Jaccard Index between user's artist set and each playlist's artist set using `calculateJaccardIndex`.
        *   [x] f. Filter playlists by a similarity threshold and sort them by score.
        *   [x] g. Return the final list of `Playlist` objects (or an empty array if no matches/error).
        *   [x] Implement error handling within the Server Action.
*   [x] **Task 2: Update `MusicContext` to Call Server Action**
    *   [x] Import the Server Action into `music-context/music-context.tsx`.
    *   [x] Create a primary `async` function (e.g., `fetchAndSetTasteMatchedPlaylists`) within `MusicProvider`.
    *   [x] This function will call `await getTasteMatchedPlaylistsAction()`.
    *   [x] It will then update `tasteMatchedPlaylists` state with the result.
    *   [x] It will reset `currentPlaylistIndex` to `null` and `initialPlaylistAutoPlayedRef.current` to `false`.
    *   [x] Call this orchestrating function from an appropriate `useEffect` hook (when `isReady`, `deviceId`, `userSession.spotifyToken` are available).
    *   [x] Remove the old `MOCK_PLAYLISTS` loading logic.
    *   [x] Handle errors from the Server Action call (e.g., update an error state in context, log error).
*   [x] **Task 3: Refactor Database Queries (Optional but Recommended)**
    *   [x] Create/use helper functions in `lib/supabase/queries/*` for fetching user top artists, candidate playlists, and playlist tracks. These helpers will be used by the Server Action.
*   [ ] **Task 4: Testing and Refinement**
    *   [ ] Prepare diverse test data in Supabase as previously outlined.
    *   [ ] Manually test login flow for different users.
    *   [ ] Verify correct playlists populate `tasteMatchedPlaylists` via the Server Action.
    *   [ ] Verify auto-play with the dynamic list.
    *   [ ] Test edge cases and error conditions.

## Testing Requirements

*   (Same as previous version of the story, focusing on the end-to-end behavior being correct regardless of whether logic is client-side or server-action-driven).

## Story Wrap Up (Agent Populates After Execution)

*   **Agent Model Used:** `<Agent Model Name/Version>`
*   **Completion Notes:** {Any notes about implementation choices, difficulties, or follow-up needed}
*   **Change Log:**
    *   Initial Draft
    *   Revised to use Server Action for data fetching and processing.

--- 
# Story 3.7: Implement Asynchronous Music Playback in Chat Rooms

**Status:** Approved

## Goal & Context

**User Story:** As a user in a chat room, I want to listen to music asynchronously using the integrated Spotify player, so my playback (play, pause, skip, track choice, volume) is independent of other users in the same room, allowing for a personalized listening experience.

**Context:** This story addresses FR16 from Epic 3: "Users in a chat room listen to music asynchronously (i.e., their playback is independent of others)". It builds upon existing Spotify Web Playback SDK integration (Story 3.1), player UI/controls (Stories 3.2-3.3), and other music functionalities (Stories 3.4-3.6). The application's architecture for chat rooms (using Supabase Realtime and Server Actions) and user session management (via Supabase Auth) is established (see `docs/architecture.md`, `docs/frontend-architecture.md`). The `MusicContext` is provided globally per user session via `app/layout.tsx`, meaning each user has an isolated context for their Spotify player. The primary goal is to ensure individual playback control in a shared environment without interference between users.

## Detailed Requirements

(Corresponds to FR16: Users in a chat room listen to music asynchronously.)
*   The system must leverage the per-user `MusicContext` and client-side Spotify Player SDK instance to manage individual playback states.
*   Playback actions (e.g., play, pause, skip track, select track, adjust volume) performed by one user must not affect the playback state of any other user in the same or different chat rooms.
*   Each user's Spotify playback commands must be directed only to their own Spotify Player SDK instance and Spotify account.

## Acceptance Criteria (ACs)

*   **AC1:** When User A starts playing a track via the integrated Spotify player while in a chat room, User B (who is in the same chat room) experiences no change in their own Spotify player state (e.g., if User B's player was idle, it remains idle; if User B was playing a different track, that track continues to play for User B).
*   **AC2:** If User A pauses or resumes their music, User B's playback (if active) is unaffected.
*   **AC3:** If User A skips to the next or previous track in their queue/playlist, User B's current track and queue remain unchanged.
*   **AC4:** If User A adjusts their playback volume, User B's volume setting is not altered.
*   **AC5:** The system correctly utilizes the isolated `MusicContext` and client-side Spotify SDK for each respective user session, ensuring playback independence even when multiple users are present in the same chat room.

## Technical Implementation Context

**Guidance:** Use the following details for implementation. Developer agent is expected to follow project standards in `docs/coding-standards.md` and understand the project structure in `docs/project-structure.md`. Application architecture details are in `docs/architecture.md` and `docs/frontend-architecture.md`.

- **Relevant Files:**
  - Files to Create: (Likely none, modifications will be to existing files)
  - Files to Modify:
    - `context/MusicContext.tsx` (or equivalent Spotify player state management service): Review to ensure all state and actions are purely client-side to the user's session and do not interact with any shared backend state that could cause cross-user playback interference. The context itself is already per-user due to its provision in `app/layout.tsx`.
    - Spotify SDK initialization and interaction logic (likely within `MusicContext.tsx` or `hooks/useSpotifyPlayer.ts`): Confirm that player instances and commands are strictly bound to the individual user's browser session and Spotify account.
    - Chat room UI components: No direct changes expected for this story, as they should already be using the user-specific `MusicContext` for any player display/control elements.

- **Key Technologies:**
  - Spotify Web Playback SDK.
  - React/TypeScript.
  - React Context API (for `MusicContext.tsx`).

- **API Interactions / SDK Usage:**
  - Focus on the client-side management of the `Spotify.Player` object. Ensure each user's SDK instance operates independently.
  - All Spotify API calls related to playback control (play, pause, seek, set volume, etc.) are inherently user-specific when made through the client-side SDK initialized with the user's token.
  - Device ID selection and management must remain user-specific.

- **UI/UX Notes:** 
    - The existing player UI should function as before; the core of this story is ensuring backend/state isolation between users, which is largely provided by the client-side nature of the SDK and per-user `MusicContext`.
    - User feedback for playback errors should remain user-specific.

- **Data Structures:**
  - The state managed by `MusicContext` must remain confined to the user's session. No shared data structures that could cause cross-talk for playback control are anticipated.

- **Environment Variables:** 
  - None specific to this story beyond existing Spotify API credentials, managed as per `docs/environment-vars.md`.

- **Coding Standards Notes:**
  - Reinforce strict client-side state management for the player. Avoid patterns that might lead to unintentional sharing or mutation of playback state across different user sessions (e.g., via backend databases for *controlling* playback, which is not the design).
  - Follow all guidelines in `docs/coding-standards.md`.

- **Clarified Assumptions (Based on Existing Documentation):**
    - **Chat Room Implementation:** The architecture for chat rooms, user identification within rooms, and real-time communication is established using Supabase Auth, Supabase Realtime, and Server Actions, as detailed in `docs/architecture.md`, `docs/frontend-architecture.md`, and `docs/data-models.md`.
    - **`MusicContext` Scoping:** `MusicContext` is provided globally via `app/layout.tsx` (`docs/architecture.md`, `docs/frontend-architecture.md`), meaning each user running the application in their browser receives their own isolated instance of this context. This provides the necessary per-user scope for managing their individual Spotify player state.

## Tasks / Subtasks

- [x] **Review & Verification:**
  - [x] Thoroughly review the current implementation of `MusicContext.tsx`.
  - [x] Verify that all player state mutations and SDK commands are strictly client-side and cannot influence other users' sessions.
  - [x] Confirm that any data displayed in the player (current track, playlist) is fetched and managed within the user's own `MusicContext`.
- [ ] **Implementation (If Necessary):**
  - [x] If any part of `MusicContext` or player logic inadvertently uses or relies on shared state that *could* cross user boundaries for playback control (unlikely given current architecture understanding), refactor to ensure strict client-session isolation for playback commands and state. **(No changes needed as per review)**
- [ ] **Testing:**
  - [ ] Manually test with multiple accounts/browsers simulating two or more users in the same chat room environment. Verify all ACs meticulously.
  - [ ] (Optional) Write unit tests for key functions within `MusicContext` if complex logic exists, mocking Spotify SDK interactions to ensure commands target the correct (mocked) user instance.

## Testing Requirements

**Guidance:** Verify implementation against the ACs using the following tests. Follow general testing approach outlined in `docs/testing-strategy.md`.

- **Unit Tests:** (Optional, as primary logic is SDK interaction)
    - If complex state logic exists in `MusicContext` beyond direct SDK calls, test that logic in isolation.
- **Integration Tests:** (Not a primary focus for this specific story if SDK usage is straightforwardly client-side)
- **Manual/E2E Tests (Critical for this story):**
    - **Setup:** Requires the ability to simulate at least two users logged into the application and joined to the same chat room (e.g., using two different browsers or browser profiles).
    - **Scenario 1 (Independent Play Start):** User A starts playing a track. Verify User B's player remains in its previous state.
    - **Scenario 2 (Independent Pause/Resume):** User A pauses their music. Verify User B's music (if playing) is unaffected. User A resumes; User B still unaffected.
    - **Scenario 3 (Independent Track Skipping):** User A skips their track. Verify User B's current track and playback position are unaffected.
    - **Scenario 4 (Independent Volume Control):** User A changes their volume. Verify User B's volume level remains unchanged.
    - **Scenario 5 (Simultaneous Independent Playback):** Both User A and User B start playing different tracks. Verify both can listen to their chosen music simultaneously without interference.
    - **Scenario 6 (Joining/Leaving Room):** User A is playing music. User B joins the room. Verify User B's player starts in an independent (e.g., idle) state and User A's playback is not interrupted.

## Story Wrap Up (Agent Populates After Execution)

- **Agent Model Used:** `<Agent Model Name/Version>`
- **Completion Notes:** {Any notes about implementation choices, difficulties, or follow-up needed}
- **Change Log:** {Track changes _within this specific story file_ if iterations occur}
  - Initial Draft (Status: Draft (Needs Input) due to chat room dependency)
  - Updated to Draft: Dependencies clarified based on existing architecture documents. Context revised. Open questions resolved. 
# Story 2.1: Define Database Schema for Playlist and Taste Data

**Status:** Complete

## Goal & Context

**User Story:** As a system architect, I want to define and implement the necessary database schema changes to store user-related playlist data and foundational elements for taste profiling, so that the application can later use this data for matching users and recommending playlists.

**Context:** This is the first story for Epic 2: "Playlist Management and Taste Profiling." It lays the database groundwork required to support FR19 (store artist/song data from user-shared/played playlists) and FR20 (fetch and store user's top artists from Spotify for taste mapping). This story directly enables future work on ingesting data and developing taste comparison logic.

## Detailed Requirements

Based on FR19 and FR20 from `docs/prd.md` and the goal of Epic 2, this story involves:
1.  Designing new database tables to store:
    *   User's top items (artists and tracks) obtained from Spotify.
    *   Information about playlists (e.g., Spotify ID, name, description, images).
    *   Tracks within those playlists (e.g., Spotify ID, name, artists, duration, audio features if readily available).
    *   Relationship between users and these playlists/tracks (e.g., which user's top items, which playlists are relevant to a user's taste profile).
2.  Updating `docs/data-models.md` to include these new table definitions, relationships, and an updated ERD.
3.  Creating Supabase SQL migration scripts for the new tables, including appropriate columns, types, constraints, and foreign key relationships.
4.  Defining and including basic RLS (Row Level Security) policies for the new tables in the migration scripts, focusing on creator-based ownership and general read access where appropriate for now.
5.  Ensuring comments are added to tables and columns in the SQL migration.

## Acceptance Criteria (ACs)

- AC1: `docs/data-models.md` is updated with detailed SQL definitions, column descriptions, and a revised Mermaid ERD for the new tables related to user top items, playlists, and playlist tracks.
- AC2: New SQL migration file(s) are created in `supabase/migrations/` that successfully apply the new schema (tables, columns, constraints, FKs, comments) to the Supabase database.
- AC3: Basic RLS policies (e.g., users can insert their own related data, authenticated users can read) are defined and included in the migration for each new table.
- AC4: After applying migrations, `types/database.ts` can be regenerated using the Supabase CLI to include types for the new tables.

## Technical Implementation Context

**Guidance:** Use the following details for implementation. Developer agent is expected to follow project standards in `docs/coding-standards.md` and understand the project structure in `docs/project-structure.md`. Only story-specific details are included below.

- **Relevant Files:**
  - Files to Create:
    - `supabase/migrations/YYYYMMDDHHMMSS_create_playlist_and_taste_tables.sql` (Timestamp to be filled by dev)
  - Files to Modify:
    - `docs/data-models.md`
    - `types/database.ts` (This will be regenerated using Supabase CLI post-migration)

- **Key Technologies:**
  - Supabase Database (PostgreSQL)
  - SQL for migrations
  - Markdown for `docs/data-models.md`

- **API Interactions / SDK Usage:**
  - Not directly in this story, but the schema should be designed to store data obtained from the Spotify Web API (e.g., user top artists/tracks, playlist details, track details). *(Hint: See `docs/api-reference.md` for general Spotify API context, though actual fetching is for later stories)*

- **UI/UX Notes:**
  - Not applicable for this story.

- **Data Structures:**
  - **Finalized Design for New Tables:**
    -   **`user_top_artists`**
        *   `user_id` (UUID, FK to `profiles.id`, ON DELETE CASCADE)
        *   `artist_spotify_id` (TEXT) - Spotify ID for the artist
        *   `name` (TEXT)
        *   `genres` (JSONB) - Array of genre strings
        *   `popularity` (INTEGER) - Spotify popularity score (0-100)
        *   `image_url` (TEXT, nullable)
        *   `fetched_at` (TIMESTAMPTZ, default `now()`)
        *   Primary Key: (`user_id`, `artist_spotify_id`)
    -   **`user_top_tracks`**
        *   `user_id` (UUID, FK to `profiles.id`, ON DELETE CASCADE)
        *   `track_spotify_id` (TEXT) - Spotify ID for the track
        *   `name` (TEXT)
        *   `artists` (JSONB) - Array of artist objects/names, e.g., `[{ "name": "Artist Name", "spotify_id": "..." }]`
        *   `album_name` (TEXT, nullable)
        *   `album_image_url` (TEXT, nullable)
        *   `popularity` (INTEGER) - Spotify popularity score (0-100)
        *   `duration_ms` (INTEGER)
        *   `preview_url` (TEXT, nullable)
        *   `fetched_at` (TIMESTAMPTZ, default `now()`)
        *   Primary Key: (`user_id`, `track_spotify_id`)
    -   **`playlists`**
        *   `spotify_id` (TEXT, PK) - Spotify ID for the playlist
        *   `name` (TEXT NOT NULL)
        *   `description` (TEXT, nullable)
        *   `owner_spotify_id` (TEXT, nullable) - Spotify user ID of the playlist owner
        *   `image_url` (TEXT, nullable)
        *   `total_tracks` (INTEGER, nullable)
        *   `snapshot_id` (TEXT, nullable) - To track changes to the playlist content on Spotify
        *   `data_source` (TEXT, nullable) - e.g., 'user_shared', 'spotify_recommendation'
        *   `created_at` (TIMESTAMPTZ, default `now()`) - When our record was created
        *   `updated_at` (TIMESTAMPTZ, default `now()`) - When our record was last updated
        *   `last_fetched_from_spotify_at` (TIMESTAMPTZ, nullable)
    -   **`playlist_items`**
        *   `id` (BIGSERIAL, PK)
        *   `playlist_spotify_id` (TEXT, FK to `playlists.spotify_id`, ON DELETE CASCADE)
        *   `track_spotify_id` (TEXT NOT NULL) - Spotify ID for the track
        *   `added_at` (TIMESTAMPTZ, nullable) - When the track was added to the Spotify playlist
        *   `position` (INTEGER, nullable) - Track's position in the playlist
        *   `track_name` (TEXT)
        *   `track_artists` (JSONB) - Array of artist objects/names, e.g., `[{ "name": "Artist Name", "spotify_id": "..." }]`
        *   `track_album_name` (TEXT, nullable)
        *   `track_album_image_url` (TEXT, nullable)
        *   `track_duration_ms` (INTEGER)
        *   `track_popularity` (INTEGER, nullable) - Popularity of the track itself
        *   `track_preview_url` (TEXT, nullable)
        *   `audio_features` (JSONB, nullable) - To store Spotify audio features for taste comparison.
    -   **`user_playlist_interactions`**
        *   `id` (BIGSERIAL, PK)
        *   `user_id` (UUID, FK to `profiles.id`, ON DELETE CASCADE)
        *   `playlist_spotify_id` (TEXT, FK to `playlists.spotify_id`, ON DELETE CASCADE)
        *   `interaction_type` (TEXT NOT NULL) - e.g., 'played_in_app', 'shared_in_chat', 'saved_to_library_via_app', 'matched_by_taste_algorithm'
        *   `interacted_at` (TIMESTAMPTZ, default `now()`)
        *   `metadata` (JSONB, nullable) - e.g., taste match score.
  - Data types should align with `docs/data-models.md` conventions.
  - *(Hint: Review existing tables in `docs/data-models.md` for conventions).*

- **Environment Variables:**
  - None specific to this story beyond standard Supabase connection variables.

- **Coding Standards Notes:**
  - Follow SQL naming conventions (`snake_case` for tables/columns) as per `docs/coding-standards.md` and `.cursor/rules/postgres-sql-style-guide.mdc`.
  - Ensure migration filenames follow `YYYYMMDDHHMMSS_description-using-hyphens.sql` format.
  - Use `COMMENT ON ... IS ...;` for all new tables and columns in the migration script.
  - Adhere to `create-migration.mdc` and `create-rls-policies.mdc` guidelines.

## Tasks / Subtasks

- [x] Task 1: Analyze FR19 & FR20 from `docs/prd.md` and existing data models to finalize the list of required tables and columns for playlist and taste data.
- [x] Task 2: Design the detailed schema for `user_top_artists`, `user_top_tracks`, `playlists`, `playlist_items`, and `user_playlist_interactions`.
  - [x] Define column names, data types, constraints (PK, FK, NOT NULL, UNIQUE, CHECK).
  - [x] Plan relationships between these new tables and with existing tables (e.g., `profiles`).
- [x] Task 3: Update `docs/data-models.md`:
  - [x] Add SQL definitions for the new tables.
  - [x] Add detailed descriptions for each new table and column.
  - [x] Update the Mermaid ERD to include the new tables and their relationships.
- [x] Task 4: Write the SQL migration script (`supabase/migrations/YYYYMMDDHHMMSS_create_playlist_and_taste_tables.sql`):
  - [x] Include `CREATE TABLE` statements for all new tables.
  - [x] Add `COMMENT ON` statements for all new tables and columns.
  - [x] Implement basic RLS policies for each new table (e.g., `CREATE POLICY "Users can insert their own related data..."`, `CREATE POLICY "Authenticated users can read all..."`).
- [x] Task 5: (Developer Agent will do this after applying migrations) Regenerate `types/database.ts` using the command: `npx supabase gen types typescript --project-id <YOUR_PROJECT_REF_FROM_RULE_supabase-project-ref> --schema public > types/database.ts` (Confirm project ID `jaoksbhfyfyqubkmjvso` is correct).
- [x] Task 6: Manually verify the migration applies correctly to a local/dev Supabase instance.
- [x] Task 7: Manually verify that `types/database.ts` is updated correctly after generation.

## Testing Requirements

**Guidance:** Verify implementation against the ACs using the following tests. Follow general testing approach in `docs/testing-strategy.md`.

- **Unit Tests:**
  - Not directly applicable for schema definition, but RLS policies might be testable with pgTAP in the future (as per `docs/testing-strategy.md` future considerations).
- **Integration Tests:**
  - Not applicable for this story.
- **Manual/CLI Verification:**
  - AC2: Apply the migration to a Supabase instance (local or dev) and confirm successful execution without errors. Inspect the database schema using Supabase Studio or `psql` to verify tables, columns, types, constraints, and comments.
  - AC3: Review RLS policies in Supabase Studio after migration.
  - AC4: After applying the migration, run the `supabase gen types` command and inspect the generated `types/database.ts` file to ensure new tables and their columns are present.

## Story Wrap Up (Agent Populates After Execution)

- **Agent Model Used:** `<Agent Model Name/Version>`
- **Completion Notes:** Successfully defined and migrated database schema for playlist and taste data. Updated data-models.md. Regenerated types/database.ts.
- **Change Log:**
  - Initial Draft
  - Added schema design to Data Structures, marked Tasks 1 & 2 complete.
  - Updated data-models.md, marked Task 3 complete.
  - Created migration SQL file, marked Task 4 complete.
  - Attempted type generation (failed due to sync issue).
  - Corrected migration SQL.
  - Applied corrected migration.
  - Regenerated types/database.ts, marked Task 5 complete.
  - Marked Task 6 complete (user confirmed migration success).
  - Marked Task 7 complete (user confirmed type verification). 
# Story 8.1: Create Aggregate Table for Playlist Tracks and Artist Occurrences

**Status:** Approved

## Goal & Context

**User Story:** As a developer, I want to design and implement a new database table (`playlist_track_artist_aggregates`) to store aggregated information about tracks and artist occurrences for each imported playlist, so that this table can facilitate more efficient querying for "top tracks" and "top artists" based on their frequency within playlists, serving as a foundational step for enhancing taste-based playlist matching.

**Context:** This story is the first step in Epic 8, which aims to refine playlist matching. This table will store pre-calculated aggregates to speed up matching algorithms. It does not depend on any previous stories within this epic.

## Detailed Requirements

Design and implement a new database table (`playlist_track_artist_aggregates`) to store aggregated information about tracks and artist occurrences for each imported playlist. This table will facilitate more efficient querying for "top tracks" and "top artists" based on their frequency within playlists, serving as a foundational step for enhancing taste-based playlist matching.

**Database Schema Details:**
*   **Table Name:** `playlist_track_artist_aggregates`
*   **SQL DDL (to be included in the migration):**
    ```sql
    CREATE TABLE public.playlist_track_artist_aggregates (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        playlist_id UUID NOT NULL UNIQUE REFERENCES public.playlists(id) ON DELETE CASCADE,
        user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
        tracks_json JSONB NOT NULL DEFAULT '[]'::jsonb,
        artists_json JSONB NOT NULL DEFAULT '[]'::jsonb,
        total_tracks INTEGER NOT NULL DEFAULT 0,
        distinct_artist_count INTEGER NOT NULL DEFAULT 0,
        last_aggregated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
        created_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    ALTER TABLE public.playlist_track_artist_aggregates ENABLE ROW LEVEL SECURITY;

    CREATE POLICY "Allow authenticated users to read playlist aggregates"
    ON public.playlist_track_artist_aggregates
    FOR SELECT
    TO authenticated
    USING (true);

    COMMENT ON TABLE public.playlist_track_artist_aggregates IS 'Stores aggregated track and artist data for each playlist.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.playlist_id IS 'FK to the playlists table.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.user_id IS 'FK to the profiles table, indicating the user associated with this aggregation (e.g., importer). Can be NULL if not user-specific.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.tracks_json IS 'JSONB array of track objects from the playlist.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.artists_json IS 'JSONB array of unique artists, each with their occurrence count in the playlist.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.total_tracks IS 'Total number of tracks in tracks_json.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.distinct_artist_count IS 'Total number of distinct artists in artists_json.';
    COMMENT ON COLUMN public.playlist_track_artist_aggregates.last_aggregated_at IS 'Timestamp of the last aggregation update.';

    CREATE OR REPLACE FUNCTION public.update_playlist_aggregates_last_aggregated_at_on_update()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.last_aggregated_at = now();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER trigger_update_playlist_aggregates_last_aggregated_at
    BEFORE UPDATE ON public.playlist_track_artist_aggregates
    FOR EACH ROW
    EXECUTE FUNCTION public.update_playlist_aggregates_last_aggregated_at_on_update();
    ```
*   **JSONB Structures:**
    *   `tracks_json`:
        ```json
        [
          {
            "spotify_track_id": "string",
            "name": "string",
            "duration_ms": "integer"
          }
        ]
        ```
    *   `artists_json`:
        ```json
        [
          {
            "spotify_artist_id": "string",
            "name": "string",
            "playlist_occurrences": "integer"
          }
        ]
        ```

## Acceptance Criteria (ACs)

- AC1: A new database table `playlist_track_artist_aggregates` is created with the schema detailed above (columns: `id`, `playlist_id`, `user_id`, `tracks_json`, `artists_json`, `total_tracks`, `distinct_artist_count`, `last_aggregated_at`, `created_at`).
- AC2: The `artists_json` column in the new table correctly stores an array of unique artist objects, each including a `playlist_occurrences` count, as per the defined JSONB structure.
- AC3: The `tracks_json` column in the new table correctly stores an array of track objects, as per the defined JSONB structure.
- AC4: A Supabase migration file is created and successfully applied to implement this table schema.
- AC5: The migration includes enabling Row Level Security (RLS) for the table.
- AC6: The migration includes appropriate RLS policies (e.g., authenticated read access as specified).
- AC7: The migration includes a trigger function to automatically update the `last_aggregated_at` column on row updates.
- AC8: Migration script comments clearly describe the table, columns, and trigger function as per `create-migration` rule.
- AC9: Aggregation logic includes console logs for debugging (This AC seems more relevant to Story 1.2, but is listed under 1.1 in the epic. For this story, it means the SQL comments should be thorough).

## Technical Implementation Context

**Guidance:** Use the following details for implementation. Developer agent is expected to follow project standards in `docs/coding-standards.md`, `postgres-sql-style-guide.mdc`, and `create-migration.mdc`.

- **Relevant Files:**
  - Files to Create: `supabase/migrations/YYYYMMDDHHMMSS_create_playlist_track_artist_aggregates_table.sql` (Developer agent to replace YYYYMMDDHHMMSS with actual timestamp).
  - Files to Modify: None.

- **Key Technologies:**
  - PostgreSQL (Supabase)

- **API Interactions / SDK Usage:**
  - Not applicable for this story.

- **Data Structures:**
  - See "Database Schema Details" and "JSONB Structures" above. The `playlists` table (referenced via `playlist_id`) is an existing table (see `docs/data-models.md`).

- **Environment Variables:**
  - None specific to this story beyond standard Supabase connection variables which are assumed to be configured for migration application.

- **Coding Standards Notes:**
  - Follow SQL guidelines from `postgres-sql-style-guide.mdc`.
  - Follow migration creation guidelines from `create-migration.mdc`.
  - Ensure all comments required by `create-migration` rule are present in the SQL migration file.

## Tasks / Subtasks

- [x] Define the SQL DDL for the `playlist_track_artist_aggregates` table including columns, types, constraints, and primary/foreign keys.
- [x] Define the SQL for adding the `user_id` column with its foreign key constraint and comment.
- [x] Define the SQL for enabling RLS on the new table.
- [x] Define the SQL for the specified RLS policy ("Allow authenticated users to read playlist aggregates").
- [x] Define the SQL for table and column comments as specified.
- [x] Define the SQL for the `update_playlist_aggregates_last_aggregated_at_on_update` trigger function.
- [x] Define the SQL for creating the trigger `trigger_update_playlist_aggregates_last_aggregated_at`.
- [x] Create a new Supabase migration file in `supabase/migrations/` named appropriately (e.g., `YYYYMMDDHHMMSS_create_playlist_track_artist_aggregates_table.sql`).
- [x] Add all defined SQL into the migration file.
- [x] Ensure the migration file includes descriptive header comments and comments for each significant SQL statement (table creation, RLS, policy, trigger function, trigger creation) as per `create-migration` rule.
- [x] (Manual step for developer) Apply the migration to the local Supabase instance and verify its successful application. (Completed using Supabase MCP `apply_migration`)
- [x] (Manual step for developer) Verify the table schema, RLS, policies, and trigger are correctly created in the database. (Partially verified using Supabase MCP `list_migrations` and `list_tables`. Table created, RLS enabled, comments verified. Specific policy and trigger existence require deeper inspection not fully possible with available tools without direct SQL query execution.)

## Testing Requirements

**Guidance:** Verify implementation against the ACs. Follow general testing approach in `docs/testing-strategy.md`.

- **Unit Tests:** Not directly applicable for a schema migration story. Verification is through application and inspection.
- **Integration Tests:** Not directly applicable.
- **Manual/CLI Verification:**
  - After applying the migration:
    - Use a SQL client or Supabase Studio to inspect the `playlist_track_artist_aggregates` table schema and confirm all columns, types, constraints (including the new `user_id` FK), and defaults match the definition.
    - Verify that RLS is enabled for the table.
    - Verify that the specified RLS policy exists and is correctly configured.
    - Verify that the trigger function `update_playlist_aggregates_last_aggregated_at_on_update` and the trigger `trigger_update_playlist_aggregates_last_aggregated_at` are created.
    - Verify comments on table and columns are present.
    - (Optional) Manually insert a row and then update it to check if `last_aggregated_at` updates automatically. This also helps verify `created_at` default.

## Story Wrap Up (Agent Populates After Execution)

- **Agent Model Used:** `Gemini 2.5 Pro`
- **Completion Notes:**
  - Created migration file `supabase/migrations/20250512065750_create_playlist_track_artist_aggregates_table.sql`.
  - Applied the migration to project `jaoksbhfyfyqubkmjvso` using `mcp_supabase_apply_migration`.
  - Verified migration application using `mcp_supabase_list_migrations`.
  - Verified table creation (`playlist_track_artist_aggregates`), RLS status, schema, and comments using `mcp_supabase_list_tables`.
  - The table `playlist_track_artist_aggregates` now exists with the specified schema and RLS enabled.
- **Change Log:**
  - Initial Draft
  - Migration file created and applied. Table schema, RLS, and comments verified. 
# Story 8.2: Populate Aggregate Table in Playlist Import Process

**Status:** Approved

## Goal & Context

**User Story:** As a developer, I want to modify the `importPlaylist` server action to populate the `playlist_track_artist_aggregates` table with aggregated track and artist data after a playlist is successfully imported or updated, so that this data is available for enhanced playlist matching.

**Context:** This story builds upon Story 8.1, which created the `playlist_track_artist_aggregates` table. This story will implement the logic to populate that table during the existing playlist import process found in `app/_actions/import-playlist.ts`.

## Detailed Requirements

Modify the `importPlaylist` server action (`app/_actions/import-playlist.ts`) to populate the newly created `playlist_track_artist_aggregates` table with aggregated track and artist data after a playlist is successfully imported or updated.

## Acceptance Criteria (ACs)

- AC1: The `importPlaylist` server action (`app/_actions/import-playlist.ts`) is updated to perform the following steps after successfully saving playlist metadata and tracks to `playlists` and `playlist_tracks` tables:
    - Construct the `tracks_json` data by mapping track details (e.g., `spotify_track_id`, `name`, `duration_ms`) from the imported playlist's tracks.
    - Construct the `artist_occurrences_json` data by:
        - Iterating through all tracks of the imported playlist.
        - For each track, iterating through its artists.
        - Aggregating occurrences for each unique artist (based on `spotify_artist_id`), storing their `spotify_artist_id`, `name`, and total `playlist_occurrences`.
    - Calculate `total_tracks` (count of items in `tracks_json`).
    - Calculate `distinct_artist_count` (count of items in `artist_occurrences_json`).
    - Identify the `user_id` for the aggregate record (this would typically be the `submitted_by_user_id` from the corresponding `playlists` record, or the current authenticated user's ID).
- AC2: An UPSERT (insert or update on conflict) operation is performed on the `playlist_track_artist_aggregates` table using `playlist_id` as the conflict target.
    - If a record for the `playlist_id` exists, it's updated with the new aggregated data.
    - If no record exists, a new one is inserted.
- AC3: The `last_aggregated_at` column in `playlist_track_artist_aggregates` is correctly updated by the database trigger (verified by checking timestamp post-operation, or implicitly by successful UPSERT).
- AC4: The logic for preparing `tracks_json` and `artist_occurrences_json` correctly matches the JSONB structures defined in Story 1.1.
- AC5: The `importPlaylist` action handles potential errors during the aggregation and UPSERT process gracefully, ensuring that failure to update aggregates does not necessarily roll back the primary playlist import if partial success is acceptable (e.g., logs an error but returns success for playlist import itself, or returns a specific status indicating partial success).
- AC6: Console logs are added to trace the aggregation data preparation and the result of the UPSERT operation for debugging purposes.
- AC7: The changes are made without negatively impacting the existing functionality of the `importPlaylist` action for saving primary playlist and track data.

## Technical Implementation Context

**Guidance:** Use the following details for implementation. Developer agent is expected to follow project standards in `docs/coding-standards.md`.

- **Relevant Files:**
  - Files to Create: None.
  - Files to Modify: `app/_actions/import-playlist.ts`.

- **Key Technologies:**
  - TypeScript
  - Supabase Client (for upserting data)

- **API Interactions / SDK Usage:**
  - Supabase client library for database operations (`upsert`).

- **Data Structures:**
  - `playlist_track_artist_aggregates` table schema (defined in Story 8.1, now including `user_id`).
  - JSONB structures for `tracks_json` and `artist_occurrences_json` (defined in Story 8.1):
    - `tracks_json`:
        ```json
        [
          {
            "spotify_track_id": "string",
            "name": "string",
            "duration_ms": "integer"
          }
        ]
        ```
    - `artist_occurrences_json`:
        ```json
        [
          {
            "spotify_artist_id": "string",
            "name": "string",
            "playlist_occurrences": "integer"
          }
        ]
        ```
  - The `importPlaylist` action already fetches playlist track data. This data will be the source for the aggregations. The existing `SpotifyPlaylistItem` and related types in `app/_actions/import-playlist.ts` will be relevant. The `user_id` to be inserted into `playlist_track_artist_aggregates` will need to be sourced, likely from the `submitted_by_user_id` of the `playlists` record or the currently authenticated user.

- **Environment Variables:**
  - None specific to this story beyond standard Supabase connection variables.

- **Coding Standards Notes:**
  - Follow TypeScript and project-specific coding standards outlined in `docs/coding-standards.md`.
  - Ensure error handling is robust and provides clear console logs for debugging the aggregation and UPSERT steps.
  - The new logic should be added towards the end of the successful import flow in `importPlaylist`, after `playlist_tracks` are saved.

## Tasks / Subtasks

- [x] Identify the section in `app/_actions/import-playlist.ts` where playlist and track data have been successfully saved to the database.
- [x] Implement logic to construct `tracks_json` array:
    - [x] Iterate through the fetched `spotifyTracksData` (or equivalent variable holding all playlist tracks).
    - [x] For each track, extract `id` (as `spotify_track_id`), `name`, and `duration_ms`.
    - [x] Map these to the `tracks_json` structure.
- [x] Implement logic to construct `artist_occurrences_json` array:
    - [x] Initialize an empty map or object to store artist counts (e.g., `Map<string, { spotify_artist_id: string; name: string; playlist_occurrences: number }>`).
    - [x] Iterate through `spotifyTracksData`.
    - [x] For each track, iterate through its `artists` array.
    - [x] For each artist, increment their count in the map. If the artist is not in the map, add them with a count of 1, storing their `id` (as `spotify_artist_id`) and `name`.
    - [x] Convert the map values into an array matching the `artist_occurrences_json` structure.
- [x] Calculate `total_tracks` as the length of the `tracks_json` array.
- [x] Calculate `distinct_artist_count` as the length of the `artist_occurrences_json` array.
- [x] Prepare the data object for upserting into `playlist_track_artist_aggregates` table, including `playlist_id` (which is `newPlaylistData.id` from the earlier part of the function), `user_id` (sourced from the playlist's `submitted_by_user_id` or current authenticated user), `tracks_json`, `artist_occurrences_json`, `total_tracks`, and `distinct_artist_count`.
- [x] Implement the Supabase UPSERT operation on `playlist_track_artist_aggregates`:
    - [x] Use `playlist_id` as the `onConflict` target.
    - [ ] Ensure the `returning` or `select` part of the upsert is minimal or not needed if relying on trigger for `last_aggregated_at`. (Currently not using `returning` or `select`)
- [x] Add console logs for the prepared aggregation data (`tracks_json`, `artist_occurrences_json`, counts) and the outcome of the UPSERT operation (success or error).
- [x] Implement error handling for the aggregation and UPSERT steps. Log errors but ensure the main playlist import can still be considered successful if this part fails (as per AC5). This might involve returning a specific status or modifying the `ImportPlaylistResult` interface. (Initial implementation done, `ImportPlaylistResult` updated, further refinement of return status for aggregation failure can be done if needed).
- [ ] Review and test to ensure existing playlist import functionality for `playlists` and `playlist_tracks` tables is not negatively impacted.

## Testing Requirements

**Guidance:** Verify implementation against the ACs. Follow general testing approach in `docs/testing-strategy.md`.

- **Unit Tests:**
    - Consider utility functions for `tracks_json` and `artist_occurrences_json` preparation if the logic becomes complex, and unit test these pure functions with mock data.
- **Integration Tests:** (More relevant here)
    - Test the `importPlaylist` server action end-to-end with a test Spotify playlist ID.
    - After a successful import, query the `playlist_track_artist_aggregates` table to verify:
        - A record exists for the imported `playlist_id`.
        - The `user_id` is correctly populated (e.g., matches `submitted_by_user_id` from the `playlists` table, or is NULL if appropriate).
        - `tracks_json` contains the correct track data and count.
        - `artist_occurrences_json` contains the correct artist data, occurrence counts, and distinct artist count.
        - `total_tracks` and `distinct_artist_count` columns are correctly populated.
        - `last_aggregated_at` is a recent timestamp.
    - Test the UPSERT functionality: import the same playlist again and verify the record in `playlist_track_artist_aggregates` is updated (check `last_aggregated_at` changes).
    - Test error handling: simulate an error during the aggregate UPSERT (e.g., by temporarily making `playlist_id` not unique in a test table if possible, or by mocking the Supabase client to throw an error for this specific upsert) and verify the `importPlaylist` function still completes for the primary data and logs the aggregation error.
- **Manual/CLI Verification:**
    - Trigger `importPlaylist` (e.g., via the application UI if available, or by calling the action directly in a test script).
    - Check console logs for tracing the aggregation data and UPSERT result.
    - Use Supabase Studio to inspect the `playlist_track_artist_aggregates` table for the newly imported/updated playlist and verify all fields as per integration tests.

## Story Wrap Up (Agent Populates After Execution)

- **Agent Model Used:** `<Agent Model Name/Version>`
- **Completion Notes:**
- **Change Log:**
  - Initial Draft 
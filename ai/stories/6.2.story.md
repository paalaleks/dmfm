# Story 6.2: Implement Playlist-User Matching PostgreSQL Function and Trigger

**Status:** Completed

## Goal & Context

**User Story:** As a system, I want to automatically evaluate if a newly imported playlist matches the taste of existing users, so that potential connections can be surfaced for notification or discovery features.

**Context:** This is the second story in Epic 6, following the implementation of the Jaccard Index calculation function in Story 6.1. In this story, we'll implement the main PostgreSQL function `match_playlist_to_users` and its associated trigger. This function will run automatically whenever a playlist's artist aggregate data is inserted or updated, comparing the playlist's artists against each user's taste profile and recording matches in the `user_playlist_matches` table.

## Detailed Requirements

We need to implement two PostgreSQL components:

1. A main function `match_playlist_to_users` that:
   - Extracts artist IDs from a playlist's aggregate data
   - Iterates through users (excluding the playlist submitter)
   - For each user, builds a taste profile from their top artists and other imported playlists
   - Calculates the Jaccard Index similarity between the playlist and user's taste profile
   - Records matches that exceed a defined threshold in the `user_playlist_matches` table

2. A trigger `trigger_playlist_user_matching_on_aggregates` that:
   - Executes after INSERT or UPDATE of `artists_json` on `playlist_track_artist_aggregates`
   - Runs the `match_playlist_to_users` function for each affected row

The implementation must handle edge cases gracefully, including users with no taste profile data and playlists with no artists in their aggregates.

## Acceptance Criteria (ACs)

- AC1: The `match_playlist_to_users` PostgreSQL function is successfully created with the following capabilities:
  - Correctly extracts artist IDs from `artists_json`
  - Correctly aggregates a user's taste profile from `user_top_artists` and their other playlists
  - Excludes the playlist's submitter from being matched with their own playlist
  - Identifies and records matches in `user_playlist_matches` when the Jaccard score meets/exceeds threshold
  - Handles NULL/empty inputs gracefully

- AC2: The function uses the `calculate_jaccard_index_text_arrays` function created in Story 6.1

- AC3: The `trigger_playlist_user_matching_on_aggregates` trigger is successfully created on the `public.playlist_track_artist_aggregates` table

- AC4: The trigger correctly executes the `match_playlist_to_users` function after relevant INSERT or UPDATE operations

- AC5: The system handles edge cases gracefully:
  - Users with no taste profile data (no matches generated)
  - Playlists with no artists in their aggregates (function exits early)
  - Duplicate match attempts (ON CONFLICT clause prevents duplicates)

- AC6: The function includes appropriate error handling and logging

## Technical Implementation Context

**Guidance:** Use the following details for implementation. Developer agent is expected to follow project standards in `docs/coding-standards.md` and understand the project structure in `docs/project-structure.md`. Only story-specific details are included below.

- **Relevant Files:**
  - Files to Create: N/A (This will be implemented as a SQL migration)
  - Files to Modify: N/A

- **Key Technologies:**
  - PostgreSQL function in PL/pgSQL
  - PostgreSQL trigger
  - Supabase for executing the migration

- **API Interactions / SDK Usage:**
  - Supabase's `supabase-js` SDK for applying migrations
  - Project's Supabase reference: `jaoksbhfyfyqubkmjvso` (from supabase-project-ref)

- **Data Structures:**
  - The `playlist_track_artist_aggregates.artists_json` structure:
    ```json
    [
      {
        "spotify_artist_id": "string",
        "name": "string",
        "playlist_occurrences": "integer"
      }
    ]
    ```
  - The `user_playlist_matches` table structure (already exists):
    ```sql
    CREATE TABLE public.user_playlist_matches (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
        playlist_id UUID NOT NULL REFERENCES public.playlists(id) ON DELETE CASCADE,
        matched_at TIMESTAMPTZ DEFAULT now() NOT NULL,
        CONSTRAINT uq_user_playlist_match UNIQUE (user_id, playlist_id)
    );
    ```

- **SQL Implementation Details:**
  ```sql
  CREATE OR REPLACE FUNCTION public.match_playlist_to_users()
  RETURNS TRIGGER AS $$
  DECLARE
      playlist_artist_ids TEXT[];
      playlist_submitter_id UUID;
      current_user_id UUID;
      user_artist_ids TEXT[];
      current_user_top_artists TEXT[];
      current_user_playlist_aggregate_artists JSONB;
      artist_record JSONB;
      similarity_score FLOAT;
      -- Configuration:
      SIMILARITY_THRESHOLD FLOAT := 0.01; -- 1% similarity threshold
  BEGIN
      -- 1. Extract artist IDs from the new/updated playlist's aggregates
      SELECT array_agg(DISTINCT artist_data->>'spotify_artist_id')
      INTO playlist_artist_ids
      FROM jsonb_array_elements(NEW.artists_json) AS artist_data
      WHERE artist_data->>'spotify_artist_id' IS NOT NULL;

      IF playlist_artist_ids IS NULL OR array_length(playlist_artist_ids, 1) = 0 THEN
          RETURN NULL; -- No artists in the new playlist to match against
      END IF;

      -- 2. Get the submitter of the playlist to exclude them from matching
      SELECT submitted_by_user_id INTO playlist_submitter_id
      FROM public.playlists
      WHERE id = NEW.playlist_id;

      -- 3. Loop through each user in public.profiles
      FOR current_user_id IN SELECT id FROM public.profiles LOOP
          -- Skip if the current user is the one who submitted this playlist
          IF playlist_submitter_id IS NOT NULL AND current_user_id = playlist_submitter_id THEN
              CONTINUE;
          END IF;

          user_artist_ids := ARRAY[]::TEXT[]; -- Initialize/reset for each user

          -- 4a. Fetch user's top artists
          SELECT array_agg(artist_spotify_id)
          INTO current_user_top_artists
          FROM public.user_top_artists
          WHERE user_id = current_user_id;

          IF current_user_top_artists IS NOT NULL THEN
              user_artist_ids := array_cat(user_artist_ids, current_user_top_artists);
          END IF;

          -- 4b. Fetch artists from user's other playlist aggregates
          FOR current_user_playlist_aggregate_artists IN
              SELECT ptaa.artists_json
              FROM public.playlist_track_artist_aggregates ptaa
              JOIN public.playlists p ON ptaa.playlist_id = p.id
              WHERE p.submitted_by_user_id = current_user_id AND ptaa.playlist_id != NEW.playlist_id -- Exclude the current playlist being processed
          LOOP
              FOR artist_record IN SELECT * FROM jsonb_array_elements(current_user_playlist_aggregate_artists) LOOP
                  IF artist_record->>'spotify_artist_id' IS NOT NULL THEN
                      user_artist_ids := array_append(user_artist_ids, artist_record->>'spotify_artist_id');
                  END IF;
              END LOOP;
          END LOOP;
          
          -- Ensure unique artist IDs for the user
          IF array_length(user_artist_ids, 1) > 0 THEN
               SELECT array_agg(DISTINCT e) INTO user_artist_ids FROM unnest(user_artist_ids) e;
          END IF;

          IF user_artist_ids IS NULL OR array_length(user_artist_ids, 1) = 0 THEN
              CONTINUE; -- User has no artists in their profile, skip.
          END IF;

          -- 5. Calculate Jaccard Index
          similarity_score := public.calculate_jaccard_index_text_arrays(playlist_artist_ids, user_artist_ids);

          -- 6. If score meets threshold, insert into user_playlist_matches
          IF similarity_score >= SIMILARITY_THRESHOLD THEN
              INSERT INTO public.user_playlist_matches (user_id, playlist_id, matched_at)
              VALUES (current_user_id, NEW.playlist_id, now())
              ON CONFLICT (user_id, playlist_id) DO NOTHING;
          END IF;

      END LOOP;

      RETURN NULL; -- Result of trigger is not used
  EXCEPTION
      WHEN OTHERS THEN
          RETURN NULL;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  COMMENT ON FUNCTION public.match_playlist_to_users() IS 'Trigger function to match a newly aggregated playlist against all users based on artist similarity. Inserts matches into user_playlist_matches.';

  CREATE TRIGGER trigger_playlist_user_matching_on_aggregates
  AFTER INSERT OR UPDATE ON public.playlist_track_artist_aggregates
  FOR EACH ROW
  EXECUTE FUNCTION public.match_playlist_to_users();

  COMMENT ON TRIGGER trigger_playlist_user_matching_on_aggregates ON public.playlist_track_artist_aggregates IS 'When playlist aggregates are inserted or updated, triggers the matching logic to find relevant users.';
  ```

## Tasks / Subtasks

- [x] Create a migration file to implement the `match_playlist_to_users` PostgreSQL function
- [x] Implement the function's logic to:
  - [x] Extract artist IDs from a playlist's aggregate data
  - [x] Iterate through users (excluding the playlist submitter)
  - [x] Build a taste profile for each user
  - [x] Calculate similarity using `calculate_jaccard_index_text_arrays`
  - [x] Record matches that exceed the threshold
- [x] Add error handling for edge cases
- [x] Create the `trigger_playlist_user_matching_on_aggregates` trigger
- [x] Add appropriate function and trigger comments

## Testing Requirements

**Guidance:** Verify implementation against the ACs using the following tests. Follow general testing approach in `docs/testing-strategy.md`.

- **Unit Tests:** Test the function with various input cases:
  - [x] Playlist with artists, multiple users with diverse taste profiles
  - [x] Playlist submitted by a user (verify submitter exclusion)
  - [x] Users with no taste profile data
  - [x] Playlist with no artists in its aggregate
  - [x] Function handles errors gracefully

- **Manual Verification:** 
  - [x] Execute SQL queries to verify the trigger fires when `playlist_track_artist_aggregates` is updated
  - [x] Verify matches are correctly inserted into `user_playlist_matches`
  - [x] Verify duplicate matches are handled correctly
  - [x] Test edge cases manually

## Story Wrap Up (Agent Populates After Execution)

- **Agent Model Used:** `Claude 3.7 Sonnet`
- **Completion Notes:** 
  - The function and trigger were implemented successfully, but we encountered several syntax errors while working with PostgreSQL's PL/pgSQL.
  - The main issue was with variable declarations and record access syntax in PL/pgSQL. We initially tried using `RECORD` types with field access (`record.field`), but this caused syntax errors.
  - We resolved this by changing the approach to directly iterate over UUIDs instead of records and using simple variable names.
  - When implementing the function, we had to use the correct function body delimiters (`$function_name$`) as PostgreSQL is sensitive to the delimiter syntax.
  - The function correctly excludes the playlist submitter from being matched with their own playlists.
  - Testing confirmed the function works as expected, creating entries in the `user_playlist_matches` table when playlists and users have sufficiently similar artist profiles.

- **Change Log:**
  - Initial Draft
  - Added implementation details and fixed PostgreSQL syntax issues
  - Completed implementation and testing 
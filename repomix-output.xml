This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ai/**, .cursor/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.eslintrc.json
.gitignore
.prettierrc.json
app/_actions/chat.ts
app/_actions/delete-playlist.ts
app/_actions/import-playlist.ts
app/_actions/top-items.ts
app/(protected)/chat/[chatId]/loading.tsx
app/(protected)/chat/[chatId]/page.tsx
app/(protected)/chat/page.tsx
app/(protected)/layout.tsx
app/(protected)/profile/page.tsx
app/(protected)/profile/play-history/page.tsx
app/(protected)/profile/playlists/loading.tsx
app/(protected)/profile/playlists/page.tsx
app/(protected)/profile/playlists/playlist-import-form.tsx
app/(protected)/profile/playlists/user-playlists-display.tsx
app/(protected)/profile/profile-page/page.tsx
app/api/spotify/refresh-token/route.ts
app/auth/error/page.tsx
app/auth/login/page.tsx
app/auth/oauth/route.ts
app/globals.css
app/layout.tsx
app/loading.tsx
app/page.tsx
components.json
components/avatar-stack.tsx
components/chat-message.tsx
components/current-user-avatar.tsx
components/login-form.tsx
components/nav/logout-action.ts
components/nav/logout-button.tsx
components/nav/nav.tsx
components/nav/notifications.tsx
components/player/player-trigger.tsx
components/player/player.tsx
components/player/VolumePopover.tsx
components/realtime-chat-loader.tsx
components/realtime-chat.tsx
components/record-spin-loader.tsx
components/ui/avatar.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/input.tsx
components/ui/popover.tsx
components/ui/skeleton.tsx
components/ui/slider.tsx
components/ui/sonner.tsx
components/ui/tooltip.tsx
eslint.config.mjs
hooks/use-chat-scroll.tsx
hooks/use-current-user-image.ts
hooks/use-current-user-name.ts
hooks/use-local-storage.ts
hooks/use-realtime-chat.tsx
hooks/use-realtime-presence-room.ts
jest.config.js
lib/cloudinary-urls.ts
lib/spotify-accesstoken.ts
lib/supabase/__mocks__/server.ts
lib/supabase/client.ts
lib/supabase/middleware.ts
lib/supabase/server.ts
lib/utils.ts
middleware.ts
music-context/music-context.tsx
music-context/playlist-actions.ts
music-context/spotify-api.ts
music-context/spotify-helpers.ts
music-context/token-manager.ts
music-context/user-session.ts
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
repomix.config.json
supabase/migrations/20240401120000_create_notification_system.sql
supabase/migrations/20240401120100_create_notification_rpcs.sql
supabase/migrations/20250512065750_create_playlist_track_artist_aggregates_table.sql
supabase/migrations/temp_add_album_spotify_id_to_user_top_tracks.sql
supabase/migrations/YYYYMMDDHHMMSS_create_playlist_and_taste_tables.sql
tsconfig.json
types/actions.ts
types/auth.ts
types/database.ts
types/music-context.ts
types/spotify.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(protected)/chat/[chatId]/loading.tsx">
import RecordSpinLoader from "@/components/record-spin-loader";
import React from "react";

export default function loading() {
  return (
    <div className="h-dvh flex justify-center items-center">
      <RecordSpinLoader />
    </div>
  );
}
</file>

<file path="app/(protected)/profile/playlists/loading.tsx">
import RecordSpinLoader from "@/components/record-spin-loader";
import React from "react";

export default function loading() {
  return (
    <div className="h-dvh flex justify-center items-center">
      <RecordSpinLoader />
    </div>
  );
}
</file>

<file path="app/(protected)/profile/profile-page/page.tsx">
import { createClient } from '@/lib/supabase/server';
import { Database } from '@/types/database';
import React from 'react';
import Image from 'next/image';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

type TopArtist = Database['public']['Tables']['user_top_artists']['Row'];
type TopTrack = Database['public']['Tables']['user_top_tracks']['Row'];

// Define a more specific type for the artist objects within track.artists (JSONB)
interface TrackArtist {
  spotify_id: string;
  name: string;
}

export default async function ProfilePage() {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  let topArtists: TopArtist[] = [];
  let topTracks: TopTrack[] = [];
  let fetchError: string | null = null;

  if (user) {
    const { data: artistsData, error: artistsError } = await supabase
      .from('user_top_artists')
      .select('*')
      .eq('user_id', user.id)
      .order('popularity', { ascending: false })
      .limit(10);

    if (artistsError) {
      console.error('Error fetching top artists for profile:', artistsError.message);
      fetchError = 'Could not load top artists.';
    } else {
      topArtists = artistsData || [];
    }

    const { data: tracksData, error: tracksError } = await supabase
      .from('user_top_tracks')
      .select('*')
      .eq('user_id', user.id)
      .order('popularity', { ascending: false })
      .limit(10);

    if (tracksError) {
      console.error('Error fetching top tracks for profile:', tracksError.message);
      if (fetchError) fetchError += ' Also, could not load top tracks.';
      else fetchError = 'Could not load top tracks.';
    } else {
      topTracks = tracksData || [];
    }
  } else {
    // Handle case where user is not authenticated, though route protection should ideally handle this
    // For a server component, this might mean redirecting or showing a login prompt.
    // For now, will result in empty lists.
  }

  return (
    <div className='mx-auto p-4 z-10 relative pt-14'>
      {user ? (
        <div className='grid md:grid-cols-2 gap-8'>
          <Card className='shadow-md'>
            <CardHeader className='pt-4'>
              <CardTitle>Your Top Artists</CardTitle>
            </CardHeader>
            {topArtists.length > 0 ? (
              <CardContent as='ul' className='space-y-3'>
                {topArtists.map((artist) => (
                  <li
                    key={artist.artist_spotify_id}
                    className='flex items-center space-x-3 p-3 border-b last:border-b-0'
                  >
                    {artist.image_url && (
                      <Image
                        src={artist.image_url}
                        alt={artist.name}
                        className='w-12 h-12 rounded-full object-cover'
                        width={48}
                        height={48}
                      />
                    )}
                    <div>
                      <p className='font-medium '>{artist.name}</p>
                      {artist.genres &&
                        Array.isArray(artist.genres) &&
                        artist.genres.length > 0 && (
                          <p className='text-sm capitalize'>
                            {(artist.genres as string[]).slice(0, 3).join(', ')}
                          </p>
                        )}
                    </div>
                  </li>
                ))}
              </CardContent>
            ) : (
              <CardContent>
                <p>No top artists available yet. Listen to some music on Spotify!</p>
              </CardContent>
            )}
          </Card>

          <Card className=' shadow-md'>
            <CardHeader className='pt-4'>
              <CardTitle>Your Top Tracks</CardTitle>
            </CardHeader>
            {topTracks.length > 0 ? (
              <CardContent as='ul'>
                <ul className='space-y-3'>
                  {topTracks.map((track) => {
                    let artistNames = 'Unknown Artist';
                    if (track.artists && Array.isArray(track.artists)) {
                      const currentTrackArtists = track.artists as unknown as TrackArtist[];
                      artistNames = currentTrackArtists.map((a: TrackArtist) => a.name).join(', ');
                    }
                    return (
                      <li
                        key={track.track_spotify_id}
                        className='flex items-center space-x-3 p-3 border-b last:border-b-0'
                      >
                        {track.album_image_url && (
                          <Image
                            src={track.album_image_url}
                            alt={track.album_name ?? track.name}
                            className='w-12 h-12 rounded-md object-cover'
                            width={48}
                            height={48}
                          />
                        )}
                        <div>
                          <p className='font-medium '>{track.name}</p>
                          <p className='text-sm '>{artistNames}</p>
                          {track.album_name && <p className='text-xs '>{track.album_name}</p>}
                        </div>
                      </li>
                    );
                  })}
                </ul>
              </CardContent>
            ) : (
              <CardContent>
                <p>No top tracks available yet. Listen to some music on Spotify!</p>
              </CardContent>
            )}
          </Card>
        </div>
      ) : (
        <Card className='text-center text-gray-600'>
          <CardContent>Please log in to see your profile and top items.</CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="app/loading.tsx">
import RecordSpinLoader from "@/components/record-spin-loader";
import React from "react";

export default function loading() {
  return (
    <div className="h-dvh flex justify-center items-center">
      <RecordSpinLoader />
    </div>
  );
}
</file>

<file path="components/record-spin-loader.tsx">
import { Disc3 } from "lucide-react";
import React from "react";

export default function RecordSpinLoader() {
  return (
    <Disc3
      className={`animate-spin relative z-50 h-6 w-6 text-muted-foreground`}
      size={20}
    />
  );
}
</file>

<file path="hooks/use-local-storage.ts">
import { useState, useEffect, useCallback } from 'react';

/**
 * A custom React hook to manage state synchronized with the browser's local storage.
 *
 * @template T The type of the value to be stored.
 * @param {string} key The key under which the value is stored in local storage.
 * @param {T | (() => T)} initialValue The initial value to use if no value is found in local storage.
 *                                      Can be a value or a function for lazy initialization.
 * @returns {[T, (value: T | ((val: T) => T)) => void]} A stateful value and a function to update it.
 */
function useLocalStorage<T>(
  key: string,
  initialValue: T | (() => T)
): [T, (value: T | ((val: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    // Check for localStorage availability (SSR and browser)
    if (typeof window === 'undefined') {
      return initialValue instanceof Function ? initialValue() : initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      if (item) {
        return JSON.parse(item) as T;
      }
    } catch (error) {
      // If error parsing, or any other localStorage error, log it and fall back to initialValue
      console.error(`Error reading localStorage key "${key}":`, error);
    }

    return initialValue instanceof Function ? initialValue() : initialValue;
  });

  // Update localStorage when storedValue changes
  useEffect(() => {
    // Check for localStorage availability
    if (typeof window === 'undefined') {
      return;
    }

    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = storedValue;
      if (valueToStore === undefined) {
        window.localStorage.removeItem(key);
      } else {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      // If error setting, or any other localStorage error, log it
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  const setValue = useCallback(
    (value: T | ((val: T) => T)) => {
      try {
        // Allow value to be a function so we have the same API as useState
        const valueToSet = value instanceof Function ? value(storedValue) : value;
        // Save state
        setStoredValue(valueToSet);
      } catch (error) {
        // A more advanced implementation would handle the error case
        console.error(`Error setting value for key "${key}":`, error);
      }
    },
    [key, storedValue, setStoredValue]
  );

  return [storedValue, setValue];
}

export default useLocalStorage;
</file>

<file path="repomix.config.json">
{
  "ignore": {
    "customPatterns": ["ai/**", ".cursor/**"]
  }
}
</file>

<file path=".eslintrc.json">
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "plugin:jsx-a11y/recommended",
    "prettier" // Make sure this is last to override other formatting rules
  ],
  "plugins": [
    "@typescript-eslint",
    "jsx-a11y",
    "prettier" // Enables eslint-plugin-prettier
  ],
  "rules": {
    "prettier/prettier": "error" // Report Prettier rule violations as ESLint errors
    // Add any specific project rule overrides here. For example:
    // "@typescript-eslint/no-unused-vars": "warn",
    // "jsx-a11y/anchor-is-valid": "off" // Often needed for Next.js <Link> components
  },
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".prettierrc.json">
{
  "semi": true,
  "singleQuote": true,
  "jsxSingleQuote": true,
  "trailingComma": "es5",
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}
</file>

<file path="app/_actions/chat.ts">
'use server';

import { createClient } from '@/lib/supabase/server';
// import { cookies } from 'next/headers'; // createClient in server.ts handles this internally
import { z } from 'zod';
import type { Tables } from '@/types/database';

// Define the schema for input validation
const sendMessageSchema = z.object({
  roomId: z.string().uuid(),
  content: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
  clientSideId: z.string().uuid(),
});

// Schema for editing a message
const editMessageSchema = z.object({
  messageId: z.number().int().positive('Invalid message ID'),
  newContent: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
});

// Schema for deleting a message
const deleteMessageSchema = z.object({
  messageId: z.number().int().positive('Invalid message ID'),
});

export interface ActionResult {
  success: boolean;
  message?: string;
  error?: string | null;
  data?: (Partial<Tables<'chat_messages'>> & { originalClientSideId?: string }) | null;
}

export async function sendMessage(
  prevState: ActionResult | undefined,
  formData: FormData
): Promise<ActionResult> {
  const supabase = await createClient();

  // 1. Get current user
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: 'User not authenticated' };
  }

  // 2. Validate input
  const rawInput = {
    roomId: formData.get('roomId') as string,
    content: formData.get('content') as string,
    clientSideId: formData.get('clientSideId') as string,
  };

  const validatedInput = sendMessageSchema.safeParse(rawInput);

  if (!validatedInput.success) {
    return {
      success: false,
      error: 'Invalid input: ' + validatedInput.error.errors.map((e) => e.message).join(', '),
    };
  }

  const { roomId, content, clientSideId } = validatedInput.data;

  // 3. Insert message into the database
  try {
    const { data: messageData, error: insertError } = await supabase
      .from('chat_messages')
      .insert({
        room_id: roomId,
        user_id: user.id,
        content: content,
      })
      .select('id, created_at, content, user_id, room_id')
      .single();

    if (insertError) {
      console.error('Error inserting message:', insertError);
      return { success: false, error: 'Failed to send message: ' + insertError.message };
    }

    // Optional: Revalidate path
    // revalidatePath(`/chat/${roomId}`) // Example

    return {
      success: true,
      message: 'Message sent',
      data: { ...messageData, originalClientSideId: clientSideId },
    };
  } catch (e: unknown) {
    let errorMessage = 'An unexpected error occurred';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    console.error('Unexpected error in sendMessage action:', e);
    return { success: false, error: errorMessage };
  }
}

export async function editMessage(messageId: number, newContent: string): Promise<ActionResult> {
  const supabase = await createClient();

  // 1. Get current user
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: 'User not authenticated' };
  }

  // 2. Validate input
  const validatedInput = editMessageSchema.safeParse({ messageId, newContent });

  if (!validatedInput.success) {
    return {
      success: false,
      error: 'Invalid input: ' + validatedInput.error.errors.map((e) => e.message).join(', '),
    };
  }

  const { messageId: validatedMessageId, newContent: validatedNewContent } = validatedInput.data;

  try {
    // 3. Verify ownership and update message
    const { data: existingMessage, error: fetchError } = await supabase
      .from('chat_messages')
      .select('id, user_id')
      .eq('id', validatedMessageId)
      .single();

    if (fetchError) {
      console.error('Error fetching message for edit:', fetchError);
      return { success: false, error: 'Message not found or error fetching it.' };
    }

    if (existingMessage.user_id !== user.id) {
      return { success: false, error: 'User not authorized to edit this message.' };
    }

    const { data: updatedMessageData, error: updateError } = await supabase
      .from('chat_messages')
      .update({ content: validatedNewContent }) // Consider adding updated_at if schema changes
      .eq('id', validatedMessageId)
      .select('id, created_at, content, user_id, room_id')
      .single();

    if (updateError) {
      console.error('Error updating message:', updateError);
      return { success: false, error: 'Failed to edit message: ' + updateError.message };
    }

    return { success: true, message: 'Message edited', data: updatedMessageData };
  } catch (e: unknown) {
    let errorMessage = 'An unexpected error occurred during edit';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    console.error('Unexpected error in editMessage action:', e);
    return { success: false, error: errorMessage };
  }
}

export async function deleteMessage(messageId: number): Promise<ActionResult> {
  const supabase = await createClient();

  // 1. Get current user
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: 'User not authenticated' };
  }

  // 2. Validate input
  const validatedInput = deleteMessageSchema.safeParse({ messageId });

  if (!validatedInput.success) {
    return {
      success: false,
      error: 'Invalid input: ' + validatedInput.error.errors.map((e) => e.message).join(', '),
    };
  }

  const { messageId: validatedMessageId } = validatedInput.data;

  try {
    // 3. Verify ownership
    const { data: existingMessage, error: fetchError } = await supabase
      .from('chat_messages')
      .select('id, user_id')
      .eq('id', validatedMessageId)
      .single();

    if (fetchError) {
      console.error('Error fetching message for delete:', fetchError);
      return { success: false, error: 'Message not found or error fetching it.' };
    }

    if (existingMessage.user_id !== user.id) {
      return { success: false, error: 'User not authorized to delete this message.' };
    }

    // 4. Delete message
    const { error: deleteError } = await supabase
      .from('chat_messages')
      .delete()
      .eq('id', validatedMessageId);

    if (deleteError) {
      console.error('Error deleting message:', deleteError);
      return { success: false, error: 'Failed to delete message: ' + deleteError.message };
    }

    return { success: true, message: 'Message deleted', data: { id: validatedMessageId } }; // Return the ID of the deleted message
  } catch (e: unknown) {
    let errorMessage = 'An unexpected error occurred during delete';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    console.error('Unexpected error in deleteMessage action:', e);
    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/_actions/delete-playlist.ts">
'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';

interface DeleteResult {
  success: boolean;
  error?: string | null;
}

export async function deleteUserPlaylist(playlistId: string): Promise<DeleteResult> {
  const supabase = await createClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    console.error('Delete playlist: Authentication error', authError);
    return { success: false, error: 'User not authenticated. Please log in again.' };
  }

  if (!playlistId) {
    return { success: false, error: 'Playlist ID is required.' };
  }

  try {
    // First, verify the playlist belongs to the user and exists
    const { data: playlistData, error: fetchError } = await supabase
      .from('playlists')
      .select('id, submitted_by_user_id')
      .eq('id', playlistId)
      .single(); // Use .single() to expect one row or error

    if (fetchError) {
      if (fetchError.code === 'PGRST116') {
        // PostgREST error for zero rows with .single()
        console.warn(`Delete playlist: Playlist ID ${playlistId} not found.`);
        return { success: false, error: 'Playlist not found.' };
      }
      console.error('Delete playlist: Error fetching playlist for verification:', fetchError);
      return { success: false, error: `Error verifying playlist: ${fetchError.message}` };
    }

    if (!playlistData) {
      // Should be caught by PGRST116 but good to double check
      console.warn(`Delete playlist: Playlist ID ${playlistId} not found (after fetch).`);
      return { success: false, error: 'Playlist not found.' };
    }

    if (playlistData.submitted_by_user_id !== user.id) {
      console.warn(
        `Delete playlist: User ${user.id} attempted to delete playlist ${playlistId} owned by ${playlistData.submitted_by_user_id}.`
      );
      return { success: false, error: 'You are not authorized to delete this playlist.' };
    }

    // Proceed with deletion
    const { data: deletedRecords, error: deleteError } = await supabase
      .from('playlists')
      .delete()
      .eq('id', playlistId)
      .select(); // Add .select() to get the deleted records back

    if (deleteError) {
      console.error('Delete playlist: Error deleting playlist:', deleteError);
      return { success: false, error: `Failed to delete playlist: ${deleteError.message}` };
    }

    // Check if any records were actually deleted
    // If deletedRecords is null or empty, it means no rows were affected by the delete operation.
    if (!deletedRecords || deletedRecords.length === 0) {
      console.warn(
        `Delete playlist: Delete operation on playlist ID ${playlistId} by user ${user.id} affected 0 rows. This could be due to RLS, a trigger, or the record already being gone.`
      );
      return {
        success: false,
        error:
          'Failed to delete the playlist. The record may have already been removed, or the operation was blocked.',
      };
    }

    console.log(
      `Playlist ${playlistId} deleted successfully by user ${user.id}. Affected records: ${deletedRecords.length}`
    );

    // Revalidate the path to update the UI if using Next.js App Router with caching
    revalidatePath('/profile/playlists');

    return { success: true };
  } catch (e: unknown) {
    console.error('Delete playlist: Unexpected error:', e);
    let errorMessage = 'An unexpected error occurred during deletion.';
    if (e instanceof Error && e.message) {
      errorMessage = e.message;
    }
    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/(protected)/chat/page.tsx">
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import type { SupabaseClient } from '@supabase/supabase-js';

// Helper function to get the default chat room ID
async function getDefaultChatRoomId(supabase: SupabaseClient): Promise<string | null> {
  const { data: room, error } = await supabase
    .from('chat_rooms')
    .select('id')
    .eq('is_default_room', true) // Changed to use the boolean flag
    .maybeSingle();

  if (error) {
    console.error('Error fetching default chat room:', error);
    return null;
  }
  return room?.id || null;
}

export default async function ChatRedirectPage() {
  const supabase = await createClient();

  // Optional: Check if user is authenticated before redirecting.
  // If unauthenticated, could redirect to login first, or let the target [chatId] page handle it.
  // For simplicity here, we'll assume the [chatId] page handles auth checks robustly.

  const defaultRoomId = await getDefaultChatRoomId(supabase);

  if (defaultRoomId) {
    redirect(`/chat/${defaultRoomId}`);
  } else {
    // Fallback if default room ID isn't found (shouldn't happen with correct seeding)
    // Could redirect to a general error page or a page to create rooms, etc.
    // For now, a simple message or redirect to home.
    console.error('Default chat room not found. Cannot redirect.');
    // Or redirect to a generic error page or home
    // redirect('/?error=default_room_missing');
    return (
      <div className='flex flex-col items-center justify-center h-screen'>
        <h1 className='text-2xl font-semibold mb-4'>Default Chat Room Not Found</h1>
        <p>The system could not find the default chat room. Please contact support.</p>
      </div>
    );
  }
  // This return is technically unreachable if redirect occurs or an error component is returned,
  // but linters/compilers might appreciate a clear path.
  return null;
}
</file>

<file path="app/(protected)/profile/play-history/page.tsx">
import React from 'react';

export default function PlayHistory() {
  return <div>PlayHistory</div>;
}
</file>

<file path="app/(protected)/profile/playlists/page.tsx">
import React from 'react';
import PlaylistImportForm from './playlist-import-form';
import UserPlaylistsDisplay from './user-playlists-display';
import { createClient } from '@/lib/supabase/server';
import type { Tables } from '@/types/database';
import { Card, CardHeader, CardTitle } from '@/components/ui/card';
import { revalidatePath } from 'next/cache';

// Type for the data as returned by the Supabase query
// Uses Pick to select only the fields explicitly queried, plus the joined track count.
// This matches the shape of data returned by the .select() call.
type FetchedPlaylistData = Pick<
  Tables<'playlists'>,
  'id' | 'name' | 'spotify_playlist_id' | 'image_url'
> & {
  playlist_tracks: { count: number }[];
};

// Interface for the playlist data shaped for display in the client component
interface DisplayPlaylist {
  id: string;
  playlist_name: string;
  spotify_playlist_id: string;
  playlist_cover_image_url: string | null;
  track_count: number;
}

export default async function PlaylistsPage() {
  const supabase = await createClient();

  let playlists: DisplayPlaylist[] = [];
  let fetchError: string | null = null;

  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError || !user) {
    fetchError = 'Could not authenticate user. Please try logging in again.';
  } else {
    try {
      const { data, error: dbError } = await supabase
        .from('playlists')
        .select(
          `
          id,
          name,
          spotify_playlist_id,
          image_url,
          playlist_tracks(count)
        `
        )
        .eq('submitted_by_user_id', user.id)
        .order('created_at', { ascending: false });

      if (dbError) {
        console.error('Error fetching playlists:', dbError);
        fetchError = `Failed to load playlists: ${dbError.message}`;
      } else if (data) {
        // Data from Supabase select will match the fields selected.
        // Explicitly casting `data` to `FetchedPlaylistData[]` if TS inference is not precise enough,
        // or ensuring `p` in map matches the inferred structure of `data` elements.
        playlists = (data as FetchedPlaylistData[]).map(
          (p: FetchedPlaylistData): DisplayPlaylist => ({
            id: p.id,
            playlist_name: p.name,
            spotify_playlist_id: p.spotify_playlist_id,
            playlist_cover_image_url: p.image_url,
            track_count:
              p.playlist_tracks && p.playlist_tracks.length > 0 ? p.playlist_tracks[0].count : 0,
          })
        );
      }
    } catch (e) {
      console.error('Unexpected error fetching playlists:', e);
      if (e instanceof Error) {
        fetchError = `An unexpected error occurred while fetching playlists: ${e.message}`;
      } else {
        fetchError = 'An unexpected error occurred while fetching playlists.';
      }
    }
  }

  const handleImportSuccess = async () => {
    'use server';
    revalidatePath('/profile/playlists');
  };

  return (
    <div className='mx-auto p-4 z-10 relative pt-16 w-full '>
      <Card className='mb-8 p-6 bg-accent border-none shadow-md rounded-lg max-w-xl mx-auto'>
        <CardHeader>
          <CardTitle>Import Spotify Playlist</CardTitle>
        </CardHeader>
        <PlaylistImportForm onImportSuccess={handleImportSuccess} />
      </Card>

      <div className='mt-12'>
        <h3 className='text-2xl font-semibold mb-6 text-center'>Your Imported Playlists</h3>
        <UserPlaylistsDisplay initialPlaylists={playlists} initialError={fetchError} />
      </div>
    </div>
  );
}
</file>

<file path="app/(protected)/profile/playlists/playlist-import-form.tsx">
'use client';

import { useState, useTransition } from 'react';
// Assuming the server action is at app/_actions/import-playlist.ts
// The relative path from app/(main)/profile/ to app/_actions/ is ../../_actions/
import { importPlaylist, type ImportPlaylistResult } from '@/app/_actions/import-playlist';
import { Button } from '@/components/ui/button';
import { CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';

interface PlaylistImportFormProps {
  onImportSuccess?: () => void;
}

export default function PlaylistImportForm({ onImportSuccess }: PlaylistImportFormProps) {
  const [inputValue, setInputValue] = useState('');
  const [message, setMessage] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isPending, startTransition] = useTransition();

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setMessage(null);
    setError(null);

    let finalPlaylistId = inputValue.trim();
    if (!finalPlaylistId) {
      setError('Please enter a Spotify Playlist ID or URL.');
      return;
    }

    // Try to extract ID from URL
    try {
      // Check if it's a Spotify URL
      if (finalPlaylistId.includes('open.spotify.com/playlist/')) {
        const url = new URL(finalPlaylistId);
        const pathParts = url.pathname.split('/');
        const playlistIndex = pathParts.indexOf('playlist');
        if (playlistIndex !== -1 && pathParts.length > playlistIndex + 1) {
          finalPlaylistId = pathParts[playlistIndex + 1].split('?')[0]; // Remove query params like ?si=...
        } else {
          // If "playlist" isn't in the path as expected, or no ID follows.
          setError('Invalid Spotify Playlist URL format.');
          return;
        }
      }
    } catch (e) {
      // Not a valid URL, assume it's an ID or invalid input that will be caught by regex
      // Log the error to mark 'e' as used and for potential debug insights
      console.warn(
        'Error during URL parsing (expected if input is an ID, otherwise check error):',
        e
      );
    }

    // Validate for typical Spotify ID format (alphanumeric, 22 chars)
    if (!/^[a-zA-Z0-9]{22}$/.test(finalPlaylistId)) {
      setError(
        'Invalid Spotify Playlist ID or URL. Please ensure it is a valid ID (22 alphanumeric characters) or a full Spotify playlist URL.'
      );
      return;
    }

    startTransition(async () => {
      try {
        const result: ImportPlaylistResult = await importPlaylist(finalPlaylistId);
        if (result.success) {
          setMessage(result.message || 'Playlist processed successfully!');
          setInputValue(''); // Clear input on success
          if (onImportSuccess) {
            onImportSuccess();
          }
        } else {
          setError(result.message || 'Failed to process playlist.');
        }
      } catch (e) {
        console.error('Form submission error:', e);
        setError('An unexpected error occurred while submitting the form.');
      }
    });
  };

  return (
    <CardContent className=''>
      <form onSubmit={handleSubmit} className='flex flex-col gap-4'>
        <div>
          <label htmlFor='playlistId' style={{ display: 'block', marginBottom: '5px' }}>
            Spotify Playlist ID or URL:
          </label>
          <Input
            type='text'
            id='playlistId'
            name='playlistId'
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder='e.g., 37i9dQZF1DXcBWIGoYBM5M or full URL'
            disabled={isPending}
          />
        </div>
        <Button type='submit' disabled={isPending}>
          {isPending ? 'Importing...' : 'Import Playlist'}
        </Button>
        {message && <p style={{ color: 'green', marginTop: '10px' }}>{message}</p>}
        {error && <p style={{ color: 'red', marginTop: '10px' }}>{error}</p>}
      </form>
    </CardContent>
  );
}
</file>

<file path="app/(protected)/profile/playlists/user-playlists-display.tsx">
'use client';

import React, { useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import { deleteUserPlaylist } from '@/app/_actions/delete-playlist';
import { Card, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Trash2 } from 'lucide-react';
interface Playlist {
  id: string;
  playlist_name: string;
  spotify_playlist_id: string;
  playlist_cover_image_url: string | null;
  track_count: number;
}

interface UserPlaylistsDisplayProps {
  initialPlaylists: Playlist[];
  initialError: string | null;
}

const UserPlaylistsDisplay = ({ initialPlaylists, initialError }: UserPlaylistsDisplayProps) => {
  const [playlists, setPlaylists] = useState<Playlist[]>(initialPlaylists);
  const error = initialError;

  useEffect(() => {
    setPlaylists(initialPlaylists);
  }, [initialPlaylists]);

  const [isPending, startTransition] = useTransition();
  const [deleteError, setDeleteError] = useState<string | null>(null);

  const handleDeletePlaylist = async (playlistId: string, playlistName: string) => {
    if (
      window.confirm(
        `Are you sure you want to delete the playlist "${playlistName}"? This action cannot be undone.`
      )
    ) {
      setDeleteError(null);
      startTransition(async () => {
        const result = await deleteUserPlaylist(playlistId);
        if (result.success) {
          setPlaylists((prevPlaylists) => prevPlaylists.filter((p) => p.id !== playlistId));
        } else {
          console.error('Failed to delete playlist:', result.error);
          setDeleteError(result.error || 'Failed to delete playlist. Please try again.');
        }
      });
    }
  };

  if (error) {
    return (
      <p className='text-center text-peach text-lg p-4 bg-red-100 border border-red-300 rounded-md'>
        {error}
      </p>
    );
  }

  if (!playlists || playlists.length === 0) {
    return (
      <p className='text-center text-muted-foreground text-lg'>
        You haven&apos;t imported any playlists yet.
      </p>
    );
  }

  return (
    <div>
      {deleteError && (
        <div className='mb-4 p-3 bg-red-100 text-peach border border-red-300 rounded-md text-sm'>
          <p>Error deleting playlist: {deleteError}</p>
        </div>
      )}
      <div className='grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6'>
        {playlists.map((playlist) => (
          <Card key={playlist.id}>
            <CardContent>
              {playlist.playlist_cover_image_url ? (
                <Image
                  src={playlist.playlist_cover_image_url}
                  alt={`Cover for ${playlist.playlist_name}`}
                  width={200}
                  height={200}
                  className='w-full h-auto object-cover rounded-md mb-3 aspect-square'
                  priority={false}
                />
              ) : (
                <div className='w-full h-auto bg-muted rounded-md mb-3 aspect-square flex items-center justify-center'>
                  <span className='text-muted-foreground text-2xl'>No Image</span>
                </div>
              )}
              <h4 className='text-lg font-semibold truncate mb-1' title={playlist.playlist_name}>
                {playlist.playlist_name}
              </h4>
              <p className='text-sm'>Tracks: {playlist.track_count}</p>
            </CardContent>
            <CardFooter>
              <Button
                onClick={() => handleDeletePlaylist(playlist.id, playlist.playlist_name)}
                disabled={isPending}
                className='w-full'
                variant='destructive'
              >
                <Trash2 className='!w-3.5 !h-3.5' />
                {isPending ? 'Deleting...' : 'Delete Playlist'}
              </Button>
            </CardFooter>
          </Card>
        ))}
      </div>
    </div>
  );
};

export default UserPlaylistsDisplay;
</file>

<file path="app/api/spotify/refresh-token/route.ts">
import { createClient } from '@/lib/supabase/server';
import { NextResponse } from 'next/server';

interface SpotifyRefreshedTokenResponse {
  access_token: string;
  token_type: string;
  scope: string;
  expires_in: number; // in seconds
  refresh_token?: string; // Spotify might return a new refresh token
}

export async function POST() {
  const supabase = await createClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    console.error('[API /api/spotify/refresh-token] Auth error or no user:', authError?.message);
    return NextResponse.json({ error: 'Authentication required.' }, { status: 401 });
  }
  console.log('[API /api/spotify/refresh-token] User authenticated:', user.id);

  // Check if a valid access token already exists in user_metadata and is not expiring soon
  const currentUserMetadata = user.user_metadata;
  const currentProviderToken = currentUserMetadata?.provider_token as string | undefined;
  const currentProviderTokenExpiresAt = currentUserMetadata?.provider_token_expires_at as
    | number
    | undefined;
  const nowInSeconds = Math.floor(Date.now() / 1000);
  const bufferSeconds = 300; // 5-minute buffer, consider making this configurable or shorter

  if (
    currentProviderToken &&
    currentProviderTokenExpiresAt &&
    currentProviderTokenExpiresAt > nowInSeconds + bufferSeconds
  ) {
    console.log(
      `[API /api/spotify/refresh-token] Token from user_metadata is still valid (expires at ${currentProviderTokenExpiresAt}, now is ${nowInSeconds}). Returning existing token.`
    );
    return NextResponse.json({
      accessToken: currentProviderToken,
      expiresAt: currentProviderTokenExpiresAt,
    });
  }
  console.log(
    '[API /api/spotify/refresh-token] Existing token in user_metadata is expired, not present, or expiring soon. Proceeding with Spotify API refresh attempt.'
  );

  const providerRefreshToken = user.user_metadata?.provider_refresh_token as string | undefined;

  if (!providerRefreshToken) {
    console.error(
      '[API /api/spotify/refresh-token] No provider_refresh_token found for user:',
      user.id
    );
    return NextResponse.json(
      { error: 'Spotify refresh token not found. Please re-authenticate with Spotify.' },
      { status: 400 }
    );
  }

  const clientId = process.env.SPOTIFY_CLIENT_ID;
  const clientSecret = process.env.SPOTIFY_CLIENT_SECRET;

  if (!clientId || !clientSecret) {
    console.error(
      '[API /api/spotify/refresh-token] SPOTIFY_CLIENT_ID or SPOTIFY_CLIENT_SECRET not set in environment variables.'
    );
    return NextResponse.json(
      { error: 'Server configuration error for Spotify credentials.' },
      { status: 500 }
    );
  }

  console.log('[API /api/spotify/refresh-token] Attempting to fetch new token from Spotify.');
  try {
    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: 'Basic ' + Buffer.from(`${clientId}:${clientSecret}`).toString('base64'),
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: providerRefreshToken,
      }),
      cache: 'no-store', // Ensure fresh request for token refresh
    });

    console.log(
      '[API /api/spotify/refresh-token] Spotify token API response status:',
      response.status
    );

    if (!response.ok) {
      const rawErrorBodyText = await response.text();
      let spotifyErrorBody;
      try {
        spotifyErrorBody = JSON.parse(rawErrorBodyText);
      } catch (parseError) {
        console.warn(
          '[API /api/spotify/refresh-token] Failed to parse Spotify error response as JSON. Raw text:',
          rawErrorBodyText
        );
        spotifyErrorBody = {
          error_description: 'Failed to parse Spotify error response. Raw: ' + rawErrorBodyText,
        };
        console.error(parseError);
      }
      console.error(
        '[API /api/spotify/refresh-token] Spotify token refresh failed. Status:',
        response.status,
        'Parsed Body:',
        spotifyErrorBody
      );

      if (
        response.status === 400 &&
        spotifyErrorBody &&
        (spotifyErrorBody.error === 'invalid_grant' ||
          spotifyErrorBody.error_description?.includes('invalid_grant'))
      ) {
        // Consider clearing the invalid refresh token from Supabase to prevent loops,
        // or forcing re-authentication on the client.
        // For now, returning a specific error.
        return NextResponse.json(
          {
            error: 'Invalid refresh token. Please re-authenticate with Spotify.',
            details: spotifyErrorBody,
          },
          { status: 400 }
        );
      }
      return NextResponse.json(
        { error: 'Failed to refresh Spotify token.', details: spotifyErrorBody },
        { status: response.status }
      );
    }

    const refreshedData = (await response.json()) as SpotifyRefreshedTokenResponse;
    console.log('[API /api/spotify/refresh-token] Spotify token successfully refreshed.');

    const newAccessToken = refreshedData.access_token;
    const newExpiresAt = Math.floor(Date.now() / 1000) + refreshedData.expires_in;

    const metadataUpdate: {
      provider_token: string;
      provider_token_expires_at: number;
      provider_refresh_token?: string;
    } = {
      provider_token: newAccessToken,
      provider_token_expires_at: newExpiresAt,
    };

    if (refreshedData.refresh_token) {
      metadataUpdate.provider_refresh_token = refreshedData.refresh_token;
      console.log(
        '[API /api/spotify/refresh-token] Spotify returned a new provider_refresh_token.'
      );
    }

    console.log(
      '[API /api/spotify/refresh-token] Attempting to update Supabase user metadata with new token info.'
    );
    const { error: updateError } = await supabase.auth.updateUser({
      data: metadataUpdate, // This merges with existing user_metadata
    });

    if (updateError) {
      console.error(
        '[API /api/spotify/refresh-token] Failed to update user metadata:',
        updateError.message
      );
      // Even if DB update fails, client might be able to use the token for a short period.
      // However, it's safer to indicate that persistence failed.
      return NextResponse.json(
        { error: 'Failed to save refreshed Spotify token to user profile.' },
        { status: 500 }
      );
    }

    console.log(
      '[API /api/spotify/refresh-token] Successfully updated user metadata. Returning new token.'
    );
    return NextResponse.json({ accessToken: newAccessToken, expiresAt: newExpiresAt });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'An unknown error occurred';
    console.error(
      '[API /api/spotify/refresh-token] Unexpected error during token refresh:',
      message
    );
    return NextResponse.json(
      { error: 'An unexpected error occurred: ' + message },
      { status: 500 }
    );
  }
}
</file>

<file path="app/auth/error/page.tsx">
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

export default async function Page({ searchParams }: { searchParams: Promise<{ error: string }> }) {
  const params = await searchParams

  return (
    <div className="flex min-h-svh w-full items-center justify-center p-6 md:p-10">
      <div className="w-full max-w-sm">
        <div className="flex flex-col gap-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-2xl">Sorry, something went wrong.</CardTitle>
            </CardHeader>
            <CardContent>
              {params?.error ? (
                <p className="text-sm text-muted-foreground">Code error: {params.error}</p>
              ) : (
                <p className="text-sm text-muted-foreground">An unspecified error occurred.</p>
              )}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="components/avatar-stack.tsx">
import { cn } from '@/lib/utils'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip'
import { cva, type VariantProps } from 'class-variance-authority'
import * as React from 'react'

const avatarStackVariants = cva('flex -space-x-4 -space-y-4', {
  variants: {
    orientation: {
      vertical: 'flex-row',
      horizontal: 'flex-col',
    },
  },
  defaultVariants: {
    orientation: 'vertical',
  },
})

export interface AvatarStackProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof avatarStackVariants> {
  avatars: { name: string; image: string }[]
  maxAvatarsAmount?: number
}

const AvatarStack = ({
  className,
  orientation,
  avatars,
  maxAvatarsAmount = 3,
  ...props
}: AvatarStackProps) => {
  const shownAvatars = avatars.slice(0, maxAvatarsAmount)
  const hiddenAvatars = avatars.slice(maxAvatarsAmount)

  return (
    <div
      className={cn(
        avatarStackVariants({ orientation }),
        className,
        orientation === 'horizontal' ? '-space-x-0' : '-space-y-0'
      )}
      {...props}
    >
      {shownAvatars.map(({ name, image }, index) => (
        <Tooltip key={`${name}-${image}-${index}`}>
          <TooltipTrigger asChild>
            <Avatar className="hover:z-10">
              <AvatarImage src={image} />
              <AvatarFallback>
                {name
                  ?.split(' ')
                  ?.map((word) => word[0])
                  ?.join('')
                  ?.toUpperCase()}
              </AvatarFallback>
            </Avatar>
          </TooltipTrigger>
          <TooltipContent>
            <p>{name}</p>
          </TooltipContent>
        </Tooltip>
      ))}

      {hiddenAvatars.length ? (
        <Tooltip key="hidden-avatars">
          <TooltipTrigger asChild>
            <Avatar>
              <AvatarFallback>+{avatars.length - shownAvatars.length}</AvatarFallback>
            </Avatar>
          </TooltipTrigger>
          <TooltipContent>
            {hiddenAvatars.map(({ name }, index) => (
              <p key={`${name}-${index}`}>{name}</p>
            ))}
          </TooltipContent>
        </Tooltip>
      ) : null}
    </div>
  )
}

export { AvatarStack, avatarStackVariants }
</file>

<file path="components/nav/logout-button.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { signOutAction } from './logout-action';

export function LogoutButton() {
  return (
    <form className='w-full' action={signOutAction}>
      <Button type='submit' className='w-full' variant={'ghost'}>
        Sign out
      </Button>
    </form>
  );
}
</file>

<file path="components/player/player-trigger.tsx">
'use client';
import React from 'react';
import {
  motion,
  useAnimationFrame,
  useMotionTemplate,
  useMotionValue,
  useTransform,
} from 'motion/react';
import { useRef } from 'react';
import { cn } from '@/lib/utils';

export function PlayerTrigger({
  borderRadius = '0.4rem',
  children,
  as: Component = 'button',
  containerClassName,
  borderClassName,
  duration,
  className,
  isPlaying,
  ...otherProps
}: {
  borderRadius?: string;
  children: React.ReactNode;
  as?: React.ElementType;
  containerClassName?: string;
  borderClassName?: string;
  duration?: number;
  className?: string;
  isPlaying?: boolean;
  [key: string]: unknown;
}) {
  return (
    <Component
      className={cn(
        'relative h-9 w-9 overflow-hidden bg-transparent p-[2px] text-xl flex items-center justify-center rounded-full transition-all duration-300 ease-in-out hover:ring-2 hover:ring-primary hover:ring-offset-2 data-[state=open]:ring-2 data-[state=open]:ring-accent data-[state=open]:ring-offset-background',
        containerClassName
      )}
      style={{
        borderRadius: borderRadius,
      }}
      {...otherProps}
    >
      <div className='absolute inset-0' style={{ borderRadius: `calc(${borderRadius} * 0.96)` }}>
        <MovingBorder duration={duration} rx='30%' ry='30%' isPlaying={isPlaying}>
          <div
            className={cn(
              'h-20 w-20 bg-[radial-gradient(var(--accent)_20%,var(--accent2)_40%,transparent_60%)] opacity-[0.8]',
              borderClassName
            )}
          />
        </MovingBorder>
      </div>

      <div
        className={cn(
          'relative flex h-full w-full items-center justify-center border border-primary bg-primary/80 text-sm text-white antialiased backdrop-blur-xl',
          className
        )}
        style={{
          borderRadius: `calc(${borderRadius} * 0.96)`,
        }}
      >
        {children}
      </div>
    </Component>
  );
}

export const MovingBorder = ({
  children,
  duration = 5000,
  rx,
  ry,
  isPlaying = false,
  ...otherProps
}: {
  children: React.ReactNode;
  duration?: number;
  rx?: string;
  ry?: string;
  isPlaying?: boolean;
  [key: string]: unknown;
}) => {
  const pathRef = useRef<SVGRectElement | null>(null);
  const progress = useMotionValue<number>(0);

  useAnimationFrame((time) => {
    if (isPlaying && pathRef.current) {
      const length = pathRef.current.getTotalLength();
      if (length) {
        const pxPerMillisecond = length / duration;
        progress.set((time * pxPerMillisecond) % length);
      }
    }
  });

  const x = useTransform(progress, (val) => pathRef.current?.getPointAtLength(val).x);
  const y = useTransform(progress, (val) => pathRef.current?.getPointAtLength(val).y);

  const transform = useMotionTemplate`translateX(${x}px) translateY(${y}px) translateX(-50%) translateY(-50%)`;

  return (
    <>
      <svg
        xmlns='http://www.w3.org/2000/svg'
        preserveAspectRatio='none'
        className='absolute h-full w-full'
        width='100%'
        height='100%'
        {...otherProps}
      >
        <rect fill='none' width='100%' height='100%' rx={rx} ry={ry} ref={pathRef} />
      </svg>
      <motion.div
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          display: 'inline-block',
          transform,
        }}
      >
        {children}
      </motion.div>
    </>
  );
};
</file>

<file path="components/player/VolumePopover.tsx">
'use client';

import React from 'react';
import { useMusic } from '@/music-context/music-context';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Volume2, VolumeX } from 'lucide-react';

export const VolumePopover = () => {
  const { currentVolumePercent, setVolume, toggleMute, isReady, player, deviceId } = useMusic();

  const isMuted = currentVolumePercent === 0;

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant='ghost'
          size='icon' // Using size='icon' for a compact button
          className='h-8 w-8 hover:bg-accent'
          disabled={!isReady || !player || !deviceId}
        >
          {isMuted ? <VolumeX className='h-4 w-4' /> : <Volume2 className='h-4 w-4' />}
          <span className='sr-only'>{isMuted ? 'Unmute' : 'Mute'} / Adjust Volume</span>
        </Button>
      </PopoverTrigger>

      <PopoverContent
        className='h-fit w-auto p-0 bg-transparent border-none shadow-none flex flex-col items-center relative top-[24px]'
        side='left'
        align='end'
        sideOffset={28}
      >
        <div className='flex flex-col items-center gap-2 bg-popover rounded-lg py-2 h-52'>
          <Slider
            orientation='vertical'
            value={currentVolumePercent !== null ? [currentVolumePercent] : [50]}
            onValueChange={(value: number[]) => {
              if (setVolume) setVolume(value[0] / 100);
            }}
            max={100}
            step={1}
            className='data-[orientation=vertical]:w-2'
            disabled={!isReady || !player || !deviceId}
            aria-label='Volume control'
            aria-valuemin={0}
            aria-valuemax={100}
            aria-valuenow={currentVolumePercent ?? 50}
          />
          <Button
            variant='ghost'
            size='icon'
            onClick={async (e) => {
              e.stopPropagation();
              if (toggleMute) await toggleMute();
            }}
            disabled={!isReady || !player || !deviceId}
            className='w-8'
          >
            {isMuted ? <VolumeX className='h-4 w-4' /> : <Volume2 className='h-4 w-4' />}
          </Button>
        </div>
      </PopoverContent>
    </Popover>
  );
};
</file>

<file path="components/realtime-chat-loader.tsx">
'use client';

import dynamic from 'next/dynamic';
import type { MessageSenderProfile, ChatMessage } from '@/hooks/use-realtime-chat';

interface RealtimeChatLoaderProps {
  roomName: string;
  currentUserProfile: MessageSenderProfile;
  initialMessages?: ChatMessage[];
  // Add any other props that RealtimeChat might need, if they are not already included in RealtimeChatProps
}

const RealtimeChat = dynamic(
  () => import('@/components/realtime-chat').then((mod) => mod.RealtimeChat),
  {
    ssr: false,
    // Optional: add a loading component here if needed
    // loading: () => <p>Loading chat...</p>,
  }
);

export default function RealtimeChatLoader(props: RealtimeChatLoaderProps) {
  return <RealtimeChat {...props} />;
}
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="hooks/use-realtime-presence-room.ts">
'use client'

import { useCurrentUserImage } from '@/hooks/use-current-user-image'
import { useCurrentUserName } from '@/hooks/use-current-user-name'
import { createClient } from '@/lib/supabase/client'
import { useEffect, useState } from 'react'

const supabase = createClient()

export type RealtimeUser = {
  id: string
  name: string
  image: string
}

export const useRealtimePresenceRoom = (roomName: string) => {
  const currentUserImage = useCurrentUserImage()
  const currentUserName = useCurrentUserName()

  const [users, setUsers] = useState<Record<string, RealtimeUser>>({})

  useEffect(() => {
    const room = supabase.channel(roomName)

    room
      .on('presence', { event: 'sync' }, () => {
        const newState = room.presenceState<{ image: string; name: string }>()

        const newUsers = Object.fromEntries(
          Object.entries(newState).map(([key, values]) => [
            key,
            { name: values[0].name, image: values[0].image },
          ])
        ) as Record<string, RealtimeUser>
        setUsers(newUsers)
      })
      .subscribe(async (status) => {
        if (status !== 'SUBSCRIBED') {
          return
        }

        await room.track({
          name: currentUserName,
          image: currentUserImage,
        })
      })

    return () => {
      room.unsubscribe()
    }
  }, [roomName, currentUserName, currentUserImage])

  return { users }
}
</file>

<file path="lib/cloudinary-urls.ts">
/**
 * Centralized location for all Cloudinary URLs used in the project
 * All URLs are from the paalaleks Cloudinary account
 */

export const CLOUDINARY_URLS = {
  GRAINY:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745715093/grainy_fxayrt.png",
  RECORD:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745562792/discovered/vinyl_jan4n8.png",
  BG_GRAIN:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745548075/discovered/grain_ftttmu.png",
  HEADER:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745647784/header_xebbau.png",
  HEADER1:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745465652/discovered/header1_bfi8bt.png",
  HEADER2:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745465663/discovered/header2_uwxmbb.png",
  SECTION1:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745461127/discovered/section1_iveooh.png",
  SECTION2:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745742946/Mask_Group_47_cplrap.png",
  SECTION3:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745461126/discovered/section3_rdoqwo.png",
  DISC: "https://res.cloudinary.com/paalaleks/image/upload/v1744346399/discovered/disc_iylvf2.png",
  LOGO: "https://res.cloudinary.com/paalaleks/image/upload/v1745463919/discovered/logo_sp4oen.png",
  VINYL_PLACEHOLDER:
    "https://res.cloudinary.com/paalaleks/image/upload/v1745463919/discovered/vinyl_placeholder_zqzqzq.png",
} as const;

/**
 * Type representing all available Cloudinary URLs
 */
export type CloudinaryUrl =
  (typeof CLOUDINARY_URLS)[keyof typeof CLOUDINARY_URLS];
</file>

<file path="lib/spotify-accesstoken.ts">
'use server';

interface SpotifyTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
}

// In-memory cache for the token
let spotifyAccessToken: string | null = null;
let tokenExpiryTime: number | null = null;
const clientId = process.env.SPOTIFY_CLIENT_ID;
const clientSecret = process.env.SPOTIFY_CLIENT_SECRET;

export async function getSpotifyAccessToken(): Promise<string | null> {
  if (!clientId || !clientSecret) {
    console.error('Spotify client ID or secret not configured in environment variables.');
    return null;
  }

  // Check if we have a valid token in cache
  if (spotifyAccessToken && tokenExpiryTime && Date.now() < tokenExpiryTime) {
    return spotifyAccessToken;
  }

  const params = new URLSearchParams();
  params.append('grant_type', 'client_credentials');

  try {
    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: 'Basic ' + Buffer.from(clientId + ':' + clientSecret).toString('base64'),
      },
      body: params,
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error(
        `Error fetching Spotify token: ${response.status} ${response.statusText}`,
        errorBody
      );
      return null;
    }

    const data = (await response.json()) as SpotifyTokenResponse;
    spotifyAccessToken = data.access_token;
    // Set expiry time a bit earlier than actual expiry to be safe (e.g., 5 minutes buffer)
    tokenExpiryTime = Date.now() + (data.expires_in - 300) * 1000;

    return spotifyAccessToken;
  } catch (error) {
    console.error('Exception fetching Spotify token:', error);
    return null;
  }
}
</file>

<file path="lib/supabase/__mocks__/server.ts">
// This is the mock Supabase client instance that will be returned
const mockSupabaseClient = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  eq: jest.fn().mockImplementation(async () => ({ data: [], error: null })), // .eq() might be the end of a chain
  // Mock other Supabase client methods you use here as needed:
  insert: jest.fn().mockImplementation(async () => ({ data: [], error: null })),
  update: jest.fn().mockImplementation(async () => ({ data: [], error: null })),
  delete: jest.fn().mockImplementation(async () => ({ data: [], error: null })),
  rpc: jest.fn().mockImplementation(async () => ({ data: null, error: null })),
  // Add a catch-all for any other methods that might be called on the client
  // and ensure they return a promise if they are part of an async chain.
  mock: jest.fn().mockReturnThis(), // Default for unhandled chained calls
  then: undefined, // Remove if it causes issues, was for direct promise-like behavior
};

// createClient is an async function, so the mock should also be async
// or return a Promise that resolves to the mock client object.
export const createClient = jest.fn(async () => mockSupabaseClient);
</file>

<file path="lib/supabase/client.ts">
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
</file>

<file path="lib/supabase/server.ts">
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
</file>

<file path="middleware.ts">
import { updateSession } from "@/lib/supabase/middleware";
import { type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
</file>

<file path="music-context/playlist-actions.ts">
'use server';

import { createClient } from '@/lib/supabase/server';
import { Playlist } from '@/types/spotify'; // Assuming this type includes necessary fields like id, name, spotify_id, image_url
import { Tables } from '@/types/database';

/**
 * Server Action to get playlists matched for the current user from the database.
 * Fetches pre-calculated matches from the user_playlist_matches table.
 *
 * @param userId - The UUID of the user whose matched playlists are to be fetched.
 * @returns A promise that resolves to an array of Playlist objects.
 */
export async function getMatchedPlaylistsForUserAction(userId: string): Promise<Playlist[]> {
  // console.log(`[Playlist Action] Fetching matched playlists for user: ${userId}`);
  if (!userId) {
    console.error('[Playlist Action] User ID is required.');
    return [];
  }

  const supabase = await createClient();

  try {
    const { data: matches, error: matchesError } = await supabase
      .from('user_playlist_matches')
      .select(
        `
        playlist_id,
        playlists (
          id,
          spotify_playlist_id,
          name,
          description,
          image_url,
          owner_spotify_user_id,
          total_tracks,
          snapshot_id,
          submitted_by_user_id
        )
      `
      )
      .eq('user_id', userId);

    if (matchesError) {
      console.error('[Playlist Action] Error fetching user_playlist_matches:', matchesError);
      throw new Error(`Failed to fetch matched playlists: ${matchesError.message}`);
    }

    if (!matches || matches.length === 0) {
      // console.log(`[Playlist Action] No pre-calculated matches found for user ${userId}.`);
      return [];
    }

    // console.log(`[Playlist Action] Found ${matches.length} matches for user ${userId}. Processing...`);

    // Extract the playlist data and map to the Playlist type
    const playlists: Playlist[] = matches
      .map((match) => {
        // Type guard to handle potential array/object discrepancy from generated types
        const potentialPlaylistData = match.playlists as
          | Tables<'playlists'>[]
          | Tables<'playlists'>
          | null;
        const playlistData = Array.isArray(potentialPlaylistData)
          ? (potentialPlaylistData[0] ?? null)
          : potentialPlaylistData;

        if (!playlistData) {
          console.warn(
            `[Playlist Action] Match found for user ${userId} but playlist data (${match.playlist_id}) is missing or invalid. Skipping.`
          );
          return null;
        }

        // Map DB fields to Playlist type fields
        // IMPORTANT: Ensure Playlist type aligns with these fields.
        // Specifically, Playlist might expect 'spotify_id' instead of 'spotify_playlist_id'
        return {
          id: playlistData.id, // Internal DB ID
          spotify_id: playlistData.spotify_playlist_id, // Spotify ID
          name: playlistData.name,
          description: playlistData.description ?? '',
          images: playlistData.image_url
            ? [{ url: playlistData.image_url, height: null, width: null }]
            : [],
          owner: {
            // Assuming Playlist type has an owner object. Adjust as needed.
            id: playlistData.owner_spotify_user_id ?? 'unknown',
            display_name: 'Unknown', // Might need another join or separate fetch if display name is needed
          },
          tracks: {
            // Assuming Playlist type needs a tracks object. Adjust as needed.
            total: playlistData.total_tracks ?? 0,
            href: '', // Placeholder or construct if needed
          },
          snapshot_id: playlistData.snapshot_id ?? '',
          public: true, // Assuming default, adjust if DB has this info
          collaborative: false, // Assuming default, adjust if DB has this info
          type: 'playlist',
          uri: `spotify:playlist:${playlistData.spotify_playlist_id}`,
          href: `https://api.spotify.com/v1/playlists/${playlistData.spotify_playlist_id}`, // Construct href if needed
          external_urls: {
            spotify: `https://open.spotify.com/playlist/${playlistData.spotify_playlist_id}`,
          },
          // Include other fields required by Playlist type, potentially with defaults
        } as Playlist; // Casting might be necessary depending on strictness
      })
      .filter((p): p is Playlist => p !== null); // Filter out any nulls from missing data

    // console.log(`[Playlist Action] Returning ${playlists.length} processed playlists for user ${userId}.`);
    return playlists;
  } catch (error) {
    console.error('[Playlist Action] Unexpected error in getMatchedPlaylistsForUserAction:', error);
    // Return empty on error to align with previous action's behavior
    return [];
  }
}
</file>

<file path="music-context/spotify-helpers.ts">
import { SpotifyApiTrackFull } from '../types/spotify';

export function mapApiTrackToSdkTrack(apiTrack: SpotifyApiTrackFull): Spotify.Track {
  return {
    uri: apiTrack.uri,
    id: apiTrack.id,
    type: 'track',
    media_type: 'audio',
    name: apiTrack.name,
    is_playable: apiTrack.is_playable ?? false,
    album: {
      uri: apiTrack.album.uri || '',
      name: apiTrack.album.name,
      images: apiTrack.album.images,
    },
    artists: apiTrack.artists.map((a) => ({
      uri: a.uri || '',
      name: a.name,
      url: a.external_urls?.spotify || '',
    })),
    duration_ms: apiTrack.duration_ms || 0,
    uid: apiTrack.id || '',
    track_type: 'audio',
    linked_from: apiTrack.linked_from
      ? { uri: apiTrack.linked_from.uri, id: apiTrack.linked_from.id }
      : { uri: null, id: null },
  };
}
</file>

<file path="music-context/token-manager.ts">
import { createClient } from '@/lib/supabase/client';

interface TokenState {
  token: string | null;
  expiresAt: number | null;
  isRefreshing: boolean;
  userId: string | null;
}

// Single instance token state
let tokenState: TokenState = {
  token: null,
  expiresAt: null,
  isRefreshing: false,
  userId: null,
};

// Pending token requests (for batching multiple simultaneous requests)
let pendingTokenPromise: Promise<string | null> | null = null;

// Initialization state
let isInitialized = false;
let initializationCompleteResolve: () => void;
const initializationCompletePromise = new Promise<void>((resolve) => {
  initializationCompleteResolve = resolve;
});

/**
 * Initialize token state from user metadata
 */
export const initializeTokenManager = async (): Promise<void> => {
  if (isInitialized) {
    return initializationCompletePromise;
  }

  const supabase = createClient();

  try {
    const { data } = await supabase.auth.getUser();

    if (data.user) {
      tokenState.token = (data.user.user_metadata?.provider_token as string | undefined) || null;
      tokenState.expiresAt =
        (data.user.user_metadata?.provider_token_expires_at as number | undefined) || null;
      tokenState.userId = data.user.id;
    } else {
      tokenState = {
        token: null,
        expiresAt: null,
        isRefreshing: false,
        userId: null,
      };
    }
  } catch (error) {
    console.error('[token-manager] Error fetching initial user:', error);
    tokenState = {
      token: null,
      expiresAt: null,
      isRefreshing: false,
      userId: null,
    };
  } finally {
    isInitialized = true;
    initializationCompleteResolve(); // Resolve the promise once initial state is set
  }

  // Set up auth state change listener
  supabase.auth.onAuthStateChange((event, session) => {
    if (!isInitialized) {
      // If an auth event comes in before initial getUser is done,
      // we should wait to avoid race conditions with the initial state setting.
      // This scenario is less likely but good to be defensive.
      console.warn(
        '[token-manager] onAuthStateChange event before initial getUser completed. This may indicate a race condition if not handled carefully elsewhere.'
      );
    }

    let needsUpdate = false;
    const previousUserId = tokenState.userId;

    if (event === 'SIGNED_OUT') {
      if (tokenState.userId !== null || tokenState.token !== null) {
        needsUpdate = true;
      }
      tokenState = {
        token: null,
        expiresAt: null,
        isRefreshing: false,
        userId: null,
      };
    } else if (session?.user) {
      const newToken = (session.user.user_metadata?.provider_token as string | undefined) || null;
      const newExpiresAt =
        (session.user.user_metadata?.provider_token_expires_at as number | undefined) || null;

      if (
        newToken !== tokenState.token ||
        newExpiresAt !== tokenState.expiresAt ||
        session.user.id !== tokenState.userId
      ) {
        tokenState.token = newToken;
        tokenState.expiresAt = newExpiresAt;
        tokenState.userId = session.user.id;
        needsUpdate = true;
      }
    }
    // If the user ID changed, it's an important update regardless of token presence
    if (tokenState.userId !== previousUserId && !needsUpdate) {
      needsUpdate = true;
    }

    if (needsUpdate) {
      // Potentially notify listeners if we had a subscription model here
      // For now, just updating internal state. MusicContext will re-check via isAuthenticated/getUserId
      console.log('[token-manager] Auth state changed. New user ID:', tokenState.userId);
    }
  });
};

/**
 * Ensures the token manager has completed its initial asynchronous setup.
 */
export const ensureTokenManagerInitialized = (): Promise<void> => {
  return initializationCompletePromise;
};

/**
 * Returns a Spotify token, refreshing if necessary
 * This method will batch multiple simultaneous requests
 */
export const getSpotifyToken = async (): Promise<string | null> => {
  await initializationCompletePromise; // Ensure initialized

  // If token is valid, return immediately
  if (isTokenValid()) {
    return tokenState.token;
  }

  // If already refreshing, return the existing promise
  if (pendingTokenPromise) {
    return pendingTokenPromise;
  }

  // Start a new refresh
  pendingTokenPromise = refreshToken();

  try {
    return await pendingTokenPromise;
  } finally {
    // Clear pending promise when done
    pendingTokenPromise = null;
  }
};

/**
 * Check if current token is valid and not expiring soon
 */
function isTokenValid(): boolean {
  // No need to await initializationCompletePromise here, getSpotifyToken does it.
  if (!tokenState.token || !tokenState.expiresAt) {
    return false;
  }

  const nowInSeconds = Math.floor(Date.now() / 1000);
  const bufferSeconds = 60; // 1 minute buffer before expiry

  return tokenState.expiresAt > nowInSeconds + bufferSeconds;
}

/**
 * Refresh token via API
 */
async function refreshToken(): Promise<string | null> {
  // No need to await initializationCompletePromise here, getSpotifyToken does it.
  if (tokenState.isRefreshing) {
    console.warn('[token-manager] Already refreshing token');
    // If already refreshing, let the caller wait on the pendingTokenPromise
    // This function returning null might be okay if pendingTokenPromise is awaited by caller
    return pendingTokenPromise;
  }

  tokenState.isRefreshing = true;

  try {
    console.log('[token-manager] Refreshing Spotify token');

    const response = await fetch('/api/spotify/refresh-token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });

    const result = await response.json();

    if (response.ok && result.accessToken && result.expiresAt) {
      console.log('[token-manager] Token refresh successful');
      tokenState.token = result.accessToken;
      tokenState.expiresAt = result.expiresAt;
      return tokenState.token;
    } else {
      console.error(
        '[token-manager] Token refresh failed:',
        result.error || 'Unknown error',
        'Status:',
        response.status
      );
      // Important: If refresh fails, clear the token to avoid using a stale one.
      tokenState.token = null;
      tokenState.expiresAt = null;
      return null;
    }
  } catch (error) {
    console.error('[token-manager] Token refresh error:', error);
    tokenState.token = null;
    tokenState.expiresAt = null;
    return null;
  } finally {
    tokenState.isRefreshing = false;
  }
}

/**
 * Check if user is authenticated with a valid session
 */
export const isAuthenticated = (): boolean => {
  // This must be synchronous for some use cases, so it can't await the promise here directly.
  // Relies on initializeTokenManager being called at app startup.
  // If used before initialization, it might return a premature false.
  // Consider if ensureTokenManagerInitialized should be called by consumers before this,
  // or if this function needs an async version for guaranteed accuracy.
  if (!isInitialized) {
    console.warn(
      '[token-manager] isAuthenticated called before initialization complete. Result may be inaccurate.'
    );
  }
  return !!tokenState.userId;
};

/**
 * Get user ID if authenticated
 */
export const getUserId = (): string | null => {
  // Similar to isAuthenticated, this is often expected to be synchronous.
  if (!isInitialized) {
    console.warn(
      '[token-manager] getUserId called before initialization complete. Result may be inaccurate.'
    );
  }
  return tokenState.userId;
};
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="supabase/migrations/20240401120000_create_notification_system.sql">
-- supabase/migrations/YYYYMMDDHHMMSS_create_notification_system.sql

BEGIN;

-- 1. Create user_saved_tracks table
CREATE TABLE public.user_saved_tracks (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    track_spotify_id TEXT NOT NULL,
    saved_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    source TEXT
);

ALTER TABLE public.user_saved_tracks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own saved tracks" ON public.user_saved_tracks
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own saved tracks" ON public.user_saved_tracks
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own saved tracks" ON public.user_saved_tracks
    FOR DELETE USING (auth.uid() = user_id);

-- 2. Create user_saved_playlists table
CREATE TABLE public.user_saved_playlists (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    playlist_id UUID NOT NULL REFERENCES public.playlists(id) ON DELETE CASCADE, -- Assuming playlists.id is UUID
    saved_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    source TEXT
);

ALTER TABLE public.user_saved_playlists ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own saved playlists" ON public.user_saved_playlists
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own saved playlists" ON public.user_saved_playlists
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own saved playlists" ON public.user_saved_playlists
    FOR DELETE USING (auth.uid() = user_id);

-- 3. Create user_notifications table
CREATE TABLE public.user_notifications (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type TEXT NOT NULL, -- e.g., 'new_track_match', 'new_playlist_match'
    item_spotify_id TEXT,
    related_playlist_table_id UUID REFERENCES public.playlists(id) ON DELETE SET NULL,
    triggering_saved_track_id BIGINT REFERENCES public.user_saved_tracks(id) ON DELETE SET NULL,
    triggering_saved_playlist_id BIGINT REFERENCES public.user_saved_playlists(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    item_name TEXT,
    item_image_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    read_at TIMESTAMPTZ,
    metadata JSONB
);

ALTER TABLE public.user_notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own notifications" ON public.user_notifications
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications (to mark as read)" ON public.user_notifications
    FOR UPDATE USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Indexes for user_notifications
CREATE INDEX idx_user_notifications_user_id ON public.user_notifications(user_id);
CREATE INDEX idx_user_notifications_user_id_is_read_created_at ON public.user_notifications(user_id, is_read, created_at DESC);

-- Ensure the internal schema exists if you're using it
CREATE SCHEMA IF NOT EXISTS internal;

-- 4. Placeholder Trigger Functions (to be implemented by Supabase Edge Functions)
-- These SQL functions are shells; the actual logic will be in Edge Functions.
-- The trigger will call an Edge Function using pg_net or similar mechanism if Supabase directly supports it,
-- or via a supabase_functions.http_request if not. For now, we define a simple plpgsql shell.

CREATE OR REPLACE FUNCTION internal.handle_new_saved_track()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- In a real scenario, this function would trigger an Edge Function.
  -- For example, using pg_net or by inserting into a queue table that an Edge Function listens to.
  -- Supabase might also offer direct invocation hooks from triggers to Edge Functions.
  -- The NEW record (NEW.id, NEW.user_id, NEW.track_spotify_id) is available here.
  PERFORM supabase_functions.http_request(
    -- Replace with your actual Edge Function URL and method
    url := 'https://jaoksbhfyfyqubkmjvso.functions.supabase.co/process-saved-track-notification',
    method := 'POST',
    headers := '{"Content-Type": "application/json", "Authorization": "Bearer " || current_setting(''request.jwt.claims'', true)::jsonb->>''service_role_key''}', -- Or appropriate auth
    body := jsonb_build_object(
        'record', row_to_json(NEW)
    )
  );
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION internal.handle_new_saved_playlist()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Similar to handle_new_saved_track, this triggers an Edge Function.
  -- The NEW record (NEW.id, NEW.user_id, NEW.playlist_id) is available here.
  PERFORM supabase_functions.http_request(
    url := 'https://jaoksbhfyfyqubkmjvso.functions.supabase.co/process-saved-playlist-notification',
    method := 'POST',
    headers := '{"Content-Type": "application/json", "Authorization": "Bearer " || current_setting(''request.jwt.claims'', true)::jsonb->>''service_role_key''}', -- Or appropriate auth
    body := jsonb_build_object(
        'record', row_to_json(NEW)
    )
  );
  RETURN NEW;
END;
$$;

-- 5. Create Triggers
CREATE TRIGGER on_user_saved_tracks_insert
    AFTER INSERT ON public.user_saved_tracks
    FOR EACH ROW EXECUTE FUNCTION internal.handle_new_saved_track();

CREATE TRIGGER on_user_saved_playlists_insert
    AFTER INSERT ON public.user_saved_playlists
    FOR EACH ROW EXECUTE FUNCTION internal.handle_new_saved_playlist();

-- Note on RPC Functions (get_user_notifications, mark_notification_as_read, etc.):
-- These will be created separately, typically in the Supabase dashboard SQL editor or as another migration.
-- They are not part of this table/trigger setup script but are part of the overall feature.

COMMIT;
</file>

<file path="supabase/migrations/20240401120100_create_notification_rpcs.sql">
-- supabase/migrations/YYYYMMDDHHMMSS_create_notification_rpcs.sql

BEGIN;

-- RPC Function: get_user_notifications
CREATE OR REPLACE FUNCTION public.get_user_notifications(
    p_limit INT DEFAULT 20,
    p_offset INT DEFAULT 0,
    p_include_read BOOLEAN DEFAULT FALSE
)
RETURNS SETOF public.user_notifications -- Or define a specific return type/view if preferred
LANGUAGE plpgsql
SECURITY DEFINER -- Executes with the permissions of the function owner (superuser if created by one)
AS $$
BEGIN
    -- Make sure to set search_path if not relying on default or function owner's path
    -- SET search_path = public;

    RETURN QUERY
    SELECT *
    FROM public.user_notifications
    WHERE user_id = auth.uid()
      AND (p_include_read OR NOT is_read) -- if p_include_read is true, get all; otherwise, only unread
    ORDER BY created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;

-- RPC Function: mark_notification_as_read
CREATE OR REPLACE FUNCTION public.mark_notification_as_read(p_notification_id BIGINT)
RETURNS public.user_notifications -- Return the updated notification
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    updated_notification public.user_notifications;
BEGIN
    UPDATE public.user_notifications
    SET is_read = TRUE, read_at = NOW()
    WHERE id = p_notification_id AND user_id = auth.uid()
    RETURNING * INTO updated_notification;

    RETURN updated_notification;
END;
$$;

-- RPC Function: mark_all_notifications_as_read
CREATE OR REPLACE FUNCTION public.mark_all_notifications_as_read()
RETURNS SETOF public.user_notifications -- Return all notifications that were marked as read
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    UPDATE public.user_notifications
    SET is_read = TRUE, read_at = NOW()
    WHERE user_id = auth.uid() AND is_read = FALSE
    RETURNING *;
END;
$$;

-- RPC Function: get_unread_notification_count
CREATE OR REPLACE FUNCTION public.get_unread_notification_count()
RETURNS JSONB -- Return as JSON object { "count": number }
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    unread_count INT;
BEGIN
    SELECT COUNT(*)
    INTO unread_count
    FROM public.user_notifications
    WHERE user_id = auth.uid() AND is_read = FALSE;

    RETURN jsonb_build_object('count', unread_count);
END;
$$;

-- Grant execute permissions to the authenticated role for these functions
-- This is crucial for them to be callable from the client-side via Supabase SDK
GRANT EXECUTE ON FUNCTION public.get_user_notifications(INT, INT, BOOLEAN) TO authenticated;
GRANT EXECUTE ON FUNCTION public.mark_notification_as_read(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.mark_all_notifications_as_read() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_unread_notification_count() TO authenticated;


COMMIT;
</file>

<file path="supabase/migrations/20250512065750_create_playlist_track_artist_aggregates_table.sql">
-- Migration: Create playlist_track_artist_aggregates table
-- Purpose: Stores aggregated track and artist data for each playlist to facilitate efficient querying.
-- Affected tables/columns:
--   - Creates table: public.playlist_track_artist_aggregates
--   - Adds columns: id, playlist_id, user_id, tracks_json, artist_occurrences_json, total_tracks, distinct_artist_count, last_aggregated_at, created_at
--   - Creates trigger: trigger_update_playlist_aggregates_last_aggregated_at on public.playlist_track_artist_aggregates
--   - Creates function: public.update_playlist_aggregates_last_aggregated_at_on_update()
--   - Creates policy: "Allow authenticated users to read playlist aggregates" on public.playlist_track_artist_aggregates
-- Special considerations: None

-- Create the playlist_track_artist_aggregates table
create table public.playlist_track_artist_aggregates (
    id uuid primary key default gen_random_uuid(),
    playlist_id uuid not null unique references public.playlists(id) on delete cascade,
    user_id uuid references public.profiles(id) on delete set null,
    tracks_json jsonb not null default '[]'::jsonb,
    artist_occurrences_json jsonb not null default '[]'::jsonb,
    total_tracks integer not null default 0,
    distinct_artist_count integer not null default 0,
    last_aggregated_at timestamptz not null default now(),
    created_at timestamptz not null default now()
);

-- Add comments to the table and columns
comment on table public.playlist_track_artist_aggregates is 'Stores aggregated track and artist data for each playlist.';
comment on column public.playlist_track_artist_aggregates.playlist_id is 'FK to the playlists table.';
comment on column public.playlist_track_artist_aggregates.user_id is 'FK to the profiles table, indicating the user associated with this aggregation (e.g., importer). Can be NULL if not user-specific.';
comment on column public.playlist_track_artist_aggregates.tracks_json is 'JSONB array of track objects from the playlist.';
comment on column public.playlist_track_artist_aggregates.artist_occurrences_json is 'JSONB array of unique artists, each with their occurrence count in the playlist.';
comment on column public.playlist_track_artist_aggregates.total_tracks is 'Total number of tracks in tracks_json.';
comment on column public.playlist_track_artist_aggregates.distinct_artist_count is 'Total number of distinct artists in artist_occurrences_json.';
comment on column public.playlist_track_artist_aggregates.last_aggregated_at is 'Timestamp of the last aggregation update.';

-- Enable Row Level Security for the table
alter table public.playlist_track_artist_aggregates enable row level security;

-- Create RLS policy for authenticated users to read
create policy "Allow authenticated users to read playlist aggregates"
on public.playlist_track_artist_aggregates
for select
to authenticated
using (true);

-- Create function to update last_aggregated_at timestamp on update
create or replace function public.update_playlist_aggregates_last_aggregated_at_on_update()
returns trigger as $$
begin
    new.last_aggregated_at = now();
    return new;
end;
$$ language plpgsql;

-- Create trigger to execute the function before update
create trigger trigger_update_playlist_aggregates_last_aggregated_at
before update on public.playlist_track_artist_aggregates
for each row
execute function public.update_playlist_aggregates_last_aggregated_at_on_update();
</file>

<file path="supabase/migrations/temp_add_album_spotify_id_to_user_top_tracks.sql">
ALTER TABLE public.user_top_tracks
ADD COLUMN album_spotify_id TEXT;

COMMENT ON COLUMN public.user_top_tracks.album_spotify_id IS 'Spotify ID for the track\''s album.';
</file>

<file path="supabase/migrations/YYYYMMDDHHMMSS_create_playlist_and_taste_tables.sql">
-- Migration: Create Playlist and Taste Tables
-- Timestamp: YYYYMMDDHHMMSS (Please update filename and this comment)

BEGIN;

-- Alter existing table: public.playlists
ALTER TABLE public.playlists
    ADD COLUMN IF NOT EXISTS total_tracks INTEGER,
    ADD COLUMN IF NOT EXISTS snapshot_id TEXT,
    ADD COLUMN IF NOT EXISTS data_source TEXT, -- e.g., 'user_shared', 'spotify_recommendation', 'user_library'
    ADD COLUMN IF NOT EXISTS last_fetched_from_spotify_at TIMESTAMPTZ;

COMMENT ON COLUMN public.playlists.total_tracks IS 'Total number of tracks in the playlist on Spotify.';
COMMENT ON COLUMN public.playlists.snapshot_id IS 'Spotify''s ID for the current version of the playlist''s tracks. Used to detect changes.';
COMMENT ON COLUMN public.playlists.data_source IS 'Indicates how this playlist was added to the system (e.g., ''user_shared'', ''spotify_library_import'', ''system_recommendation'').';
COMMENT ON COLUMN public.playlists.last_fetched_from_spotify_at IS 'Timestamp of when this playlist''s details were last fetched/updated from Spotify.';

-- RLS for playlists (adjusting existing if necessary, or adding new)
-- Assuming these might be new or need adjustment based on added columns like submitted_by_user_id
DROP POLICY IF EXISTS "Authenticated users can view all playlists." ON public.playlists;
CREATE POLICY "Authenticated users can view all playlists." ON public.playlists
    FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert playlists they submit." ON public.playlists;
CREATE POLICY "Users can insert playlists they submit." ON public.playlists
    FOR INSERT WITH CHECK (auth.uid() = submitted_by_user_id AND submitted_by_user_id IS NOT NULL);

-- Allow service_role full access (common pattern)
DROP POLICY IF EXISTS "Service role can manage playlists." ON public.playlists;
CREATE POLICY "Service role can manage playlists." ON public.playlists
    FOR ALL USING (auth.role() = 'service_role');


-- Alter existing table: public.playlist_tracks
-- (Note: in docs, referred to conceptually as playlist_items)
ALTER TABLE public.playlist_tracks
    DROP COLUMN IF EXISTS artist_names, -- Removing old TEXT[] array
    ADD COLUMN IF NOT EXISTS track_artists JSONB, -- Adding new JSONB for structured artist data
    ADD COLUMN IF NOT EXISTS track_popularity INTEGER,
    ADD COLUMN IF NOT EXISTS track_preview_url TEXT,
    ADD COLUMN IF NOT EXISTS audio_features JSONB; 
    -- Assuming album_art_url and order_in_playlist are kept as is, no rename needed in SQL.
    -- Assuming added_at is kept as is.

COMMENT ON COLUMN public.playlist_tracks.track_artists IS 'Array of artist objects, e.g., [{ "spotify_id": "...", "name": "..." }]. Replaces artist_names.';
COMMENT ON COLUMN public.playlist_tracks.track_popularity IS 'Popularity of the track on Spotify (0-100).';
COMMENT ON COLUMN public.playlist_tracks.track_preview_url IS 'URL to a 30-second preview of the track.';
COMMENT ON COLUMN public.playlist_tracks.audio_features IS 'Detailed audio features from Spotify (e.g., danceability, energy, valence).';

-- RLS for playlist_tracks
DROP POLICY IF EXISTS "Authenticated users can view all playlist items." ON public.playlist_tracks;
CREATE POLICY "Authenticated users can view all playlist items." ON public.playlist_tracks
    FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Service role can manage playlist items." ON public.playlist_tracks;
CREATE POLICY "Service role can manage playlist items." ON public.playlist_tracks
    FOR ALL USING (auth.role() = 'service_role');


-- Create new table: public.user_top_artists
CREATE TABLE IF NOT EXISTS public.user_top_artists (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    artist_spotify_id TEXT NOT NULL,
    name TEXT NOT NULL,
    genres JSONB, -- Array of genre strings
    popularity INTEGER, -- Spotify popularity score (0-100)
    image_url TEXT,
    fetched_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    PRIMARY KEY (user_id, artist_spotify_id)
);

COMMENT ON TABLE public.user_top_artists IS 'Stores a user''s top artists from Spotify, periodically updated.';
COMMENT ON COLUMN public.user_top_artists.user_id IS 'Link to the user in public.profiles.';
COMMENT ON COLUMN public.user_top_artists.artist_spotify_id IS 'Spotify ID for the artist.';
COMMENT ON COLUMN public.user_top_artists.name IS 'Name of the artist.';
COMMENT ON COLUMN public.user_top_artists.genres IS 'Array of genre strings associated with the artist.';
COMMENT ON COLUMN public.user_top_artists.popularity IS 'Spotify popularity score (0-100) for the artist.';
COMMENT ON COLUMN public.user_top_artists.image_url IS 'URL for the artist''s image.';
COMMENT ON COLUMN public.user_top_artists.fetched_at IS 'Timestamp when this artist data was fetched for the user.';

ALTER TABLE public.user_top_artists ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own top artists." ON public.user_top_artists
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert/update their own top artists." ON public.user_top_artists
    FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Service role can manage user top artists." ON public.user_top_artists
    FOR ALL USING (auth.role() = 'service_role');

-- Create new table: public.user_top_tracks
CREATE TABLE IF NOT EXISTS public.user_top_tracks (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    track_spotify_id TEXT NOT NULL,
    name TEXT NOT NULL,
    artists JSONB, -- Array of artist objects, e.g., [{ "spotify_id": "...", "name": "..." }]
    album_name TEXT,
    album_image_url TEXT,
    popularity INTEGER, -- Spotify popularity score (0-100)
    duration_ms INTEGER,
    preview_url TEXT,
    fetched_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    PRIMARY KEY (user_id, track_spotify_id)
);

COMMENT ON TABLE public.user_top_tracks IS 'Stores a user''s top tracks from Spotify, periodically updated.';
COMMENT ON COLUMN public.user_top_tracks.user_id IS 'Link to the user in public.profiles.';
COMMENT ON COLUMN public.user_top_tracks.track_spotify_id IS 'Spotify ID for the track.';
COMMENT ON COLUMN public.user_top_tracks.name IS 'Name of the track.';
COMMENT ON COLUMN public.user_top_tracks.artists IS 'Array of artist objects, e.g., [{ "spotify_id": "...", "name": "..." }].';
COMMENT ON COLUMN public.user_top_tracks.album_name IS 'Name of the track''s album.';
COMMENT ON COLUMN public.user_top_tracks.album_image_url IS 'URL for the track''s album cover image.';
COMMENT ON COLUMN public.user_top_tracks.popularity IS 'Spotify popularity score (0-100) for the track.';
COMMENT ON COLUMN public.user_top_tracks.duration_ms IS 'Duration of the track in milliseconds.';
COMMENT ON COLUMN public.user_top_tracks.preview_url IS 'URL to a 30-second preview of the track.';
COMMENT ON COLUMN public.user_top_tracks.fetched_at IS 'Timestamp when this track data was fetched for the user.';

ALTER TABLE public.user_top_tracks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own top tracks." ON public.user_top_tracks
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert/update their own top tracks." ON public.user_top_tracks
    FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Service role can manage user top tracks." ON public.user_top_tracks
    FOR ALL USING (auth.role() = 'service_role');


-- Create new table: public.user_playlist_interactions
CREATE TABLE IF NOT EXISTS public.user_playlist_interactions (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    playlist_id UUID NOT NULL REFERENCES public.playlists(id) ON DELETE CASCADE, -- Links to playlists.id (UUID)
    interaction_type TEXT NOT NULL, -- e.g., 'played_in_app', 'shared_in_chat', 'saved_to_library_via_app', 'matched_by_taste_algorithm'
    interacted_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    metadata JSONB -- For extra details, e.g., taste match score, chat message ID if shared.
);

COMMENT ON TABLE public.user_playlist_interactions IS 'Tracks various ways users interact with playlists within the application.';
COMMENT ON COLUMN public.user_playlist_interactions.user_id IS 'Link to the user in public.profiles.';
COMMENT ON COLUMN public.user_playlist_interactions.playlist_id IS 'Link to the playlist in public.playlists (using internal UUID).';
COMMENT ON COLUMN public.user_playlist_interactions.interaction_type IS 'Categorizes the interaction, e.g., played_in_app, shared_in_chat, saved_to_library_via_app, matched_by_taste_algorithm.';
COMMENT ON COLUMN public.user_playlist_interactions.metadata IS 'Flexible JSONB field for additional interaction-specific data (e.g., taste match score).';

ALTER TABLE public.user_playlist_interactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own interactions." ON public.user_playlist_interactions
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own interactions." ON public.user_playlist_interactions
    FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Service role can manage interactions." ON public.user_playlist_interactions
    FOR ALL USING (auth.role() = 'service_role');

COMMIT;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="types/actions.ts">
export type ActionResult<T = void> =
  | { success: true; data: T; message?: string }
  | { success: false; error: string; errorCode?: string; message?: string };
</file>

<file path="types/auth.ts">
export interface SpotifyUserMetadata {
  provider_token?: string;
  provider_refresh_token?: string;
  provider_token_expires_at?: number; // Assuming this is a numeric timestamp
  // You can add other known properties of user_metadata here if needed
}
</file>

<file path="app/_actions/top-items.ts">
import { SpotifyApi, type AccessToken } from '@spotify/web-api-ts-sdk';
import type { Database } from '@/types/database'; // Import generated DB types
import { createClient as createSupabaseServerClient } from '@/lib/supabase/server'; // For server-side Supabase client
import type { ActionResult } from '@/types/actions'; // Standardized ActionResult
import { User } from '@supabase/supabase-js';
// Define DB table row types locally for convenience
type UserTopArtistInsert = Database['public']['Tables']['user_top_artists']['Insert'];
type UserTopTrackInsert = Database['public']['Tables']['user_top_tracks']['Insert'];

// Type for the data part of a successful result
interface TopItemsResultData {
  artistsUpserted: number;
  tracksUpserted: number;
}

export async function fetchAndStoreUserTopItems(
  user: User
): Promise<ActionResult<TopItemsResultData | null>> {
  const supabase = await createSupabaseServerClient();

  if (!user) {
    console.error('[Server Action] User not authenticated.');
    return { success: false, error: 'User not authenticated.' };
  }

  const userId = user.id;

  // Correctly access provider tokens and expiry from user_metadata, handling potential nulls
  const spotifyProviderTokenFromMeta = user.user_metadata?.provider_token;
  const spotifyProviderToken =
    spotifyProviderTokenFromMeta === null
      ? undefined
      : (spotifyProviderTokenFromMeta as string | undefined);

  const spotifyProviderRefreshTokenFromMeta = user.user_metadata?.provider_refresh_token;
  const spotifyProviderRefreshToken =
    spotifyProviderRefreshTokenFromMeta === null
      ? undefined
      : (spotifyProviderRefreshTokenFromMeta as string | undefined);

  const spotifyProviderTokenExpiresAtFromMeta = user.user_metadata?.provider_token_expires_at;
  const spotifyProviderTokenExpiresAt =
    spotifyProviderTokenExpiresAtFromMeta === null
      ? undefined
      : (spotifyProviderTokenExpiresAtFromMeta as number | undefined);

  if (!spotifyProviderToken) {
    console.error(
      '[Server Action] Spotify provider_token not found in user_metadata. Please re-authenticate.'
    );
    return { success: false, error: 'Spotify provider_token not found. Please re-authenticate.' };
  }

  // spotifyProviderToken is now confirmed to be a string

  const spotifyClientId = process.env.SPOTIFY_CLIENT_ID;
  if (!spotifyClientId) {
    console.error('[Server Action] SPOTIFY_CLIENT_ID environment variable not set.');
    return { success: false, error: 'Server configuration error: Spotify Client ID missing.' };
  }

  const tokenDetails: AccessToken = {
    access_token: spotifyProviderToken as string, // Explicitly cast after check
    token_type: 'Bearer',
    expires_in: spotifyProviderTokenExpiresAt
      ? spotifyProviderTokenExpiresAt - Math.floor(Date.now() / 1000)
      : 3600,
    refresh_token: spotifyProviderRefreshToken as string, // Correctly string | undefined
  };

  const spotify = SpotifyApi.withAccessToken(spotifyClientId, tokenDetails);

  console.log(`[Server Action] Starting fetchAndStoreUserTopItems for user: ${userId}`);

  let artistsUpsertedCount = 0;
  let tracksUpsertedCount = 0;

  try {
    // Task 4: Call topItems for artists
    console.log('[Server Action] Fetching top artists...');
    const topArtistsResponse = await spotify.currentUser.topItems('artists', 'medium_term', 50);
    console.log(`[Server Action] Fetched ${topArtistsResponse.items.length} top artists.`);

    // Task 5: Process top artists response
    if (topArtistsResponse.items.length > 0) {
      const artistsToUpsert: UserTopArtistInsert[] = topArtistsResponse.items.map((artist) => ({
        user_id: userId,
        artist_spotify_id: artist.id,
        name: artist.name,
        genres: artist.genres,
        popularity: artist.popularity,
        image_url: artist.images?.[0]?.url ?? null,
      }));

      // Task 6: Implement Supabase upsert for artists
      console.log(`[Server Action] Upserting ${artistsToUpsert.length} artists...`);
      const { error: artistsError, count } = await supabase
        .from('user_top_artists')
        .upsert(artistsToUpsert, { onConflict: 'user_id, artist_spotify_id' })
        .select();

      if (artistsError) {
        console.error('[Server Action] Error upserting artists:', artistsError.message);
        return {
          success: false,
          error: 'Failed to store top artists: ' + artistsError.message,
        };
      }
      artistsUpsertedCount = count ?? artistsToUpsert.length; // Fallback if count is null
      console.log(`[Server Action] Successfully upserted ${artistsUpsertedCount} artists.`);
    } else {
      console.log('[Server Action] No top artists found to upsert.');
    }

    // Task 7: Call topItems for tracks
    console.log('[Server Action] Fetching top tracks...');
    const topTracksResponse = await spotify.currentUser.topItems('tracks', 'medium_term', 50);
    console.log(`[Server Action] Fetched ${topTracksResponse.items.length} top tracks.`);

    // Task 8: Process top tracks response
    if (topTracksResponse.items.length > 0) {
      const tracksToUpsert: UserTopTrackInsert[] = topTracksResponse.items.map((track) => ({
        user_id: userId,
        track_spotify_id: track.id,
        name: track.name,
        artists: track.artists.map((artist) => ({
          spotify_id: artist.id,
          name: artist.name,
        })),
        album_spotify_id: track.album.id,
        album_name: track.album.name,
        album_image_url: track.album.images?.[0]?.url ?? null,
        popularity: track.popularity,
        duration_ms: track.duration_ms,
        preview_url: track.preview_url ?? null,
      }));

      // Task 9: Implement Supabase upsert for tracks
      console.log(`[Server Action] Upserting ${tracksToUpsert.length} tracks...`);
      const { error: tracksError, count: trackCountResponse } = await supabase
        .from('user_top_tracks')
        .upsert(tracksToUpsert, { onConflict: 'user_id, track_spotify_id' })
        .select();

      if (tracksError) {
        console.error('[Server Action] Error upserting tracks:', tracksError.message);
        return {
          success: false,
          error: 'Failed to store top tracks: ' + tracksError.message,
        };
      }
      tracksUpsertedCount = trackCountResponse ?? tracksToUpsert.length; // Fallback if count is null
      console.log(`[Server Action] Successfully upserted ${tracksUpsertedCount} tracks.`);
    } else {
      console.log('[Server Action] No top tracks found to upsert.');
    }

    // Task 11: Return Value
    return {
      success: true,
      data: {
        artistsUpserted: artistsUpsertedCount,
        tracksUpserted: tracksUpsertedCount,
      },
      message: `Successfully fetched and stored ${artistsUpsertedCount} artists and ${tracksUpsertedCount} tracks.`,
    };
  } catch (error: unknown) {
    let errorMessage = 'An unknown error occurred while fetching/storing top items.';
    if (error instanceof Error) {
      errorMessage = error.message;
    }
    console.error(
      '[Server Action] General error in fetchAndStoreUserTopItems:',
      errorMessage,
      error
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}
</file>

<file path="app/(protected)/profile/page.tsx">
import { redirect } from 'next/navigation';

export default function page() {
  return redirect('/profile/playlists');
}
</file>

<file path="components/current-user-avatar.tsx">
'use client'

import { useCurrentUserImage } from '@/hooks/use-current-user-image'
import { useCurrentUserName } from '@/hooks/use-current-user-name'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'

export const CurrentUserAvatar = () => {
  const profileImage = useCurrentUserImage()
  const name = useCurrentUserName()

  console.log('profileImage', profileImage);
  const initials = name
    ?.split(' ')
    ?.map((word) => word[0])
    ?.join('')
    ?.toUpperCase()

  return (
    <Avatar>
      {profileImage && <AvatarImage src={profileImage} alt={initials} />}
      <AvatarFallback>{initials}</AvatarFallback>
    </Avatar>
  )
}
</file>

<file path="components/nav/logout-action.ts">
'use server';

import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';

export const signOutAction = async () => {
  const supabase = await createClient();
  await supabase.auth.signOut();
  return redirect('/');
};
</file>

<file path="components/nav/nav.tsx">
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Suspense, useState, useEffect } from 'react';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Button } from '../ui/button';
import PlayerUI from '../player/player';
import {
  Music,
  ChevronDown,
  ChevronUp,
  MessageCircle,
  User as UserIcon,
  LogOut,
} from 'lucide-react';
import { Avatar, AvatarImage, AvatarFallback } from '../ui/avatar';
import { User } from '@supabase/supabase-js';
import Notifications from './notifications';
import { signOutAction } from './logout-action';
import { PlayerTrigger } from '../player/player-trigger';
import { useMusic } from '@/music-context/music-context';
import Image from 'next/image';
/**
 * Renders the navigation header specific to the rooms section.
 * Includes user avatar popover with logout and conditional playlist adding.
 */
export function Nav({ user }: { user: User | null }) {
  const pathname = usePathname();
  const [isExpanded, setIsExpanded] = useState(false);
  const { playbackState } = useMusic();

  const isPlaying = playbackState ? !playbackState.paused : false;
  const currentTrack = playbackState?.track_window?.current_track;
  const albumArtUrl = currentTrack?.album?.images?.[0]?.url;

  // const navigateAndExpand = (path: string) => {
  //   router.push(path);
  //   setIsExpanded(true);
  // };

  useEffect(() => {
    if (!pathname.startsWith('/profile')) {
      setIsExpanded(false);
    }
  }, [pathname]);

  return (
    <nav className='absolute top-0 z-50 px-5 bg-teal-dark w-full'>
      <div className='flex h-14 items-center'>
        <Link href='/' className='mr-6 flex items-center space-x-2'>
          <span className='font-bold'>Discovered.fm</span>
        </Link>
        <div className='flex flex-1 items-center space-x-2 justify-end'>
          <nav className='flex items-center space-x-2'>
            <Notifications />
            <Popover>
              <PopoverTrigger asChild>
                <PlayerTrigger isPlaying={isPlaying}>
                  {albumArtUrl ? (
                    <Image
                      src={albumArtUrl}
                      alt={currentTrack?.name ?? 'Album art'}
                      className='h-6 w-6 rounded object-cover'
                      fill
                      sizes='(max-width: 768px) 100vw, (max-width: 200px) 50vw, 25vw'
                    />
                  ) : (
                    <Music className='h-6 w-6 text-accent2 hover:text-accent2/90' />
                  )}
                </PlayerTrigger>
              </PopoverTrigger>
              <PlayerUI />
            </Popover>
            {user ? (
              <Suspense fallback={<div className='h-8 w-8 rounded-full bg-muted' />}>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant='ringAround'
                      size='icon'
                      aria-label='Open music player'
                      type='button'
                    >
                      <Avatar>
                        <AvatarImage
                          className='object-cover'
                          src={user?.user_metadata.avatar_url}
                          alt={user?.user_metadata.name}
                        />
                        <AvatarFallback>{user?.user_metadata.name}</AvatarFallback>
                      </Avatar>
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className='w-56' align='start' forceMount sideOffset={8}>
                    <div className='flex flex-col gap-1'>
                      <Button
                        variant='ghost'
                        asChild
                        className={`${pathname === '/chat' ? '' : ''} pl-6 justify-start`}
                      >
                        <Link href='/chat'>
                          <MessageCircle className='h-4 w-4 mr-2' />
                          Chat
                        </Link>
                      </Button>
                      <Button
                        className='relative disabled:opacity-100 pl-6 justify-start'
                        variant='ghost'
                        onClick={() => (isExpanded ? setIsExpanded(false) : setIsExpanded(true))}
                      >
                        <UserIcon className='h-4 w-4 mr-2' />
                        Profile
                        <span className='flex items-center gap-1 absolute right-2'>
                          {isExpanded ? (
                            <ChevronUp className='h-4 w-4' />
                          ) : (
                            <ChevronDown className='h-4 w-4' />
                          )}
                        </span>
                      </Button>
                      <div
                        className={`transition-all flex flex-col duration-300 relative py-1 ${isExpanded ? 'opacity-100 h-auto block ' : 'opacity-0 h-0 hidden'}`}
                      >
                        <div className='h-full flex items-center absolute left-4.5 top-0 bottom-0'>
                          <div className='border-l-2 border-popover-foreground/25 pl-4 h-24' />
                        </div>
                        <div className='flex flex-col gap-2 pl-6 ml-2 mr-2-'>
                          <Button
                            size='sm'
                            variant='ghost'
                            asChild
                            className={`${pathname === '/profile/playlists' ? '' : ''} justify-start pl-5`}
                          >
                            <Link href='/profile/playlists'>Playlists</Link>
                          </Button>
                          <Button
                            size='sm'
                            variant='ghost'
                            asChild
                            className={`${pathname === '/profile/profile-page' ? '' : ''} justify-start pl-5`}
                          >
                            <Link href='/profile/profile-page'>Profile page</Link>
                          </Button>
                          <Button
                            size='sm'
                            variant='ghost'
                            asChild
                            className={`${pathname === '/profile/play-history' ? '' : ''} justify-start pl-5`}
                          >
                            <Link href='/profile/play-history'>Play History</Link>
                          </Button>
                        </div>
                      </div>
                      <Suspense fallback={null}>
                        <form className='w-full' action={signOutAction}>
                          <Button type='submit' className='w-full justify-start ' variant={'ghost'}>
                            <LogOut className='!h-3.5 !w-3.5 ml-0.5 mr-2' />
                            Sign out
                          </Button>
                        </form>
                      </Suspense>
                    </div>
                  </PopoverContent>
                </Popover>
              </Suspense>
            ) : (
              <Button asChild variant='default'>
                <Link href='/auth/login'>Sign in</Link>
              </Button>
            )}
          </nav>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="components/nav/notifications.tsx">
import { Bell } from 'lucide-react';
import { Button } from '../ui/button';
import { Popover, PopoverContent, PopoverTrigger } from '../ui/popover';

// Removed local Notification interface, will use NotificationItemProps directly from context/item

export default function Notifications() {
  // const handleMarkAllAsRead = async () => { // Will be enabled later
  //   try {
  //     // await markAllNotificationsAsRead();
  //   } catch (err) {
  //     // Handle error appropriately, e.g., show a toast notification
  //     console.error("Failed to mark all notifications as read:", err);
  //   }
  // };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant='ringAround'
          size='icon'
          aria-label='Open notifications'
          type='button'
          className='relative'
        >
          <Bell className='h-6 w-6 text-accent2 hover:text-accent2/90' />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className='w-80 md:w-96'
        align='end'
        forceMount
        sideOffset={8}
      ></PopoverContent>
    </Popover>
  );
}
</file>

<file path="components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  );
}

interface CardContentProps extends React.HTMLAttributes<HTMLElement> {
  as?: 'div' | 'ul';
  className?: string;
}

function CardContent({ className, as: Tag = 'div', ...props }: CardContentProps) {
  return <Tag data-slot='card-content' className={cn('px-6', className)} {...props} />;
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};
</file>

<file path="components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot='popover-content'
        align={align}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md p-4 shadow-md outline-hidden',
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot='slider'
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        'relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col',
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot='slider-track'
        className={cn(
          'bg-popover-foreground/50 relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5'
        )}
      >
        <SliderPrimitive.Range
          data-slot='slider-range'
          className={cn(
            'bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full'
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot='slider-thumb'
          key={index}
          className='border-popover-foreground bg-popover-foreground ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50'
        />
      ))}
    </SliderPrimitive.Root>
  );
}

export { Slider }
</file>

<file path="hooks/use-chat-scroll.tsx">
'use client';

import { useCallback } from 'react';

export function useChatScroll(containerRef: React.RefObject<HTMLDivElement>) {
  const scrollToBottom = useCallback(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    container.scrollTo({
      top: container.scrollHeight,
      behavior: 'smooth',
    });
  }, []);

  return { containerRef, scrollToBottom };
}
</file>

<file path="hooks/use-current-user-name.ts">
import { createClient } from '@/lib/supabase/client'
import { useEffect, useState } from 'react'

export const useCurrentUserName = () => {
  const [name, setName] = useState<string | null>(null)

  useEffect(() => {
    const fetchProfileName = async () => {
      try {
        const { data, error } = await createClient().auth.getUser();
        if (error) {
          // Only log if not AuthSessionMissingError
          if (error.name !== 'AuthSessionMissingError') {
            console.error(error);
          }
          // If AuthSessionMissingError, treat as logged out
          setName(null);
          return;
        }
        setName(data.user?.user_metadata.full_name ?? '?');
      } catch (err: unknown) {
        if (
          typeof err === 'object' &&
          err !== null &&
          'name' in err &&
          (err as { name: string }).name === 'AuthSessionMissingError'
        ) {
          setName(null);
        } else {
          console.error(err);
          setName('?');
        }
      }
    }
    fetchProfileName()
  }, [])

  return name || '?'
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Formats a duration in milliseconds into a "mm:ss" string.
 * Returns "" if the duration is null, undefined, or not a positive number.
 * @param ms The duration in milliseconds.
 * @returns The formatted time string or "".
 */
export function formatTime(ms: number | null | undefined): string {
  if (ms === null || ms === undefined || isNaN(ms) || ms < 0) {
    return '';
  }

  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;

  const formattedMinutes = String(minutes).padStart(2, '0'); // Ensure two digits for minutes
  const formattedSeconds = String(seconds).padStart(2, '0');

  return `${formattedMinutes}:${formattedSeconds}`;
}
</file>

<file path="music-context/user-session.ts">
import { createClient } from '@/lib/supabase/client';

export interface UserSessionState {
  userSpotifyId: string | null;
  userId: string | null;
  isLoading: boolean;
  error: string | null;
}

export type UserSessionListener = (state: UserSessionState) => void;

let supabaseListener:
  | ReturnType<typeof createClient.prototype.auth.onAuthStateChange>['data']['subscription']
  | null = null;
let profileListenerUnsubscribe: (() => void) | null = null;

const listeners = new Set<UserSessionListener>();

let internalState: UserSessionState = {
  userSpotifyId: null,
  userId: null,
  isLoading: true,
  error: null,
};

const updateState = (newState: Partial<UserSessionState>) => {
  internalState = { ...internalState, ...newState, isLoading: false };
  listeners.forEach((listener) => listener(internalState));
};

const setupProfileListener = async (supabase: ReturnType<typeof createClient>, userId: string) => {
  if (profileListenerUnsubscribe) {
    profileListenerUnsubscribe();
    profileListenerUnsubscribe = null;
  }

  try {
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('spotify_user_id')
      .eq('id', userId)
      .single();

    if (profileError) {
      console.error('Error fetching user profile:', profileError);
      updateState({ userSpotifyId: null, error: profileError.message });
    } else {
      updateState({ userSpotifyId: profile?.spotify_user_id || null });
    }

    const channel = supabase
      .channel(`public:profiles:id=eq.${userId}`)
      .on(
        'postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'profiles', filter: `id=eq.${userId}` },
        (payload) => {
          const updatedProfile = payload.new as { spotify_user_id?: string };
          if (updatedProfile && typeof updatedProfile.spotify_user_id === 'string') {
            updateState({ userSpotifyId: updatedProfile.spotify_user_id });
          }
        }
      )
      .subscribe((status, err) => {
        if (status === 'SUBSCRIBED') {
          // console.log('Subscribed to profile changes for user:', userId);
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
          if (err) {
            console.error(
              'Error subscribing to profile changes for user:',
              userId,
              'Status:',
              status,
              'Error:',
              err
            );
          } else {
            console.error(
              'Error subscribing to profile changes for user:',
              userId,
              'Status:',
              status,
              'Error: Unknown (no error object provided).'
            );
          }
          // Optionally update state with an error
        }
      });

    profileListenerUnsubscribe = () => {
      supabase.removeChannel(channel).catch(console.error);
    };
  } catch (e) {
    console.error('Exception in setupProfileListener:', e);
    updateState({ error: e instanceof Error ? e.message : 'Error setting up profile listener' });
  }
};

export const initializeUserSession = (): (() => void) => {
  const supabase = createClient();
  // Set loading true on init, but don't assume an error yet.
  internalState = { ...internalState, isLoading: true, error: null };

  supabase.auth
    .getUser()
    .then(async ({ data: { user }, error: authError }) => {
      if (authError) {
        // Check if the error is the expected "AuthSessionMissingError"
        if (authError.name === 'AuthSessionMissingError') {
          console.log(
            '[user-session.ts] Auth session missing during init (expected for logged-out users).'
          );
          updateState({
            userId: null,
            userSpotifyId: null,
            error: null, // Set error to null for this specific, expected case
            isLoading: false,
          });
        } else {
          // It's some other, unexpected auth error
          console.error('[user-session.ts] Error in getUser during init:', authError);
          updateState({
            userId: null,
            userSpotifyId: null,
            error: authError.message, // Report the actual error message
            isLoading: false,
          });
        }
        return;
      }

      if (user) {
        updateState({
          userId: user.id,
          error: null, // Clear previous error
          isLoading: false,
        });
        await setupProfileListener(supabase, user.id);
      } else {
        // No user session found
        updateState({
          userId: null,
          userSpotifyId: null,
          error: null, // No error, just no session
          isLoading: false,
        });
      }
    })
    .catch((e) => {
      console.error('Error during session initialization get User:', e);
      updateState({
        userId: null,
        userSpotifyId: null,
        error: e instanceof Error ? e.message : 'Error initializing session',
        isLoading: false,
      });
    });

  const authSubscription = supabase.auth.onAuthStateChange(async (event, session) => {
    if (profileListenerUnsubscribe) {
      profileListenerUnsubscribe();
      profileListenerUnsubscribe = null;
    }

    if (!session?.user) {
      console.log('[user-session.ts] onAuthStateChange: No user in session. Event:', event);
      updateState({
        userSpotifyId: null,
        userId: null,
        error: event === 'SIGNED_OUT' ? null : 'User session missing.',
        isLoading: false,
      });
    } else {
      updateState({
        userId: session.user.id,
        error: null,
        isLoading: false,
      });
      await setupProfileListener(supabase, session.user.id);
    }
  });

  supabaseListener = authSubscription.data.subscription;

  return () => {
    supabaseListener?.unsubscribe();
    if (profileListenerUnsubscribe) {
      profileListenerUnsubscribe();
    }
    listeners.clear(); // Clear all listeners on cleanup
  };
};

export const subscribeToUserSession = (listener: UserSessionListener): (() => void) => {
  listeners.add(listener);
  listener(internalState); // Immediately call with current state
  return () => listeners.delete(listener);
};

// Helper function to get current state directly if needed without subscription
export const getCurrentUserSessionState = (): UserSessionState => {
  return { ...internalState };
};
</file>

<file path="types/music-context.ts">
import { Playlist } from './spotify';

export interface MusicContextState {
  player: Spotify.Player | null;
  deviceId: string | null;
  isReady: boolean;
  playbackState: Spotify.PlaybackState | null;
  currentVolumePercent: number | null;
  error: string | null;
  // User Info
  userSpotifyId: string | null;

  // Playlist State
  tasteMatchedPlaylists: Playlist[];
  currentPlaylistIndex: number | null;
  currentPlaylistName: string | null;

  // Save/Follow State
  isCurrentTrackSaved: boolean | null;
  isCurrentPlaylistFollowed: boolean | null;

  // Player control functions
  nextTrack: () => Promise<void>;
  previousTrack: () => Promise<void>;
  setVolume: (volume: number) => Promise<void>;
  toggleMute: () => Promise<void>;

  // Playlist control functions
  playPlaylist: (playlist: Playlist, trackIndex?: number) => Promise<void>;
  nextPlaylist: () => Promise<void>;
  previousPlaylist: () => Promise<void>;
  playPlaylistWithCustomShuffle: (playlist: Playlist, trackIndex?: number) => Promise<void>;

  // Save/Follow Check/Action Methods
  checkIfTrackIsSaved: (trackId: string) => Promise<void>;
  saveCurrentTrack: () => Promise<void>;
  unsaveCurrentTrack: () => Promise<void>;
  checkIfPlaylistIsFollowed: (playlistId: string) => Promise<void>;
  followCurrentPlaylist: () => Promise<void>;
  unfollowCurrentPlaylist: () => Promise<void>;

  // Timeline State & Seek Capability
  trackPositionMs: number | null;
  trackDurationMs: number | null;
  seek: (positionMs: number) => Promise<void>;
}
</file>

<file path="app/(protected)/chat/[chatId]/page.tsx">
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import type { MessageSenderProfile, ChatMessage } from '@/hooks/use-realtime-chat';
// import RealtimeChatLoader from '@/components/realtime-chat-loader'; // Added
import { RealtimeChat } from '@/components/realtime-chat';
import { Suspense } from 'react';

interface RawChatMessageFromDB {
  id: string | number;
  content: string;
  created_at: string;
  user_id: string;
  room_id: string;
  profile: MessageSenderProfile | MessageSenderProfile[] | null;
}

interface ChatRoomPagePromise {
  params: Promise<{
    chatId: string; // This will be the UUID of the chat room from the URL
  }>;
}

export default async function ChatRoomPage({ params }: ChatRoomPagePromise) {
  const { chatId } = await params;
  const supabase = await createClient();

  // Fetch user and initial messages in parallel
  const [userAuthResult, initialMessagesResult] = await Promise.all([
    supabase.auth.getUser(),
    supabase
      .from('chat_messages')
      .select(
        `
        id,
        content,
        created_at,
        user_id,
        room_id,
        profile:profiles (
          id,
          username,
          avatar_url
        )
      `
      )
      .eq('room_id', chatId)
      .order('created_at', { ascending: true })
      .limit(50),
  ]);

  const {
    data: { user },
    error: userError,
  } = userAuthResult;

  if (userError || !user) {
    console.error('Error fetching user or user not authenticated:', userError);
    redirect('/login');
    return; // Stop further execution
  }

  const userId = user.id;

  // Fetch current user's profile (depends on userId)
  const { data: currentUserProfileData, error: profileError } = await supabase
    .from('profiles')
    .select('id, username, avatar_url') // Fetch id, username, and avatar_url
    .eq('id', userId)
    .single<MessageSenderProfile>(); // Cast to MessageSenderProfile

  if (profileError || !currentUserProfileData) {
    console.error(`Error fetching full profile for user ${userId}:`, profileError);
    redirect('/login?error=profile_fetch_failed');
    return; // Stop further execution
  }

  // Explicitly check if username is null or empty after successful profile fetch
  if (!currentUserProfileData.username) {
    console.error(`Username is missing for user ${userId}:`);
    redirect('/login?error=username_missing');
    return; // Stop further execution
  }

  const currentUserProfile = currentUserProfileData;

  // Process initial messages
  let initialMessages: ChatMessage[] = [];
  const { data: initialMessagesData, error: messagesError } = initialMessagesResult;

  if (messagesError) {
    console.error(`Error fetching initial messages for room ${chatId}:`, messagesError);
  } else if (initialMessagesData) {
    initialMessages = initialMessagesData
      .map((msg: RawChatMessageFromDB) => {
        let userProfile: MessageSenderProfile | null = null;
        if (msg.profile) {
          if (Array.isArray(msg.profile)) {
            userProfile = msg.profile.length > 0 ? (msg.profile[0] as MessageSenderProfile) : null;
          } else {
            userProfile = msg.profile as MessageSenderProfile;
          }
        }

        if (!msg.created_at) {
          console.warn(
            'Message found with null created_at, using current time as fallback:',
            msg.id
          );
        }

        return {
          id: msg.id as number | string,
          clientSideId: msg.id.toString(),
          content: msg.content as string,
          created_at: msg.created_at || new Date().toISOString(),
          profile: userProfile,
          isOptimistic: false,
        };
      })
      .filter(Boolean) as ChatMessage[];
  }

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <RealtimeChat // Changed
        roomName={chatId}
        currentUserProfile={currentUserProfile}
        initialMessages={initialMessages}
      />
    </Suspense>
  );
}
</file>

<file path="app/(protected)/layout.tsx">
import React from 'react';

export default async function layout({ children }: { children: React.ReactNode }) {
  return (
    <div className='flex flex-col h-full'>
      <div className='absolute top-0 left-0 w-full h-full z-0 bg-linear-[170deg,_var(--teal-dark)_25%,_oklch(from_var(--seafoam-green)_l_c_h_/_0.4)_50%,_transparent_70%,_transparent_100%]' />
      {children}
    </div>
  );
}
</file>

<file path="app/auth/oauth/route.ts">
import { NextResponse } from "next/server";
// The client you created from the Server-Side Auth instructions
import { createClient } from "@/lib/supabase/server";
import { fetchAndStoreUserTopItems } from '@/app/_actions/top-items';
import { User } from '@supabase/supabase-js';

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get('code');
  // if "next" is in param, use it as the redirect URL
  const next = searchParams.get('next') ?? '/';

  if (code) {
    const supabase = await createClient();
    const { error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);

    if (!exchangeError) {
      // Code exchange successful, now get the session to access provider tokens

      const { data: sessionData, error: sessionError } = await supabase.auth.getSession();

      if (sessionError || !sessionData.session) {
        console.error('OAuth callback: Error getting session after code exchange:', sessionError);
        // Redirect to error page or handle differently
        return NextResponse.redirect(`${origin}/auth/error?message=session-fetch-failed`);
      }

      const session = sessionData.session;
      console.log(
        'OAuth callback: Session obtained after exchange:',
        JSON.stringify(session, null, 2)
      );

      // Extract provider tokens from the session
      const providerToken = session.provider_token;
      const providerRefreshToken = session.provider_refresh_token;
      const providerExpiresAt = session.expires_at; // Spotify uses expires_at

      if (!providerToken || !providerRefreshToken) {
        console.warn(
          'OAuth callback: Provider tokens not found in session after exchange. Scopes might be missing or login flow issue.'
        );
        // Proceed with redirect, but SDK might fail later
      } else {
        console.log('OAuth callback: Provider tokens found, attempting to save to user_metadata.');
        // Save tokens to user_metadata
        const { data, error: updateError } = await supabase.auth.updateUser({
          data: {
            provider_token: providerToken,
            provider_refresh_token: providerRefreshToken,
            provider_token_expires_at: providerExpiresAt, // Store expiry too
            // Add any other metadata you want to persist here
          },
        });

        if (data.user || !updateError) {
          await fetchAndStoreUserTopItems(data.user as User);
        }

        if (updateError) {
          console.error(
            'OAuth callback: Error updating user metadata with provider tokens:',
            updateError
          );
        } else {
          console.log('OAuth callback: Successfully saved provider tokens to user_metadata.');
        }
      }

      const forwardedHost = request.headers.get('x-forwarded-host'); // original origin before load balancer
      const isLocalEnv = process.env.NODE_ENV === 'development';
      if (isLocalEnv) {
        // we can be sure that there is no load balancer in between, so no need to watch for X-Forwarded-Host
        return NextResponse.redirect(`${origin}${next}`);
      } else if (forwardedHost) {
        return NextResponse.redirect(`https://${forwardedHost}${next}`);
      } else {
        return NextResponse.redirect(`${origin}${next}`);
      }
    } else {
      console.error('OAuth callback: Error exchanging code for session:', exchangeError);
    }
  }

  // return the user to an error page with instructions
  return NextResponse.redirect(`${origin}/auth/error`);
}
</file>

<file path="app/page.tsx">
import Image from 'next/image';
import { CLOUDINARY_URLS } from '@/lib/cloudinary-urls';
import { RiSpotifyFill } from '@remixicon/react';
import { Button } from '@/components/ui/button';

export default async function Home() {
  return (
    <div className='max-w-screen-xl w-full h-full relative bg-sandLight'>
      <div className='absolute top-0 left-0 w-full h-full z-0 noise' />
      <div className=' relative'>
        <div className='absolute top-0 left-0 w-full h-full z-10 bg-linear-[170deg,_var(--teal-dark)_25%,_oklch(from_var(--seafoam-green)_l_c_h_/_0.4)_50%,_transparent_70%,_transparent_100%]' />

        <header className='w-full  flex flex-col justify-center z-10 relative pt-28 pb-16 '>
          <div className='max-w-[55rem] sm:max-w-[53rem] px-4 sm:px-6 mx-auto '>
            <div className='relative z-10'>
              <Image
                src={CLOUDINARY_URLS.HEADER}
                alt='Discover'
                width={1000}
                height={1000}
                className='rounded-l-full overflow-hidden'
              />
              <div className='aspect-square absolute top-0 left-0 w-full h-full z-10'>
                <div className='absolute top-1/2 left-[53%] transform -translate-x-1/4 -translate-y-1/2 flex gap-5  flex-col justify-center items-center'>
                  <h1 className='text-center text-[clamp(2.4rem,9vw,5.5rem)] lg:text-[5.5rem] leading-[clamp(1.7rem,8vw,4.5rem)] font-black'>
                    Discover Curated Playlists
                  </h1>
                  <p className='text-center text-[clamp(1.1rem,3vw,2rem)] lg:text-[2rem] leading-[clamp(1.5rem,3.8vw,2.5rem)] hidden xs:block px-4 font-medium'>
                    Discover music outside the algorithms.
                  </p>

                  <p className='flex items-center gap-2 text-center text-[clamp(0.8rem,2.5vw,1.2rem)] leading-[clamp(1.5rem,2vw,1.6rem)]'>
                    <RiSpotifyFill className='text-spotifyGreen' size={20} />
                    Discover in Spotify
                  </p>
                </div>
              </div>
            </div>
          </div>
        </header>

        <section className='grid place-content-start grid-cols-12 px-4 sm:px-6 max-w-[55rem] sm:max-w-[53rem] mx-auto z-10 relative '>
          <div className='z-10 relative row-start-1 col-span-10 col-start-2 h-fit mb-0 sm:mb-8'>
            <div className='flex flex-col gap-5 px-5 text-center text-balance  max-w-2xl mx-auto'>
              <h2 className='text-[clamp(2rem,5.6vw,3rem)] leading-[clamp(2rem,5.4vw,2.7rem)] font-black text-foreground mx-auto'>
                Music from new sources
              </h2>
              <div className='text-[clamp(1.2rem,2.7vw,1.3rem)] leading-[clamp(1.4rem,5vw,2rem)] text-pretty font-medium'>
                <p>
                  Machine learning is in many ways great, but sometimes we&apos;d like to take a
                  leap into something new musically and head into a different direction. And did you
                  know we could actually be crow sourcing good music?
                </p>
              </div>
            </div>
          </div>
          <div className='sm:col-span-9 sm:col-start-1 row-start-3 sm:row-start-2 col-span-10 col-start-2'>
            <Image
              src={CLOUDINARY_URLS.SECTION1}
              alt='Discover'
              width={1000}
              height={1000}
              className='w-full h-full object-cover object-right-top rounded-[3rem] relative z-10 '
            />
          </div>
          <div className='sm:col-span-3 col-span-12 sm:col-start-10 row-start-2 sm:row-start-2 flex items-center justify-center my-8 sm:mt-0 sm:mb-0'>
            <ul className='gap-4 xs:gap-8 items-center text-center text-pretty flex sm:flex-col flex-row justify-center text-[clamp(0.8rem,2vw,1.2rem)]  font-bold'>
              <li className='flex items-center gap-2 text-pretty flex-col '>
                <Image
                  src={CLOUDINARY_URLS.RECORD}
                  alt='Discover'
                  width={50}
                  height={50}
                  className='w-7 h-7 opacity-85'
                />
                <p>
                  More playlist <br /> followers
                </p>
              </li>
              <li className='flex items-center gap-2 text-pretty flex-col '>
                <Image
                  src={CLOUDINARY_URLS.RECORD}
                  alt='Discover'
                  width={50}
                  height={50}
                  className='w-7 h-7 opacity-85'
                />
                <p>
                  Play music right <br /> inside the app
                </p>
              </li>
              <li className='flex items-center gap-2 text-pretty flex-col '>
                <Image
                  src={CLOUDINARY_URLS.RECORD}
                  alt='Discover'
                  width={50}
                  height={50}
                  className='w-7 h-7 opacity-85'
                />
                <p>
                  Shuffle curated <br /> playlists
                </p>
              </li>
            </ul>
          </div>
        </section>
      </div>
      <div className=' relative w-full mt-16 max-w-5xl mx-auto min-h-[500px]'>
        <div className='absolute top-0 left-0 w-full h-full z-10 bg-linear-[174deg,_transparent_20%,_oklch(from_var(--seafoam-green)_l_c_h_/_0.4)_45%,_var(--teal-dark)_100%]' />
        <section className='w-full px-4 sm:px-6 max-w-[55rem] sm:max-w-[53rem] mx-auto z-10 relative grid grid-cols-11  items-center'>
          <div className='bg-gradient-to-br from-peach to-sandLight to-70% rounded-[3rem] overflow-hidden col-span-6'>
            <Image
              src={CLOUDINARY_URLS.SECTION2}
              alt='Discover'
              width={500}
              height={500}
              className='object-cover w-full h-full object-right rounded-[3rem] relative z-10 '
            />
          </div>

          <div className='col-span-4 flex flex-col gap-4 justify-center items-center relative right-2 sm:right-4 max-w-[190px] w-full z-10'>
            <h3 className='text-[clamp(1.2rem,3vw,1.5rem)] leading-[clamp(1.2rem,4vw,2.2rem)] font-bold text-center'>
              Login with Spotify to get started
            </h3>

            <Button className='w-full shadow-sm' size={'lg'}>
              <RiSpotifyFill className='!w-5 !h-5 text-spotifyGreen' /> Login to Spotify
            </Button>
          </div>
        </section>
      </div>
    </div>
  );
}
</file>

<file path="components/player/player.tsx">
'use client';

import React from 'react';
import { useMusic } from '@/music-context/music-context'; // Import the custom hook

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'; // Assuming Shadcn Avatar is installed
import { Button } from '@/components/ui/button'; // Import Button
import { Slider } from '@/components/ui/slider'; // Added Slider
import {
  Music,
  Play,
  Pause,
  SkipForward,
  SkipBack,
  ListMusic,
  ChevronFirst,
  ChevronLast,
} from 'lucide-react'; // Added Volume2, VolumeX, Shuffle, Rewind, FastForward, Heart, CheckCircle, PlusCircle
import { PopoverContent } from '@/components/ui/popover';
import { RiAddCircleFill, RiCheckboxCircleFill } from '@remixicon/react';
import { formatTime } from '@/lib/utils'; // Import formatTime
import { VolumePopover } from '@/components/player/VolumePopover'; // Import VolumePopover

const PlayerUI = () => {
  // Task 2: Use the hook to get context state
  const {
    player,
    playbackState,
    isReady,
    deviceId,
    nextTrack,
    previousTrack,
    nextPlaylist,
    previousPlaylist,
    isCurrentTrackSaved,
    saveCurrentTrack,
    unsaveCurrentTrack,
    currentPlaylistName,
    trackPositionMs,
    trackDurationMs,
    seek,
  } = useMusic();

  // Use the track history hook to track play duration and mark tracks as played

  const [optimisticSliderValue, setOptimisticSliderValue] = React.useState<number | null>(null);

  const currentTrack = playbackState?.track_window?.current_track;
  const albumArtUrl = currentTrack?.album?.images?.[0]?.url; // Get the first image URL
  // const isCheckingPlayedStatus = checkingPlayedTrackId === currentTrack?.id;

  const handleSeek = (value: number[]) => {
    if (seek && trackDurationMs) {
      seek(value[0]);
    }
    setOptimisticSliderValue(null); // Reset optimistic value after seek
  };

  const handleSliderChange = (value: number[]) => {
    setOptimisticSliderValue(value[0]);
  };

  const displayPosition = optimisticSliderValue !== null ? optimisticSliderValue : trackPositionMs;
  const showTimeline = trackDurationMs && trackDurationMs > 0;

  return (
    <PopoverContent align='end' sideOffset={8} className='w-[310px] bg-popover shadow-lg p-4'>
      <div className='flex flex-col bg-popover overflow-hidden relative'>
        <div className='flex items-center p-3 gap-3'>
          <Avatar className='h-16 w-16 rounded-md flex-shrink-0'>
            <AvatarImage src={albumArtUrl} alt={currentTrack?.album?.name || 'Album art'} />
            <AvatarFallback className='rounded-md bg-muted'>
              <Music className='h-5 w-5 text-muted-foreground' />
            </AvatarFallback>
          </Avatar>
          <div className='min-w-0 flex-1'>
            {currentTrack ? (
              <div className=''>
                <div className='font-medium text-sm truncate'>{currentTrack.name}</div>
                <div className='text-xs truncate'>
                  {currentTrack.artists.map((artist) => artist.name).join(', ')}
                </div>
                {currentPlaylistName && (
                  <div className='text-xs text-popover-foreground/60 truncate mt-1'>
                    <span className='inline-flex items-center'>
                      <ListMusic className='!h-3 !w-3 mr-1' />
                      {currentPlaylistName}
                    </span>
                  </div>
                )}
              </div>
            ) : (
              <div className='text-sm text-muted-foreground'>Nothing playing</div>
            )}
          </div>
        </div>

        {/* Timeline Section */}
        <div className='px-3 pt-1 pb-2'>
          <div className='flex justify-between items-center text-xs text-muted-foreground mb-1'>
            <span>{formatTime(showTimeline ? displayPosition : 0)}</span>
            <span>{formatTime(trackDurationMs)}</span>
          </div>
          <Slider
            value={
              showTimeline
                ? [optimisticSliderValue !== null ? optimisticSliderValue : (trackPositionMs ?? 0)]
                : [0]
            }
            max={showTimeline ? (trackDurationMs ?? 100) : 100} // Ensure max is not 0 to prevent errors
            step={1000} // Seek in 1-second increments
            disabled={!showTimeline || !isReady || !player || !deviceId}
            onValueChange={handleSliderChange}
            onValueCommit={handleSeek}
            aria-label='Track progress'
            aria-valuemin={0}
            aria-valuemax={trackDurationMs ?? 0}
            aria-valuenow={displayPosition ?? 0}
            className='w-full h-2 [&>span:first-child]:h-2 [&>span:first-child>span]:h-2'
          />
        </div>

        <div className='flex justify-between items-center p-2 gap-2'>
          <VolumePopover />

          <div className='flex justify-center items-center gap-1'>
            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={async (e) => {
                e.stopPropagation();
                if (previousPlaylist) await previousPlaylist();
              }}
              disabled={!isReady || !player || !deviceId || !playbackState}
            >
              <ChevronFirst className='!h-4.5 !w-4.5' />
            </Button>
            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={async (e) => {
                e.stopPropagation();
                if (previousTrack) await previousTrack();
              }}
              disabled={!isReady || !player || !deviceId || !playbackState}
            >
              <SkipBack className='h-5 w-5' />
            </Button>

            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={(e) => {
                e.stopPropagation();
                if (player) {
                  player.togglePlay().catch((e) => console.error('Error toggling play', e));
                }
              }}
              disabled={!isReady || !player || !deviceId || !playbackState}
            >
              {playbackState?.paused ? <Play className='h-5 w-5' /> : <Pause className='h-5 w-5' />}
            </Button>

            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={async (e) => {
                e.stopPropagation();
                if (nextTrack) await nextTrack();
              }}
              disabled={!isReady || !player || !deviceId || !playbackState}
            >
              <SkipForward className='h-5 w-5' />
            </Button>
            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={async (e) => {
                e.stopPropagation();
                if (nextPlaylist) await nextPlaylist();
              }}
              disabled={!isReady || !player || !deviceId || !playbackState}
            >
              <ChevronLast className='!h-4.5 !w-4.5' />
            </Button>
          </div>
          <Button
            variant='ghost'
            size='sm'
            className='h-8 w-8'
            onClick={async (e) => {
              e.stopPropagation();
              if (isCurrentTrackSaved === false) {
                await saveCurrentTrack?.();
              } else if (isCurrentTrackSaved === true) {
                await unsaveCurrentTrack?.();
              }
            }}
            disabled={!isReady || !player || !currentTrack || isCurrentTrackSaved === null}
          >
            {isCurrentTrackSaved ? (
              <RiCheckboxCircleFill className='!h-5 !w-5' />
            ) : (
              <RiAddCircleFill className='!h-5 !w-5' />
            )}
          </Button>
        </div>

        {/* <div className='flex justify-between items-center'>
          <div className='flex gap-1'>
            <Button
              variant='ghost'
              size='sm'
              className='h-8 w-8 hover:bg-accent'
              onClick={async (e) => {
                e.stopPropagation();
                if (isCurrentPlaylistFollowed === false) {
                  await followCurrentPlaylist?.();
                } else if (isCurrentPlaylistFollowed === true) {
                  await unfollowCurrentPlaylist?.();
                }
              }}
              disabled={
                !isReady || !player || !currentPlaylistName || isCurrentPlaylistFollowed === null
              }
            >
              <ListMinus className='h-4 w-4' />
            </Button>

          </div>
        </div> */}
      </div>
    </PopoverContent>
  );
};

export default PlayerUI;
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        ringAround:
          'relative flex h-8 w-8 items-center justify-center rounded-full transition-all duration-300 ease-in-out hover:ring-2 hover:ring-primary hover:ring-offset-2 data-[state=open]:ring-2 data-[state=open]:ring-accent data-[state=open]:ring-offset-background',
        default: 'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary: 'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="hooks/use-current-user-image.ts">
import { createClient } from '@/lib/supabase/client'
import { useEffect, useState } from 'react'

export const useCurrentUserImage = () => {
  const [image, setImage] = useState<string | null>(null)


  console.log('image', image);

  useEffect(() => {
    const fetchUserImage = async () => {
      try {
        const { data, error } = await createClient().auth.getUser();
        console.log('data', data.user?.user_metadata);
        if (error) {
          if (error.name !== 'AuthSessionMissingError') {
            console.error(error);
          }
          setImage(null);
          return;
        }
        setImage(data.user?.user_metadata.avatar_url ?? null);
      } catch (err: unknown) {
        if (
          typeof err === 'object' &&
          err !== null &&
          'name' in err &&
          (err as { name: string }).name === 'AuthSessionMissingError'
        ) {
          setImage(null);
        } else {
          console.error(err);
          setImage(null);
        }
      }
    };
    fetchUserImage();
  }, []);

  return image
}
</file>

<file path="jest.config.js">
/** @type {import('jest').Config} */
module.exports = {
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.(ts|tsx)$': [
      '@swc/jest',
      {
        jsc: {
          parser: {
            syntax: 'typescript',
            tsx: true,
          },
          transform: {
            react: {
              runtime: 'automatic',
            },
          },
          // target: 'es2017', // Optional: ensure SWC's JS output target matches TS
        },
        module: {
          type: 'commonjs',
          strictMode: false,
          noInterop: false,
        },
      },
    ],
    // If you have .js/.jsx files that need transpilation (e.g. from node_modules or plain JS components)
    // you might need babel-jest for them if SWC isn't configured for it or they use Babel-specific features.
    // If your project is pure TypeScript for source files, you might not need this.
    // '^.+\\.(js|jsx)$': 'babel-jest',
  },
  moduleNameMapper: {
    // Handle module aliases (if you have them in tsconfig.json)
    '^@/(.*)$': '<rootDir>/$1',
  },
  // Add any other Jest options you need below
  // For example, setupFilesAfterEnv for test setup
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
};
</file>

<file path="lib/supabase/middleware.ts">
import { createServerClient } from '@supabase/ssr';
import { type NextRequest, NextResponse } from 'next/server';

export const updateSession = async (request: NextRequest) => {
  // This `try/catch` block is only here for the interactive tutorial.
  // Feel free to remove once you have Supabase connected.
  try {
    // Create an unmodified response
    let response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value));
            response = NextResponse.next({
              request,
            });
            cookiesToSet.forEach(({ name, value, options }) =>
              response.cookies.set(name, value, options)
            );
          },
        },
      }
    );

    // This will refresh session if expired - required for Server Components
    // https://supabase.com/docs/guides/auth/server-side/nextjs
    const user = await supabase.auth.getUser();

    // protected routes
    if (
      (request.nextUrl.pathname.startsWith('/profile') ||
        request.nextUrl.pathname.startsWith('/chat')) &&
      user.error
    ) {
      return NextResponse.redirect(new URL('/auth/login', request.url));
    }

    // if (request.nextUrl.pathname === "/" && !user.error) {
    //   return NextResponse.redirect(new URL("/chat", request.url));
    // }

    return response;
  } catch (e) {
    console.error(e);
    // If you are here, a Supabase client could not be created!
    // This is likely because you have not set up environment variables.
    // Check out http://localhost:3000 for Next Steps.
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
};
</file>

<file path="music-context/music-context.tsx">
'use client';

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
  useCallback,
  useRef,
} from 'react';
import { Playlist } from '../types/spotify';
import { MusicContextState } from '../types/music-context';
import { toast } from 'sonner';

// NEW IMPORTS for services
import { initializeUserSession, subscribeToUserSession, UserSessionState } from './user-session';
import {
  checkIfTrackIsSavedAPI,
  saveTrackAPI,
  unsaveTrackAPI,
  checkIfPlaylistIsFollowedAPI,
  followPlaylistAPI,
  unfollowPlaylistAPI,
  playPlaylistWithCustomShuffleAPI,
} from './spotify-api';

// Import the NEW Server Action
import { getMatchedPlaylistsForUserAction } from './playlist-actions';

// Add token manager imports
import {
  initializeTokenManager,
  getSpotifyToken,
  isAuthenticated,
  getUserId,
  ensureTokenManagerInitialized,
} from './token-manager';

// Define the initial state
const initialState: MusicContextState = {
  player: null,
  deviceId: null,
  isReady: false,
  playbackState: null,
  currentVolumePercent: 50,
  error: null,
  userSpotifyId: null,
  tasteMatchedPlaylists: [],
  currentPlaylistIndex: null,
  currentPlaylistName: null,
  isCurrentTrackSaved: null,
  isCurrentPlaylistFollowed: null,
  trackPositionMs: null,
  trackDurationMs: null,
  seek: async () => Promise.reject(new Error('Seek not available.')),
  nextTrack: async () => console.warn('Next track not available.'),
  previousTrack: async () => console.warn('Previous track not available.'),
  setVolume: async () => console.warn('Set volume not available.'),
  toggleMute: async () => console.warn('Toggle mute not available.'),
  playPlaylist: async () => console.warn('Play playlist not available.'),
  nextPlaylist: async () => console.warn('Next playlist not available.'),
  previousPlaylist: async () => console.warn('Previous playlist not available.'),
  playPlaylistWithCustomShuffle: async () =>
    console.warn('Play with custom shuffle not available.'),
  checkIfTrackIsSaved: async () => console.warn('Check track saved not available.'),
  saveCurrentTrack: async () => console.warn('Save track not available.'),
  unsaveCurrentTrack: async () => console.warn('Unsave track not available.'),
  checkIfPlaylistIsFollowed: async () => console.warn('Check playlist followed not available.'),
  followCurrentPlaylist: async () => console.warn('Follow playlist not available.'),
  unfollowCurrentPlaylist: async () => console.warn('Unfollow playlist not available.'),
};

const MusicContext = createContext<MusicContextState>(initialState);

interface MusicProviderProps {
  children: ReactNode;
  isDisabled?: boolean;
}

export const MusicProvider: React.FC<MusicProviderProps> = ({ children, isDisabled }) => {
  const [player, setPlayer] = useState<Spotify.Player | null>(null);
  const [deviceId, setDeviceId] = useState<string | null>(null);
  const [isReady, setIsReady] = useState<boolean>(false);
  const [playbackState, setPlaybackState] = useState<Spotify.PlaybackState | null>(null);
  const [currentVolumePercent, setCurrentVolumePercent] = useState<number | null>(50);
  const [error, setError] = useState<string | null>(null);
  const playerRef = useRef<Spotify.Player | null>(null);
  const [sdkReady, setSdkReady] = useState(false);
  const [preMuteVolume, setPreMuteVolume] = useState<number>(0.5);
  const [isTokenManagerReady, setIsTokenManagerReady] = useState(false);

  const [tasteMatchedPlaylists, setTasteMatchedPlaylists] = useState<Playlist[]>([]);
  const [currentPlaylistIndex, setCurrentPlaylistIndex] = useState<number | null>(null);
  const [currentPlaylistName, setCurrentPlaylistName] = useState<string | null>(null);

  const [isCurrentTrackSaved, setIsCurrentTrackSaved] = useState<boolean | null>(null);
  const [isCurrentPlaylistFollowed, setIsCurrentPlaylistFollowed] = useState<boolean | null>(null);

  const [userSession, setUserSession] = useState<UserSessionState>({
    userSpotifyId: null,
    userId: null,
    isLoading: !isDisabled,
    error: null,
  });

  const initialPlaylistAutoPlayedRef = useRef(false);
  const [trackPositionMs, setTrackPositionMs] = useState<number | null>(null);
  const [trackDurationMs, setTrackDurationMs] = useState<number | null>(null);
  const lastProcessedTrackIdRef = useRef<string | null>(null);
  const trackProgressionIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const debouncedTrackCheckRef = useRef<NodeJS.Timeout | null>(null);
  const debouncedPlaylistCheckRef = useRef<NodeJS.Timeout | null>(null);
  const DEBOUNCE_DELAY_MS = 1000;
  const isSeekingRef = useRef(false);
  const seekTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const fetchAndSetTasteMatchedPlaylists = useCallback(async () => {
    if (isDisabled || !isTokenManagerReady) return;
    const userId = getUserId();
    if (!userId) {
      console.log(
        '[MusicContext] User ID not available from token manager. Skipping playlist fetch.'
      );
      setTasteMatchedPlaylists([]); // Ensure playlists are cleared if no user
      setCurrentPlaylistIndex(null);
      return;
    }
    try {
      const playlists = await getMatchedPlaylistsForUserAction(userId);
      setTasteMatchedPlaylists(playlists);
      setCurrentPlaylistIndex(null);
      initialPlaylistAutoPlayedRef.current = false;
      if (playlists.length === 0) {
        toast.info("Couldn't find any pre-matched playlists for you right now.");
      }
    } catch (err) {
      console.error('[MusicContext] Error fetching matched playlists:', err);
      setError(err instanceof Error ? err.message : 'Failed to load matched playlists.');
      toast.error('Failed to load your matched playlists.');
      setTasteMatchedPlaylists([]);
      setCurrentPlaylistIndex(null);
      initialPlaylistAutoPlayedRef.current = false;
    }
  }, [isDisabled, isTokenManagerReady]);

  // Player Control Callbacks
  const nextTrack = useCallback(async () => {
    if (isDisabled || !playerRef.current || !isReady) {
      setError('Player not ready for next track.');
      return;
    }
    try {
      await playerRef.current.nextTrack();
      setError(null);
    } catch (e) {
      console.error('Error nextTrack:', e);
      setError('Error skipping track.');
    }
  }, [isDisabled, isReady]);

  const previousTrack = useCallback(async () => {
    if (isDisabled || !playerRef.current || !isReady) {
      setError('Player not ready for previous track.');
      return;
    }
    try {
      await playerRef.current.previousTrack();
      setError(null);
    } catch (e) {
      console.error('Error previousTrack:', e);
      setError('Error skipping track.');
    }
  }, [isDisabled, isReady]);

  const setVolume = useCallback(
    async (volume: number) => {
      if (isDisabled || !playerRef.current || !isReady) {
        setError('Player not ready to set volume.');
        return;
      }
      const clampedVolume = Math.max(0, Math.min(1, volume));
      try {
        await playerRef.current.setVolume(clampedVolume);
        setCurrentVolumePercent(Math.round(clampedVolume * 100));
        if (clampedVolume > 0) setPreMuteVolume(clampedVolume);
        setError(null);
      } catch (e) {
        console.error('Error setVolume:', e);
        setError('Error setting volume.');
      }
    },
    [isDisabled, isReady]
  );

  const toggleMute = useCallback(async () => {
    if (isDisabled || !playerRef.current || !isReady) {
      setError('Player not ready to toggle mute.');
      return;
    }
    try {
      const currentVolumeVal = await playerRef.current.getVolume();
      if (currentVolumeVal > 0) {
        setPreMuteVolume(currentVolumeVal);
        await playerRef.current.setVolume(0);
        setCurrentVolumePercent(0);
      } else {
        const volumeToRestore = preMuteVolume > 0 ? preMuteVolume : 0.5;
        await playerRef.current.setVolume(volumeToRestore);
        setCurrentVolumePercent(Math.round(volumeToRestore * 100));
      }
      setError(null);
    } catch (e) {
      console.error('Error toggleMute:', e);
      setError('Error toggling mute.');
    }
  }, [isDisabled, isReady, preMuteVolume]);

  const playPlaylistWithCustomShuffle = useCallback(
    async (playlist: Playlist) => {
      if (isDisabled || !isReady || !deviceId || !isTokenManagerReady) {
        const msg = 'Cannot play with custom shuffle: Player/auth not ready or device missing.';
        setError(msg);
        toast.error(msg);
        console.warn(
          `[MusicContext] ${msg} Conditions: isDisabled=${isDisabled}, isReady=${isReady}, deviceId=${deviceId}, isTokenManagerReady=${isTokenManagerReady}`
        );
        return;
      }
      const token = await getSpotifyToken();
      if (!token) {
        const msg = 'Cannot play with custom shuffle: Token not available.';
        setError(msg);
        toast.error(msg);
        console.warn(`[MusicContext] ${msg}`);
        return;
      }

      if (!playlist || !playlist.spotify_id) {
        const msg = 'Cannot play with custom shuffle: Invalid playlist data provided.';
        setError(msg);
        toast.error(msg);
        console.warn(`[MusicContext] ${msg}`, playlist);
        return;
      }

      toast.info(`Playing from playlist: ${playlist.name}`);
      try {
        await playPlaylistWithCustomShuffleAPI(token, deviceId, playlist.spotify_id);

        const playlistIndexInMatched = tasteMatchedPlaylists.findIndex(
          (p) => p.spotify_id === playlist.spotify_id
        );
        setCurrentPlaylistIndex(playlistIndexInMatched !== -1 ? playlistIndexInMatched : null);
        setCurrentPlaylistName(playlist.name);

        setError(null);
        // console.log(
        //   `[MusicContext] Successfully initiated custom shuffle for playlist "${playlist.name}" (ID: ${playlist.spotify_id})`
        // );
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'An unknown error occurred.';
        console.error(
          `[MusicContext] Error playing playlist with custom shuffle (ID: ${playlist.spotify_id}):`,
          e
        );
        setError(`Failed to play playlist "${playlist.name}": ${errorMsg}`);

        if (errorMsg.toLowerCase().includes('no playable tracks found')) {
          toast.error(`Could not play playlist "${playlist.name}": No playable tracks were found.`);
        } else {
          toast.error(`Failed to play playlist "${playlist.name}": ${errorMsg.substring(0, 100)}`);
        }
      }
    },
    [
      isDisabled,
      isReady,
      deviceId,
      isTokenManagerReady,
      setCurrentPlaylistIndex,
      setCurrentPlaylistName,
      tasteMatchedPlaylists,
    ]
  );

  const playPlaylist = useCallback(
    async (playlist: Playlist) => {
      await playPlaylistWithCustomShuffle(playlist);
    },
    [playPlaylistWithCustomShuffle]
  );

  const nextPlaylist = useCallback(async () => {
    if (isDisabled || !tasteMatchedPlaylists || tasteMatchedPlaylists.length < 1) {
      setError('No playlists available.');
      return;
    }
    const currentIndex = currentPlaylistIndex === null ? -1 : currentPlaylistIndex;
    const nextIndex = (currentIndex + 1) % tasteMatchedPlaylists.length;
    const nextList = tasteMatchedPlaylists[nextIndex];
    if (nextList) await playPlaylist(nextList);
    else setError('Error finding next playlist.');
  }, [isDisabled, tasteMatchedPlaylists, currentPlaylistIndex, playPlaylist]);

  const previousPlaylist = useCallback(async () => {
    if (isDisabled || !tasteMatchedPlaylists || tasteMatchedPlaylists.length < 1) {
      setError('No playlists available.');
      return;
    }
    const currentIndex = currentPlaylistIndex === null ? 0 : currentPlaylistIndex;
    const prevIndex =
      (currentIndex - 1 + tasteMatchedPlaylists.length) % tasteMatchedPlaylists.length;
    const prevList = tasteMatchedPlaylists[prevIndex];
    if (prevList) await playPlaylist(prevList);
    else setError('Error finding previous playlist.');
  }, [isDisabled, tasteMatchedPlaylists, currentPlaylistIndex, playPlaylist]);

  // Save/Follow Check/Action Methods
  const checkIfTrackIsSaved = useCallback(
    async (trackId: string) => {
      if (isDisabled || !isTokenManagerReady) {
        setIsCurrentTrackSaved(null);
        return;
      }
      const token = await getSpotifyToken();
      if (!token || !trackId) {
        setIsCurrentTrackSaved(null);
        return;
      }
      try {
        const isSaved = await checkIfTrackIsSavedAPI(token, trackId);
        setIsCurrentTrackSaved(isSaved);
      } catch (err) {
        console.error('[MusicContext] Error in checkIfTrackIsSaved:', err);
        setIsCurrentTrackSaved(null);
      }
    },
    [isDisabled, isTokenManagerReady]
  );

  const saveCurrentTrack = useCallback(async () => {
    if (isDisabled || !isTokenManagerReady) {
      setError('Cannot save track: Auth not ready or provider disabled.');
      return;
    }
    const token = await getSpotifyToken();
    const currentTrackId = playbackState?.track_window?.current_track?.id;
    if (!token || !currentTrackId) {
      setError('No track playing or token unavailable to save.');
      return;
    }
    try {
      setError(null);
      await saveTrackAPI(token, currentTrackId);
      setIsCurrentTrackSaved(true);
      toast.success('Track saved to your Liked Songs!');
    } catch (err) {
      console.error('[MusicContext] Error saving track:', err);
      const errorMsg = 'Failed to save track. Please try again.';
      setError(errorMsg);
      toast.error(errorMsg);
      setIsCurrentTrackSaved(false);
    }
  }, [isDisabled, playbackState, isTokenManagerReady]);

  const unsaveCurrentTrack = useCallback(async () => {
    if (isDisabled || !isTokenManagerReady) {
      setError('Cannot unsave track: Auth not ready or provider disabled.');
      return;
    }
    const token = await getSpotifyToken();
    const currentTrackId = playbackState?.track_window?.current_track?.id;
    if (!token || !currentTrackId) {
      setError('No track playing or token unavailable to unsave.');
      return;
    }
    try {
      setError(null);
      await unsaveTrackAPI(token, currentTrackId);
      setIsCurrentTrackSaved(false);
      toast.success('Track removed from your Liked Songs.');
    } catch (err) {
      console.error('[MusicContext] Error unsaving track:', err);
      const errorMsg = 'Failed to unsave track. Please try again.';
      setError(errorMsg);
      toast.error(errorMsg);
      setIsCurrentTrackSaved(true);
    }
  }, [isDisabled, playbackState, isTokenManagerReady]);

  const checkIfPlaylistIsFollowed = useCallback(
    async (playlistId: string) => {
      if (isDisabled || !isTokenManagerReady) {
        setIsCurrentPlaylistFollowed(null);
        return;
      }
      const token = await getSpotifyToken();
      if (!token || !playlistId) {
        setIsCurrentPlaylistFollowed(null);
        return;
      }
      try {
        const isFollowed = await checkIfPlaylistIsFollowedAPI(token, playlistId);
        setIsCurrentPlaylistFollowed(isFollowed);
      } catch (err) {
        console.error('[MusicContext] Error in checkIfPlaylistIsFollowed:', err);
        setIsCurrentPlaylistFollowed(null);
      }
    },
    [isDisabled, isTokenManagerReady]
  );

  const followCurrentPlaylist = useCallback(async () => {
    if (isDisabled || !playbackState?.context?.uri || !isTokenManagerReady) {
      setError(
        'Cannot follow playlist: No playlist playing, auth not ready, or provider disabled.'
      );
      return;
    }
    const token = await getSpotifyToken();
    if (!token) {
      setError('Authentication required to follow playlist.');
      return;
    }
    const currentPlaylistId = playbackState.context.uri.split(':')[2];
    try {
      setError(null);
      await followPlaylistAPI(token, currentPlaylistId);
      setIsCurrentPlaylistFollowed(true);
      toast.success('Playlist followed!');
    } catch (err) {
      console.error('[MusicContext] Error following playlist:', err);
      const errorMsg = 'Failed to follow playlist. Please try again.';
      setError(errorMsg);
      toast.error(errorMsg);
      setIsCurrentPlaylistFollowed(false);
    }
  }, [isDisabled, playbackState, isTokenManagerReady]);

  const unfollowCurrentPlaylist = useCallback(async () => {
    if (isDisabled || !playbackState?.context?.uri || !isTokenManagerReady) {
      setError(
        'Cannot unfollow playlist: No playlist playing, auth not ready, or provider disabled.'
      );
      return;
    }
    const token = await getSpotifyToken();
    if (!token) {
      setError('Authentication required to unfollow playlist.');
      return;
    }
    const currentPlaylistId = playbackState.context.uri.split(':')[2];
    try {
      setError(null);
      await unfollowPlaylistAPI(token, currentPlaylistId);
      setIsCurrentPlaylistFollowed(false);
      toast.success('Playlist unfollowed.');
    } catch (err) {
      console.error('[MusicContext] Error unfollowing playlist:', err);
      const errorMsg = 'Failed to unfollow playlist. Please try again.';
      setError(errorMsg);
      toast.error(errorMsg);
      setIsCurrentPlaylistFollowed(true);
    }
  }, [isDisabled, playbackState, isTokenManagerReady]);

  // Timeline & Seek Functions
  const seek = useCallback(
    async (positionMs: number) => {
      if (isDisabled || !playerRef.current || !isReady) {
        const msg = 'Seek failed: Player not ready or provider disabled.';
        setError(msg);
        toast.error(msg);
        throw new Error(msg);
      }
      if (!playbackState || !trackDurationMs) {
        const msg = 'Seek failed: No track loaded or duration unknown.';
        setError(msg);
        toast.error(msg);
        throw new Error(msg);
      }
      if (isSeekingRef.current) {
        return;
      }
      isSeekingRef.current = true;
      const newPosition = Math.max(0, Math.min(positionMs, trackDurationMs));
      setTrackPositionMs(newPosition);
      try {
        await playerRef.current.seek(newPosition);
      } catch (e: unknown) {
        const errMsg = e instanceof Error ? e.message : 'Unknown Spotify SDK error';
        const msg = `Seek failed: ${errMsg}`;
        setError(msg);
        toast.error(msg);
        throw new Error(msg);
      } finally {
        if (seekTimeoutRef.current) clearTimeout(seekTimeoutRef.current);
        seekTimeoutRef.current = setTimeout(() => {
          isSeekingRef.current = false;
        }, 200);
      }
    },
    [isDisabled, isReady, playbackState, trackDurationMs, setError]
  );

  // PlayerInitEffect
  useEffect(() => {
    if (isDisabled || !sdkReady || !isTokenManagerReady) {
      if (playerRef.current) {
        if (typeof playerRef.current.disconnect === 'function') playerRef.current.disconnect();
        setPlayer(null);
        playerRef.current = null;
        setIsReady(false);
        setDeviceId(null);
        setPlaybackState(null);
      }
      return;
    }
    if (playerRef.current) return;

    const getOAuthTokenCallback: Spotify.PlayerInit['getOAuthToken'] = async (cb) => {
      if (isDisabled) {
        cb('');
        return;
      }
      const token = await getSpotifyToken();
      cb(token || '');
    };

    // const effectRunId = Date.now();
    // console.log(`[MusicContext PlayerInitEffect ${effectRunId}] Initializing new player.`);

    const newPlayer = new window.Spotify.Player({
      name: 'Playlist Chat Rooms Player',
      getOAuthToken: getOAuthTokenCallback,
      volume: currentVolumePercent !== null ? currentVolumePercent / 100 : 0.5,
    });

    newPlayer.addListener('ready', async ({ device_id }) => {
      if (playerRef.current !== null && playerRef.current !== newPlayer) {
        if (typeof newPlayer.disconnect === 'function') newPlayer.disconnect();
        return;
      }
      setDeviceId(device_id);
      setIsReady(true);
      setError(null);
      try {
        const vol = await newPlayer.getVolume();
        setCurrentVolumePercent(Math.round(vol * 100));
        setPreMuteVolume(vol);
      } catch (e) {
        console.error('Error getting vol on ready:', e);
      }
      newPlayer.getCurrentState().then(setPlaybackState);
    });

    newPlayer.addListener('not_ready', ({ device_id }) => {
      if (playerRef.current !== null && playerRef.current !== newPlayer) return;
      console.log('[MusicContext] Device ID has gone offline:', device_id);
      setIsReady(false);
      setDeviceId(null);
      lastProcessedTrackIdRef.current = null;
    });

    newPlayer.addListener('player_state_changed', async (sdkState) => {
      if (playerRef.current !== newPlayer) return;
      if (sdkState) {
        setTrackPositionMs(sdkState.position);
        setTrackDurationMs(sdkState.duration);
      } else {
        setTrackPositionMs(null);
        setTrackDurationMs(null);
      }
      if (!sdkState) {
        setPlaybackState(null);
        lastProcessedTrackIdRef.current = null;
        return;
      }
      const currentSdkTrack = sdkState.track_window.current_track;
      const currentSdkTrackId = currentSdkTrack?.id;
      setPlaybackState(sdkState);

      if (currentSdkTrackId && lastProcessedTrackIdRef.current !== currentSdkTrackId) {
        lastProcessedTrackIdRef.current = currentSdkTrackId;
      }
      if (!currentSdkTrackId) {
        lastProcessedTrackIdRef.current = null;
      }

      const shouldCheckSaved = currentSdkTrackId && !sdkState.paused;
      if (shouldCheckSaved) checkIfTrackIsSaved(currentSdkTrackId);
      if (sdkState.context?.uri !== playbackState?.context?.uri) {
        if (sdkState.context?.uri?.startsWith('spotify:playlist:'))
          checkIfPlaylistIsFollowed(sdkState.context.uri.split(':')[2]);
        else setIsCurrentPlaylistFollowed(null);
      }
    });

    newPlayer.addListener('initialization_error', ({ message }) => {
      setError(`Init Error: ${message}`);
      setIsReady(false);
    });
    newPlayer.addListener('authentication_error', ({ message }) => {
      console.error('[MusicContext] Authentication Error:', message);
      setError(`Spotify authentication error: ${message}. Please try signing out and in again.`);
      if (playerRef.current) playerRef.current.disconnect();
      setPlayer(null);
      playerRef.current = null;
      setIsReady(false);
      setPlaybackState(null);
      setDeviceId(null);
    });
    newPlayer.addListener('account_error', ({ message }) => {
      setError(`Account Error: ${message}`);
      toast.error(`Spotify account error: ${message}`);
    });
    newPlayer.addListener('playback_error', ({ message }) => {
      setError(`Playback Error: ${message}`);
      toast.error(`Spotify playback error: ${message}`);
      console.log(`[MusicContext Playback Error] UserID: ${getUserId()}`);
    });

    newPlayer
      .connect()
      .catch((err) =>
        setError(`Connect Error: ${err instanceof Error ? err.message : String(err)}`)
      );
    setPlayer(newPlayer);
    playerRef.current = newPlayer;
    newPlayer.getCurrentState().then((pState) => {
      if (pState)
        newPlayer.getVolume().then((vol) => {
          setCurrentVolumePercent(Math.round(vol * 100));
          setPreMuteVolume(vol);
        });
    });

    return () => {
      if (playerRef.current) {
        if (typeof playerRef.current.disconnect === 'function') playerRef.current.disconnect();
      }
      setPlayer(null);
      playerRef.current = null;
      setIsReady(false);
      setDeviceId(null);
      setPlaybackState(null);
    };
  }, [isDisabled, sdkReady, isTokenManagerReady]);

  // SDK Ready Effect
  useEffect(() => {
    if (isDisabled) return;
    window.onSpotifyWebPlaybackSDKReady = () => setSdkReady(true);
    return () => {
      if (!isDisabled) window.onSpotifyWebPlaybackSDKReady = () => {};
    };
  }, [isDisabled]);

  // Track Progression Interval Effect
  useEffect(() => {
    if (playbackState && !playbackState.paused && playerRef.current) {
      if (trackProgressionIntervalRef.current) clearInterval(trackProgressionIntervalRef.current);
      trackProgressionIntervalRef.current = setInterval(async () => {
        if (playerRef.current) {
          try {
            const cState = await playerRef.current.getCurrentState();
            if (cState) setTrackPositionMs(cState.position);
            else {
              if (trackProgressionIntervalRef.current)
                clearInterval(trackProgressionIntervalRef.current);
              trackProgressionIntervalRef.current = null;
              setTrackPositionMs(null);
            }
          } catch (e) {
            console.error('[MusicContext] Error getting current state in interval:', e);
            if (trackProgressionIntervalRef.current)
              clearInterval(trackProgressionIntervalRef.current);
            trackProgressionIntervalRef.current = null;
            setError('Failed to sync track position.');
          }
        }
      }, 500);
    } else {
      if (trackProgressionIntervalRef.current) clearInterval(trackProgressionIntervalRef.current);
      trackProgressionIntervalRef.current = null;
    }
    return () => {
      if (trackProgressionIntervalRef.current) clearInterval(trackProgressionIntervalRef.current);
    };
  }, [playbackState]);

  // Fetch Taste-Matched Playlists Effect
  useEffect(() => {
    if (isDisabled || !isReady || !deviceId || !isTokenManagerReady || !isAuthenticated()) return;
    fetchAndSetTasteMatchedPlaylists().catch((err) =>
      console.error('Error fetching playlists:', err)
    );
  }, [isDisabled, isReady, deviceId, isTokenManagerReady, fetchAndSetTasteMatchedPlaylists]);

  // Auto-Play First Playlist Effect
  useEffect(() => {
    if (
      isDisabled ||
      !isReady ||
      !deviceId ||
      !isTokenManagerReady ||
      tasteMatchedPlaylists.length === 0 ||
      currentPlaylistIndex !== null ||
      initialPlaylistAutoPlayedRef.current ||
      typeof playPlaylist !== 'function' ||
      !isAuthenticated()
    )
      return;
    playPlaylist(tasteMatchedPlaylists[0])
      .then(() => {
        initialPlaylistAutoPlayedRef.current = true;
      })
      .catch((err) => {
        console.error('Error auto-playing:', err);
        initialPlaylistAutoPlayedRef.current = true;
      });
  }, [
    isDisabled,
    isReady,
    deviceId,
    isTokenManagerReady,
    tasteMatchedPlaylists,
    currentPlaylistIndex,
    playPlaylist,
  ]);

  // Debounced Save/Follow Checks Effect
  useEffect(() => {
    if (isDisabled || !isTokenManagerReady) {
      if (debouncedTrackCheckRef.current) clearTimeout(debouncedTrackCheckRef.current);
      if (debouncedPlaylistCheckRef.current) clearTimeout(debouncedPlaylistCheckRef.current);
      setIsCurrentTrackSaved(null);
      setIsCurrentPlaylistFollowed(null);
      return;
    }
    const trackId = playbackState?.track_window?.current_track?.id;
    const playlistCtxUri = playbackState?.context?.uri;
    const playlistId = playlistCtxUri?.startsWith('spotify:playlist:')
      ? playlistCtxUri.split(':')[2]
      : null;

    if (debouncedTrackCheckRef.current) clearTimeout(debouncedTrackCheckRef.current);
    if (trackId) {
      debouncedTrackCheckRef.current = setTimeout(
        () => checkIfTrackIsSaved(trackId).catch(console.error),
        DEBOUNCE_DELAY_MS
      );
    } else {
      setIsCurrentTrackSaved(null);
    }
    if (debouncedPlaylistCheckRef.current) clearTimeout(debouncedPlaylistCheckRef.current);
    if (playlistId) {
      debouncedPlaylistCheckRef.current = setTimeout(
        () => checkIfPlaylistIsFollowed(playlistId).catch(console.error),
        DEBOUNCE_DELAY_MS
      );
    } else {
      setIsCurrentPlaylistFollowed(null);
    }
    return () => {
      if (debouncedTrackCheckRef.current) clearTimeout(debouncedTrackCheckRef.current);
      if (debouncedPlaylistCheckRef.current) clearTimeout(debouncedPlaylistCheckRef.current);
    };
  }, [
    playbackState,
    checkIfTrackIsSaved,
    checkIfPlaylistIsFollowed,
    isDisabled,
    isTokenManagerReady,
    DEBOUNCE_DELAY_MS,
  ]);

  // Main Initialization Effect (Token Manager and User Session)
  useEffect(() => {
    let userSessionCleanup: (() => void) | null = null;

    if (isDisabled) {
      setIsTokenManagerReady(false);
      setUserSession({ userSpotifyId: null, userId: null, isLoading: false, error: null });
      if (playerRef.current) {
        if (typeof playerRef.current.disconnect === 'function') playerRef.current.disconnect();
        setPlayer(null);
        playerRef.current = null;
      }
      setIsReady(false);
      setPlaybackState(null);
      setDeviceId(null);
      setCurrentVolumePercent(50);
      setTasteMatchedPlaylists([]);
      setCurrentPlaylistIndex(null);
      setCurrentPlaylistName(null);
      setIsCurrentTrackSaved(null);
      setIsCurrentPlaylistFollowed(null);
      initialPlaylistAutoPlayedRef.current = false;
      lastProcessedTrackIdRef.current = null;
      return;
    }

    initializeTokenManager(); // Idempotent
    ensureTokenManagerInitialized()
      .then(() => {
        setIsTokenManagerReady(true);
        // console.log('[MusicContext] Token manager is initialized.');

        // Initialize user session after token manager is confirmed ready
        const cleanupUserSess = initializeUserSession();
        const unsubscribeUserSess = subscribeToUserSession((newSessionState) => {
          setUserSession((prevState) => {
            if (
              newSessionState.isLoading &&
              newSessionState.userId === null &&
              prevState.userId !== null
            ) {
              return {
                ...newSessionState,
                userId: prevState.userId,
                userSpotifyId: prevState.userSpotifyId,
              };
            }
            return newSessionState;
          });
          const sessionErr = newSessionState.error;
          const expectedErr = sessionErr === 'User session missing.';
          const actualErr = sessionErr && !expectedErr;
          setError((prevErr) => {
            if (actualErr) return prevErr !== sessionErr ? sessionErr : prevErr;
            if (prevErr !== null && (sessionErr === null || expectedErr)) return null;
            return prevErr;
          });
          if (sessionErr === 'User session missing.' && !isAuthenticated()) {
            if (playerRef.current && typeof playerRef.current.disconnect === 'function')
              playerRef.current.disconnect();
            setPlayer(null);
            playerRef.current = null;
            setIsReady(false);
            setPlaybackState(null);
            setDeviceId(null);
            // Reset other states as well
          }
        });
        userSessionCleanup = () => {
          cleanupUserSess();
          unsubscribeUserSess();
        };
      })
      .catch((err) => {
        console.error('[MusicContext] Failed to initialize token manager:', err);
        setError('Music services failed to start.');
        setIsTokenManagerReady(false);
      });

    return () => {
      console.log('[MusicContext] Main init effect cleanup.');
      if (userSessionCleanup) userSessionCleanup();
      setIsTokenManagerReady(false);
    };
  }, [isDisabled]);

  const contextValue: MusicContextState = isDisabled
    ? initialState
    : {
        player,
        deviceId,
        isReady,
        playbackState,
        currentVolumePercent,
        error,
        userSpotifyId: userSession.userSpotifyId,
        tasteMatchedPlaylists,
        currentPlaylistIndex,
        currentPlaylistName,
        isCurrentTrackSaved,
        isCurrentPlaylistFollowed,
        trackPositionMs,
        trackDurationMs,
        seek,
        nextTrack,
        previousTrack,
        setVolume,
        toggleMute,
        playPlaylist,
        nextPlaylist,
        previousPlaylist,
        playPlaylistWithCustomShuffle,
        checkIfTrackIsSaved,
        saveCurrentTrack,
        unsaveCurrentTrack,
        checkIfPlaylistIsFollowed,
        followCurrentPlaylist,
        unfollowCurrentPlaylist,
      };

  return <MusicContext.Provider value={contextValue}>{children}</MusicContext.Provider>;
};

export const useMusic = (): MusicContextState => {
  const context = useContext(MusicContext);
  if (context === undefined) throw new Error('useMusic must be used within a MusicProvider');
  return context;
};
</file>

<file path="music-context/spotify-api.ts">
import { SpotifyApiTrackFull } from '../types/spotify';
import { getSpotifyToken } from './token-manager'; // Import from token-manager instead

// Constants for network retry logic
const MAX_NETWORK_RETRIES = 2; // Retry up to 2 additional times (3 total attempts)
const NETWORK_RETRY_DELAY_MS = 1000; // Delay between retries in milliseconds

/**
 * Shuffles an array in place using the Fisher-Yates algorithm.
 * The original array is modified.
 *
 * @param array The array to shuffle.
 * @returns The same array, shuffled.
 * @template T The type of elements in the array.
 */
export const shuffleArray = <T>(array: T[]): T[] => {
  let currentIndex = array.length;
  let randomIndex: number;

  // While there remain elements to shuffle.
  while (currentIndex !== 0) {
    // Pick a remaining element.
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }

  return array;
};

// Generic Spotify API Call Helper
export const makeSpotifyApiCall = async <T = unknown>(
  token: string,
  endpoint: string,
  method: string = 'GET',
  body?: unknown,
  isRetry: boolean = false // Added to prevent infinite refresh loops
): Promise<T> => {
  if (!token && !isRetry) {
    // Allow retry even if initial token was null, getSpotifyToken will handle it
    // If it's a retry and token is still null, getSpotifyToken would have been called by the first attempt
    // and failed, so we shouldn't proceed further if we are in a retry and no token was obtained.
    console.warn(
      `[Spotify API] No token for ${method} ${endpoint}, attempting to get a valid token.`
    );
    const newToken = await getSpotifyToken();
    if (!newToken) {
      throw new Error('Spotify token not available and refresh failed before API call.');
    }
    // Call self with the new token, marking it as a retry so it doesn't try to refresh again if this also fails.
    return makeSpotifyApiCall(newToken, endpoint, method, body, true);
  }
  if (!token && isRetry) {
    // This means the first attempt (which called getSpotifyToken) failed to get a token.
    throw new Error('Spotify token not available after refresh attempt for API call.');
  }

  const headers: HeadersInit = {
    Authorization: `Bearer ${token}`,
  };
  if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
    headers['Content-Type'] = 'application/json';
  }

  let response!: Response; // Definite assignment assertion, as loop will either assign or throw
  let lastNetworkError: Error | null = null;

  for (let attempt = 0; attempt <= MAX_NETWORK_RETRIES; attempt++) {
    try {
      response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined,
      });
      lastNetworkError = null; // Clear error on successful fetch attempt
      break; // Exit loop if fetch was successful (i.e., did not throw a network error)
    } catch (e) {
      if (e instanceof TypeError && e.message.toLowerCase().includes('failed to fetch')) {
        lastNetworkError = e;
        console.warn(
          `[Spotify API] Network error ("Failed to fetch") on attempt ${attempt + 1} of ${MAX_NETWORK_RETRIES + 1} for ${method} ${endpoint}. Retrying in ${NETWORK_RETRY_DELAY_MS / 1000}s...`
        );
        if (attempt < MAX_NETWORK_RETRIES) {
          await new Promise((resolve) => setTimeout(resolve, NETWORK_RETRY_DELAY_MS));
        } else {
          console.error(
            `[Spotify API] Network error ("Failed to fetch") for ${method} ${endpoint} after ${MAX_NETWORK_RETRIES + 1} attempts. Final error: ${e.message}`
          );
          throw e; // Re-throw the last "Failed to fetch" error after all retries
        }
      } else {
        // Different error type (not "Failed to fetch" TypeError), re-throw immediately
        console.error(`[Spotify API] Non-network error during fetch for ${method} ${endpoint}:`, e);
        throw e;
      }
    }
  }

  if (!response) {
    // This case should ideally not be reached if the loop logic is correct (either assigns response or throws)
    // but serves as a fallback.
    throw (
      lastNetworkError ||
      new Error(
        `[Spotify API] Fetch failed for ${method} ${endpoint} after retries without a valid response object.`
      )
    );
  }

  if (!response.ok) {
    let errorBody = '';
    try {
      errorBody = await response.text(); // Read error body first
    } catch {
      /* ignore if reading body fails */
    }

    if (response.status === 401 && !isRetry) {
      console.warn(
        `[Spotify API] Received 401 for ${method} ${endpoint}. Attempting token refresh and retry.`
      );
      const newToken = await getSpotifyToken(); // This will attempt to call our API endpoint
      if (newToken) {
        console.log(`[Spotify API] Token refreshed successfully. Retrying ${method} ${endpoint}.`);
        return makeSpotifyApiCall(newToken, endpoint, method, body, true); // Pass true for isRetry
      } else {
        console.error(
          `[Spotify API] Token refresh failed after 401. Cannot retry ${method} ${endpoint}.`
        );
        // Throw an error that includes the original 401 and the refresh failure context
        throw new Error(
          `Spotify API Error (401 - Unauthenticated) for ${method} ${endpoint} and subsequent token refresh failed. Original Body: ${errorBody.substring(0, 500)}`
        );
      }
    }
    // For non-401 errors, or for 401s on a retry, throw the original error
    throw new Error(
      `Spotify API Error (${response.status}) for ${method} ${endpoint}: ${response.statusText}. Body: ${errorBody.substring(0, 500)}`
    );
  }

  if (response.status === 204) {
    return null as T;
  }

  const contentType = response.headers.get('Content-Type');
  const contentLengthHeader = response.headers.get('content-length');

  if (contentType && contentType.includes('application/json')) {
    if (contentLengthHeader === '0') {
      console.warn(
        `Spotify API: Endpoint ${endpoint} (status ${response.status}) declared Content-Type: application/json but Content-Length: 0. Treating as empty response.`
      );
      return null as T;
    }
    try {
      return (await response.json()) as T;
    } catch (parseError) {
      const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
      console.error(
        `Spotify API Error: Failed to parse JSON response from ${method} ${endpoint} (status ${response.status}, Content-Type: ${contentType}). Error: ${errorMessage}`
      );
      throw new Error(
        `Spotify API Error: Malformed JSON response from ${method} ${endpoint} (status ${response.status}, Content-Type: ${contentType}). Original error: ${errorMessage}`
      );
    }
  }

  if (contentLengthHeader === '0') {
    return null as T;
  }

  if (method === 'PUT' || method === 'DELETE' || method === 'PATCH') {
    const textBody = await response.text();
    console.warn(
      `Spotify API: Successful ${method} to ${endpoint} (status ${response.status}) ` +
        `returned non-JSON, non-empty content (Content-Type: ${contentType || 'N/A'}, Body: "${textBody.substring(0, 50)}..."). ` +
        `This might be unexpected. For now, treating as success with no parseable body and returning null.`
    );
    return null as T;
  }

  const responseText = await response.text();
  throw new Error(
    `Spotify API Error: Expected JSON response from ${method} ${endpoint} (status ${response.status}), ` +
      `but received Content-Type: ${contentType || 'N/A'}. Response body: ${responseText.substring(0, 200)}`
  );
};

// Fetch a single track with market context
export const fetchSpotifyTrack = async (
  token: string,
  trackId: string
): Promise<SpotifyApiTrackFull | null> => {
  if (!token) {
    console.warn('[fetchSpotifyTrack API] No Spotify token available.');
    return null;
  }
  if (!trackId) {
    console.warn('[fetchSpotifyTrack API] No trackId provided.');
    return null;
  }

  try {
    // The generic type for makeSpotifyApiCall here is unknown by default,
    // but we expect SpotifyApiTrackFull or something compatible.
    const trackData = await makeSpotifyApiCall<SpotifyApiTrackFull>(
      token,
      `/tracks/${trackId}?market=from_token`
    );
    return trackData; // No need to cast if makeSpotifyApiCall is correctly typed for this call
  } catch (err) {
    console.error(`[fetchSpotifyTrack API] Error fetching track ${trackId}:`, err);
    // Re-throw or handle more gracefully, for now, let context handle UI error
    throw err;
  }
};

// Interface for the paginated response from Spotify's get playlist tracks endpoint
interface SpotifyPlaylistTracksPage {
  items: {
    track: SpotifyApiTrackFull | null; // Track can be null if unavailable, e.g. deleted
    // is_local is a property of the track object itself if requested in fields
  }[];
  next: string | null;
  total: number;
  limit: number;
  offset: number;
  // href?: string; // The request URL for this page
  // previous?: string | null; // URL for the previous page
}

/**
 * Fetches all playable tracks from a given Spotify playlist, handling pagination and relinking.
 *
 * @param token Spotify API access token.
 * @param playlistId The ID of the Spotify playlist.
 * @returns A promise that resolves to an array of SpotifyApiTrackFull objects.
 * @throws Throws an error if the playlist ID is not provided or if API calls fail.
 */
export const fetchAllPlayablePlaylistTracksAPI = async (
  token: string,
  playlistId: string
): Promise<SpotifyApiTrackFull[]> => {
  // Token presence is primarily handled by makeSpotifyApiCall, but initial check can be useful.
  // For this function, we assume token is provided, and makeSpotifyApiCall will attempt refresh if needed.
  if (!playlistId) {
    const errMsg = '[fetchAllPlayablePlaylistTracksAPI] Playlist ID is required.';
    console.error(errMsg);
    throw new Error(errMsg);
  }

  const playableTracks: SpotifyApiTrackFull[] = [];
  const limit = 50; // Max limit for this endpoint usually 50, sometimes 100. Let's use 50.

  // DR12.1.1: Ensure all necessary track data (including linked_from, is_playable, is_local, uri, type, restrictions, available_markets) is fetched efficiently.
  // Added artists, album basic details, and duration_ms as they are part of SpotifyApiTrackFull and generally useful.
  // is_local is a field *on the track object*, so it needs to be requested within track().
  const fields =
    'items(track(id,uri,name,type,is_playable,is_local,linked_from(id,type,uri),artists(name,id),album(name,id,images),duration_ms,restrictions,available_markets)),next,total,limit,offset';

  let currentPageUrl: string | null =
    `/playlists/${playlistId}/tracks?limit=${limit}&offset=0&market=from_token&fields=${encodeURIComponent(fields)}`;

  while (currentPageUrl) {
    try {
      // makeSpotifyApiCall expects the endpoint path without the domain, e.g., "/playlists/..."
      const pageData: SpotifyPlaylistTracksPage | null =
        await makeSpotifyApiCall<SpotifyPlaylistTracksPage>(token, currentPageUrl);

      if (!pageData || !pageData.items) {
        console.warn(
          `[fetchAllPlayablePlaylistTracksAPI] Received no items or invalid page data from ${currentPageUrl}. Assuming end of playlist.`
        );
        break;
      }

      for (const item of pageData.items) {
        const track = item.track;

        // DR12.1.1: Skip if track is null, not a track type, or is local
        if (!track) {
          // console.debug('[fetchAllPlayablePlaylistTracksAPI] Skipping null track item.');
          continue;
        }
        if (track.type !== 'track') {
          // console.debug(`[fetchAllPlayablePlaylistTracksAPI] Skipping item of type '${track.type}': ${track.name || track.id}`);
          continue;
        }
        if (track.is_local) {
          // console.debug(`[fetchAllPlayablePlaylistTracksAPI] Skipping local track: ${track.name || track.id}`);
          continue;
        }

        // DR12.1.1: Check playability and relink if necessary
        if (track.is_playable) {
          playableTracks.push(track);
        } else if (track.linked_from?.id && track.linked_from.type === 'track') {
          // console.log(`[fetchAllPlayablePlaylistTracksAPI] Track '${track.name}' (ID: ${track.id}) is not playable, attempting relink from ${track.linked_from.id}`);
          try {
            const relinkedTrack = await fetchSpotifyTrack(token, track.linked_from.id);
            if (
              relinkedTrack &&
              relinkedTrack.is_playable &&
              relinkedTrack.type === 'track' &&
              !relinkedTrack.is_local
            ) {
              // console.log(`[fetchAllPlayablePlaylistTracksAPI] Successfully relinked to playable track '${relinkedTrack.name}' (ID: ${relinkedTrack.id})`);
              playableTracks.push(relinkedTrack);
            } else {
              // console.log(`[fetchAllPlayablePlaylistTracksAPI] Relinked track ${track.linked_from.id} for '${track.name}' is also not playable, is local, or not a track.`);
            }
          } catch (relinkError) {
            console.warn(
              `[fetchAllPlayablePlaylistTracksAPI] Error fetching relinked track ${track.linked_from.id} for '${track.name}':`,
              relinkError instanceof Error ? relinkError.message : relinkError
            );
            // Continue to the next track, don't let a failed relink stop the whole process for other tracks.
          }
        } else {
          // console.debug(`[fetchAllPlayablePlaylistTracksAPI] Track '${track.name}' (ID: ${track.id}) is not playable and has no valid linked_from information.`);
        }
      }

      // Prepare for the next page
      if (pageData.next) {
        const spotifyApiBase = 'https://api.spotify.com/v1';
        if (pageData.next.startsWith(spotifyApiBase)) {
          currentPageUrl = pageData.next.substring(spotifyApiBase.length);
        } else {
          console.warn(
            `[fetchAllPlayablePlaylistTracksAPI] Unexpected 'next' URL format: ${pageData.next}. Ending pagination.`
          );
          currentPageUrl = null;
        }
      } else {
        currentPageUrl = null; // No more pages
      }
    } catch (error) {
      console.error(
        `[fetchAllPlayablePlaylistTracksAPI] Error fetching playlist tracks page for playlist ${playlistId} (URL: ${currentPageUrl}):`,
        error instanceof Error ? error.message : error
      );
      // Re-throw the error to be handled by the calling context, as per error propagation strategy.
      throw error;
    }
  }

  return playableTracks;
};

// --- Save/Follow API Call Methods ---

export const checkIfTrackIsSavedAPI = async (
  token: string,
  trackId: string
): Promise<boolean | null> => {
  if (!token || !trackId) {
    return null;
  }
  try {
    const result = (await makeSpotifyApiCall(
      token,
      `/me/tracks/contains?ids=${trackId}`
    )) as boolean[];
    if (Array.isArray(result) && typeof result[0] === 'boolean') {
      return result[0];
    }
    console.warn('[checkIfTrackIsSavedAPI] Unexpected response format:', result);
    return null;
  } catch (err) {
    console.error('[checkIfTrackIsSavedAPI] Error:', err);
    throw err; // Re-throw for the context to handle UI feedback
  }
};

export const saveTrackAPI = async (token: string, trackId: string): Promise<void> => {
  if (!token || !trackId) {
    throw new Error('Token or Track ID missing for saveTrackAPI');
  }
  try {
    await makeSpotifyApiCall(token, `/me/tracks?ids=${trackId}`, 'PUT');
  } catch (err) {
    console.error('[saveTrackAPI] Error saving track:', err);
    throw err;
  }
};

export const unsaveTrackAPI = async (token: string, trackId: string): Promise<void> => {
  if (!token || !trackId) {
    throw new Error('Token or Track ID missing for unsaveTrackAPI');
  }
  try {
    await makeSpotifyApiCall(token, `/me/tracks?ids=${trackId}`, 'DELETE');
  } catch (err) {
    console.error('[unsaveTrackAPI] Error unsaving track:', err);
    throw err;
  }
};

export const checkIfPlaylistIsFollowedAPI = async (
  token: string,
  playlistId: string
): Promise<boolean | null> => {
  if (!token || !playlistId) {
    console.warn('[Spotify API] Missing token or playlistId for checkIfPlaylistIsFollowedAPI');
    return null;
  }
  try {
    const result = (await makeSpotifyApiCall(
      token,
      `/playlists/${playlistId}/followers/contains`
    )) as boolean[];
    if (Array.isArray(result) && result.length > 0 && typeof result[0] === 'boolean') {
      return result[0];
    }
    console.warn(
      '[checkIfPlaylistIsFollowedAPI] Unexpected response format or empty array:',
      result
    );
    return null;
  } catch (err) {
    console.error('[checkIfPlaylistIsFollowedAPI] Error:', err);
    throw err;
  }
};

export const followPlaylistAPI = async (token: string, playlistId: string): Promise<void> => {
  if (!token || !playlistId) {
    throw new Error('Token or Playlist ID missing for followPlaylistAPI');
  }
  try {
    await makeSpotifyApiCall(token, `/playlists/${playlistId}/followers`, 'PUT');
  } catch (err) {
    console.error('[followPlaylistAPI] Error following playlist:', err);
    throw err;
  }
};

export const unfollowPlaylistAPI = async (token: string, playlistId: string): Promise<void> => {
  if (!token || !playlistId) {
    throw new Error('Token or Playlist ID missing for unfollowPlaylistAPI');
  }
  try {
    await makeSpotifyApiCall(token, `/playlists/${playlistId}/followers`, 'DELETE');
  } catch (err) {
    console.error('[unfollowPlaylistAPI] Error unfollowing playlist:', err);
    throw err;
  }
};

/**
 * Plays a Spotify playlist with a custom shuffle order.
 * Fetches all playable tracks, shuffles them, turns off Spotify's native shuffle,
 * and then starts playback of the custom queue.
 *
 * @param token Spotify API access token.
 * @param deviceId The ID of the device to play on.
 * @param playlistId The ID of the Spotify playlist.
 * @returns A promise that resolves when playback is successfully initiated.
 * @throws Throws an error if no playable tracks are found or if any API call fails.
 */
export const playPlaylistWithCustomShuffleAPI = async (
  token: string,
  deviceId: string,
  playlistId: string
): Promise<void> => {
  if (!token || !deviceId || !playlistId) {
    const errMsg =
      '[playPlaylistWithCustomShuffleAPI] Token, Device ID, and Playlist ID are required.';
    console.error(errMsg);
    throw new Error(errMsg);
  }

  // console.log(
  //   `[playPlaylistWithCustomShuffleAPI] Starting custom shuffle for playlist ${playlistId} on device ${deviceId}`
  // );

  // 1. Fetch all playable tracks
  const playableTracks = await fetchAllPlayablePlaylistTracksAPI(token, playlistId);

  // 2. Handle no playable tracks (AC5)
  if (!playableTracks || playableTracks.length === 0) {
    const errMsg = `[playPlaylistWithCustomShuffleAPI] No playable tracks found in playlist ${playlistId}. Cannot start custom shuffle.`;
    console.warn(errMsg);
    // This error will be caught by MusicContext and shown as a toast
    throw new Error(`No playable tracks found in playlist ${playlistId}.`);
  }
  // console.log(`[playPlaylistWithCustomShuffleAPI] Found ${playableTracks.length} playable tracks.`);

  // 3. Extract URIs
  const trackUris = playableTracks.map((track) => track.uri);

  // 4. Shuffle URIs - Use a copy by spreading into a new array before shuffling
  const shuffledTrackUris = shuffleArray([...trackUris]);

  // 5. Turn off Spotify's native shuffle (DR12.1.3, AC3)
  // console.log(
  //   `[playPlaylistWithCustomShuffleAPI] Turning off Spotify native shuffle for device ${deviceId}.`
  // );

  // If toggleShuffleAPI fails critically, makeSpotifyApiCall within it will throw,
  // and the error will propagate, stopping execution before playing the custom queue.

  // 6. Play the shuffled URIs (DR12.1.3, AC3)
  const playBody = {
    uris: shuffledTrackUris,
  };

  // console.log(
  //   `[playPlaylistWithCustomShuffleAPI] Attempting to play ${shuffledTrackUris.length} shuffled tracks on device ${deviceId}.`
  // );

  // The main try/catch for this function is implicitly handled by the caller in MusicContext
  // if individual API calls like fetchAllPlayablePlaylistTracksAPI or toggleShuffleAPI throw.
  // Explicit try/catch for the final play call for clarity or specific error message if needed.
  try {
    await makeSpotifyApiCall(token, `/me/player/play?device_id=${deviceId}`, 'PUT', playBody);
    // console.log(
    //   `[playPlaylistWithCustomShuffleAPI] Successfully initiated playback of custom shuffled playlist ${playlistId} on device ${deviceId}.`
    // );
  } catch (playError) {
    console.error(
      `[playPlaylistWithCustomShuffleAPI] Error initiating playback of custom shuffled playlist ${playlistId}:`,
      playError
    );
    // Re-throw for MusicContext to handle and potentially show a toast
    throw playError;
  }
};
</file>

<file path="types/spotify.ts">
// Types related to Spotify data

export interface SpotifyPlaylist {
  id: string;
  name: string;
  description: string;
  owner: {
    display_name?: string;
    id: string;
  };
  images: { url: string; height?: number; width?: number }[];
  tracks: {
    href: string;
    total: number;
  };
}

export interface SpotifyTrackArtist {
  id: string;
  name: string;
}

export interface SpotifyAlbumImage {
  url: string;
  height?: number;
  width?: number;
}

export interface SpotifyTrackAlbum {
  id: string;
  name: string;
  images: SpotifyAlbumImage[];
}

export interface SpotifyPlaylistItem {
  track: {
    id: string;
    name: string;
    artists: SpotifyTrackArtist[];
    album: SpotifyTrackAlbum;
    duration_ms: number;
    explicit: boolean;
    preview_url: string | null;
    uri: string;
  } | null;
  added_at: string;
}

export interface SpotifyPlaylistTracksResponse {
  href: string;
  items: SpotifyPlaylistItem[];
  limit: number;
  next: string | null;
  offset: number;
  previous: string | null;
  total: number;
}

// Playlist type for the database

export interface Playlist {
  id: string; // Internal database ID (e.g., UUID from Supabase)
  spotify_id: string;
  name: string;
  image_url?: string; // Optional image URL
}

export interface SpotifyApiTrackFull {
  id: string;
  uri: string;
  name: string;
  artists: {
    name: string;
    uri?: string;
    external_urls?: { spotify: string };
    [key: string]: unknown;
  }[];
  album: {
    name: string;
    images: { url: string; height?: number; width?: number }[];
    uri?: string;
    external_urls?: { spotify: string };
    [key: string]: unknown;
  };
  is_playable?: boolean;
  linked_from?: {
    id: string;
    uri: string;
    type: 'track';
    href: string;
    external_urls: { [key: string]: string };
  } | null;
  available_markets?: string[];
  restrictions?: {
    reason: string;
  };
  duration_ms?: number;
  [key: string]: unknown;
}
</file>

<file path="app/_actions/import-playlist.ts">
'use server';

import { getSpotifyAccessToken } from '@/lib/spotify-accesstoken';
import { createClient as createSupabaseServerClient } from '@/lib/supabase/server';
import {
  SpotifyPlaylist,
  SpotifyPlaylistItem,
  SpotifyPlaylistTracksResponse,
} from '@/types/spotify';

// Define a basic structure for expected Spotify Playlist object
// This can be expanded based on actual needs and Spotify API response

// Interfaces for Spotify Tracks

interface DbPlaylistInsert {
  spotify_playlist_id: string;
  name: string;
  description: string | null;
  owner_spotify_user_id: string;
  image_url: string | null;
  submitted_by_user_id?: string | null;
}

// For storing playlist items - REVISED for playlist_tracks table
interface DbPlaylistTrackInsert {
  playlist_id: string; // FK to our playlists.id (UUID)
  track_spotify_id: string;
  track_name: string;
  track_artists: { spotify_id: string; name: string }[] | null; // JSONB
  album_name: string | null;
  album_art_url: string | null;
  duration_ms: number | null;
  order_in_playlist: number; // 0-based index
  track_preview_url?: string | null;
  added_at: string | null; // Spotify's added_at timestamp
}

// Updated ImportPlaylistResult
export interface ImportPlaylistResult {
  success: boolean;
  status?:
    | 'created'
    | 'exists'
    | 'error_token'
    | 'error_fetching_meta'
    | 'error_fetching_tracks'
    | 'error_saving_meta'
    | 'error_saving_tracks'
    | 'error_aggregating_data'; // Added for aggregation step
  playlistIdDb?: string; // Our internal DB playlist ID
  message?: string;
  spotifyPlaylistData?: SpotifyPlaylist; // Raw from Spotify
  spotifyTracksData?: SpotifyPlaylistItem[]; // Raw from Spotify
}

// Helper function for introducing a delay
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export async function importPlaylist(playlistSpotifyId: string): Promise<ImportPlaylistResult> {
  console.log(`Attempting to import playlist: ${playlistSpotifyId}`);

  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    return {
      success: false,
      status: 'error_token',
      message: 'Failed to retrieve Spotify access token.',
    };
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  try {
    // 1. Fetch Playlist Metadata from Spotify
    const playlistResponse = await fetch(
      `https://api.spotify.com/v1/playlists/${playlistSpotifyId}?fields=id,name,description,owner(id,display_name),images,tracks(href,total)`,
      {
        headers: { Authorization: `Bearer ${accessToken}` },
      }
    );

    if (!playlistResponse.ok) {
      const errorBody = await playlistResponse.json().catch(() => ({}));
      return {
        success: false,
        status: 'error_fetching_meta',
        message: `Spotify API error (playlist metadata): ${playlistResponse.status} - ${errorBody?.error?.message || playlistResponse.statusText}`,
      };
    }
    const spotifyPlaylist: SpotifyPlaylist = await playlistResponse.json();
    console.log('Successfully fetched playlist data from Spotify:', spotifyPlaylist.name);

    // 2. Check for Duplicates in DB
    const { data: existingPlaylist, error: dbError } = await supabase
      .from('playlists')
      .select('id, spotify_playlist_id')
      .eq('spotify_playlist_id', spotifyPlaylist.id);

    if (dbError) {
      return {
        success: false,
        status: 'error_saving_meta',
        message: `Database error checking for existing playlist: ${dbError.message}`,
      };
    }

    if (existingPlaylist.length > 0) {
      return {
        success: true,
        status: 'exists',
        playlistIdDb: existingPlaylist[0].id,
        message: `Playlist ${spotifyPlaylist.name} already exists in the database.`,
        spotifyPlaylistData: spotifyPlaylist,
      };
    }

    // 3. Playlist does not exist, Insert Playlist Metadata into DB
    const playlistToInsert: DbPlaylistInsert = {
      spotify_playlist_id: spotifyPlaylist.id,
      name: spotifyPlaylist.name,
      description: spotifyPlaylist.description,
      owner_spotify_user_id: spotifyPlaylist.owner.id,
      image_url:
        spotifyPlaylist.images && spotifyPlaylist.images.length > 0
          ? spotifyPlaylist.images[0].url
          : null,
      submitted_by_user_id: user ? user.id : null,
    };

    const { data: newPlaylistData, error: insertMetaError } = await supabase
      .from('playlists')
      .insert(playlistToInsert)
      .select('id')
      .single();

    if (insertMetaError) {
      return {
        success: false,
        status: 'error_saving_meta',
        message: `Database error inserting playlist metadata: ${insertMetaError.message}`,
        spotifyPlaylistData: spotifyPlaylist,
      };
    }

    if (!newPlaylistData) {
      return {
        success: false,
        status: 'error_saving_meta',
        message: 'Failed to retrieve new playlist ID after metadata insert.',
        spotifyPlaylistData: spotifyPlaylist,
      };
    }
    const newDbPlaylistId = newPlaylistData.id;
    console.log(`Playlist metadata saved to DB with ID: ${newDbPlaylistId}`);

    // 4. Fetch Playlist Tracks from Spotify for the new playlist
    let allSpotifyTracks: SpotifyPlaylistItem[] = [];
    let tracksUrl: string | null = null; // Initialize as null

    // Only attempt to fetch tracks if the playlist metadata indicates tracks exist.
    if (spotifyPlaylist.tracks && spotifyPlaylist.tracks.total > 0) {
      // Always construct the initial URL for fetching tracks with the correct item-specific fields.
      // Using limit=100 for efficiency, as it's the typical maximum for this endpoint.
      tracksUrl = `https://api.spotify.com/v1/playlists/${playlistSpotifyId}/tracks?offset=0&limit=100&fields=items(added_at,track(id,name,artists(id,name),album(id,name,images),duration_ms,explicit,preview_url,uri)),next,total`;
      console.log(`[importPlaylist] Constructed initial tracksUrl: ${tracksUrl}`);
    } else {
      console.log(
        `[importPlaylist] Playlist ${spotifyPlaylist.name} has 0 tracks according to metadata. Skipping track fetch.`
      );
      // If there are no tracks, we can consider the import successful at this point with 0 tracks.
    }

    while (tracksUrl) {
      console.log(`[importPlaylist] Fetching tracks page from URL: ${tracksUrl}`);
      const tracksResponse = await fetch(tracksUrl, {
        headers: { Authorization: `Bearer ${accessToken}` },
      });

      if (!tracksResponse.ok) {
        const errorBody = await tracksResponse.json().catch(() => ({}));
        return {
          success: true,
          status: 'error_fetching_tracks',
          playlistIdDb: newDbPlaylistId,
          message: `Playlist metadata saved (ID: ${newDbPlaylistId}), but failed to fetch a page of tracks: ${tracksResponse.status} - ${errorBody?.error?.message || tracksResponse.statusText} from URL: ${tracksUrl}`,
          spotifyPlaylistData: spotifyPlaylist,
          spotifyTracksData: allSpotifyTracks, // Tracks fetched so far
        };
      }

      let tracksPageData;
      try {
        tracksPageData = await tracksResponse.json();
        console.log(
          '[importPlaylist] Raw tracksPageData received from Spotify:',
          JSON.stringify(tracksPageData, null, 2)
        );
      } catch (jsonError: unknown) {
        const errorMessage = jsonError instanceof Error ? jsonError.message : String(jsonError);
        console.error(
          'Error parsing JSON from Spotify tracks response:',
          errorMessage,
          tracksResponse.statusText
        );
        const responseText = await tracksResponse
          .text()
          .catch(() => 'Could not read error text during JSON parse error.');
        console.error('Response text for tracks page JSON parsing error:', responseText);
        return {
          success: true,
          status: 'error_fetching_tracks',
          playlistIdDb: newDbPlaylistId,
          message: `Playlist metadata saved (ID: ${newDbPlaylistId}), but failed to parse JSON for a page of tracks from URL ${tracksUrl}. Error: ${errorMessage}`,
          spotifyPlaylistData: spotifyPlaylist,
          spotifyTracksData: allSpotifyTracks,
        };
      }

      const tracksPage = tracksPageData as SpotifyPlaylistTracksResponse;

      if (!tracksPage || typeof tracksPage !== 'object' || !Array.isArray(tracksPage.items)) {
        console.warn(
          "[importPlaylist] Spotify tracks page data is malformed. 'tracksPage' is not an object or 'tracksPage.items' field is missing or not an array.",
          'URL fetched:',
          tracksUrl,
          'Type of tracksPage:',
          typeof tracksPage,
          'Is tracksPage.items an array?:',
          Array.isArray(tracksPage?.items),
          'Received data for tracks page (logged above as Raw tracksPageData received from Spotify):'
        );
        return {
          success: true,
          status: 'error_fetching_tracks',
          playlistIdDb: newDbPlaylistId,
          message: `Playlist metadata saved (ID: ${newDbPlaylistId}), but Spotify returned malformed data for a page of tracks from URL ${tracksUrl}. Track import may be incomplete.`,
          spotifyPlaylistData: spotifyPlaylist,
          spotifyTracksData: allSpotifyTracks,
        };
      }

      allSpotifyTracks = allSpotifyTracks.concat(
        tracksPage.items.filter((item) => item && item.track !== null)
      );

      // Check for next page and introduce a delay if needed
      if (tracksPage && typeof tracksPage.next === 'string') {
        tracksUrl = tracksPage.next;
        // Add a small delay to be kind to the API when paginating
        console.log('[importPlaylist] Delaying before fetching next page of tracks...');
        await sleep(300); // 300ms delay
      } else if (tracksPage && tracksPage.next === null) {
        tracksUrl = null; // End of pages
      } else {
        console.warn(
          "[importPlaylist] Unexpected 'next' field in Spotify tracks response or tracksPage is undefined. Stopping pagination. Received 'next' value:",
          tracksPage ? tracksPage.next : 'tracksPage was falsy'
        );
        tracksUrl = null; // Stop pagination if 'next' is not a string or null
      }

      console.log(
        `Fetched ${tracksPage.items ? tracksPage.items.length : 0} tracks for ${spotifyPlaylist.name}, total so far: ${allSpotifyTracks.length} / ${tracksPage.total}`
      );
    }
    console.log(
      `Successfully fetched all ${allSpotifyTracks.length} tracks for playlist: ${spotifyPlaylist.name}`
    );

    // 5. Map and Insert Playlist Items into DB
    if (allSpotifyTracks.length > 0) {
      const playlistTracksToInsert: DbPlaylistTrackInsert[] = allSpotifyTracks
        .map((item, index) => {
          if (!item.track) {
            // This case should ideally be filtered out earlier, but as a safeguard:
            console.warn('Skipping item with null track data during mapping:', item);
            return null; // Will be filtered out later
          }
          const track = item.track;
          return {
            playlist_id: newDbPlaylistId,
            track_spotify_id: track.id,
            track_name: track.name,
            track_artists: track.artists.map((a) => ({
              spotify_id: a.id, // Ensure this matches expected JSONB structure
              name: a.name,
            })),
            album_name: track.album ? track.album.name : null,
            album_art_url:
              track.album && track.album.images && track.album.images.length > 0
                ? track.album.images[0].url
                : null,
            duration_ms: track.duration_ms,
            order_in_playlist: index, // Using the index in the fetched array
            track_preview_url: track.preview_url,
            added_at: item.added_at,
            // Note: 'track_popularity' and 'audio_features' are not included
            // as they are not in the current Spotify track fetch or DbPlaylistTrackInsert
          };
        })
        .filter(Boolean) as DbPlaylistTrackInsert[]; // Filter out any nulls if items with null tracks were encountered

      if (playlistTracksToInsert.length > 0) {
        const { error: insertTracksError } = await supabase
          .from('playlist_tracks') // CORRECTED TABLE NAME
          .insert(playlistTracksToInsert);

        if (insertTracksError) {
          return {
            success: true,
            status: 'error_saving_tracks',
            playlistIdDb: newDbPlaylistId,
            message: `Playlist metadata saved (ID: ${newDbPlaylistId}), but failed to save tracks: ${insertTracksError.message}`,
            spotifyPlaylistData: spotifyPlaylist,
            spotifyTracksData: allSpotifyTracks,
          };
        }
        console.log(
          `Successfully saved ${allSpotifyTracks.length} tracks to DB for playlist ID: ${newDbPlaylistId}`
        );
      }
    }

    // --- BEGIN AGGREGATION LOGIC FOR Story 8.2 ---
    console.log(`[Story 8.2] Starting aggregation for playlist ID: ${newDbPlaylistId}`);
    try {
      const tracks_json: { spotify_track_id: string; name: string; duration_ms: number }[] =
        allSpotifyTracks
          .map((item) => {
            if (!item.track) return null;
            return {
              spotify_track_id: item.track.id,
              name: item.track.name,
              duration_ms: item.track.duration_ms,
            };
          })
          .filter(Boolean) as { spotify_track_id: string; name: string; duration_ms: number }[];

      const artistOccurrencesMap = new Map<
        string,
        { spotify_artist_id: string; name: string; playlist_occurrences: number }
      >();
      allSpotifyTracks.forEach((item) => {
        if (item.track && item.track.artists) {
          item.track.artists.forEach((artist) => {
            if (artistOccurrencesMap.has(artist.id)) {
              artistOccurrencesMap.get(artist.id)!.playlist_occurrences++;
            } else {
              artistOccurrencesMap.set(artist.id, {
                spotify_artist_id: artist.id,
                name: artist.name,
                playlist_occurrences: 1,
              });
            }
          });
        }
      });
      const artists_json = Array.from(artistOccurrencesMap.values());

      const total_tracks = tracks_json.length;
      const distinct_artist_count = artists_json.length;

      // user_id for the aggregate record is the submitted_by_user_id from the playlist record
      const aggregateUserId = playlistToInsert.submitted_by_user_id;

      const aggregateData = {
        playlist_id: newDbPlaylistId,
        user_id: aggregateUserId, // Can be null if not submitted by a logged-in user
        tracks_json,
        artists_json,
        total_tracks,
        distinct_artist_count,
        // last_aggregated_at will be set by the database trigger
      };

      console.log('[Story 8.2] Prepared aggregate data:', JSON.stringify(aggregateData, null, 2));

      const { error: upsertError } = await supabase
        .from('playlist_track_artist_aggregates')
        .upsert(aggregateData, { onConflict: 'playlist_id' });

      if (upsertError) {
        console.error(
          `[Story 8.2] Error upserting playlist aggregates for playlist ID ${newDbPlaylistId}:`,
          upsertError
        );
        // AC5: Log error but return success for playlist import itself
        // The overall function will still return success, but we log this specific error.
        // Optionally, we could modify the return status to 'created_with_aggregation_error'
        // For now, just logging and proceeding.
      } else {
        console.log(
          `[Story 8.2] Successfully upserted aggregates for playlist ID: ${newDbPlaylistId}`
        );
      }
    } catch (aggregationError) {
      console.error(
        `[Story 8.2] Exception during aggregation for playlist ID ${newDbPlaylistId}:`,
        aggregationError
      );
      // AC5: Log error but return success for playlist import itself
    }
    // --- END AGGREGATION LOGIC FOR Story 8.2 ---

    return {
      success: true,
      status: 'created',
      playlistIdDb: newDbPlaylistId,
      message: `Successfully imported playlist '${spotifyPlaylist.name}' and its ${allSpotifyTracks.length} tracks.`,
      spotifyPlaylistData: spotifyPlaylist,
      spotifyTracksData: allSpotifyTracks,
    };
  } catch (error) {
    console.error('Exception during Spotify playlist import process:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    // Determine a more specific status if possible, or keep general
    // Ensure this part is not accidentally duplicated if you are merging.
    // Check if playlistIdDb was set (meaning metadata might have been saved before this generic catch)
    // const currentPlaylistIdDb = newDbPlaylistId; // This variable might not be in scope here.
    // For simplicity, sticking to the original error statuses unless aggregation specifically fails.

    return {
      success: false,
      // status: 'error_saving_meta', // This might be too generic if error occurs after meta save
      // Consider if a more specific error status is needed if error is after metadata save
      // but before aggregation.
      // For now, using a general status if newDbPlaylistId is not available,
      // otherwise the status might have been set more specifically by earlier returns.
      status: 'error_saving_meta', // Fallback, might be overridden by more specific error returns above
      message: `Failed to import playlist: ${errorMessage}`,
    };
  }
}
</file>

<file path="app/auth/login/page.tsx">
import { LoginForm } from '@/components/login-form'
import { LogoutButton } from '@/components/nav/logout-button';

export default function Page() {
  return (
    <div className='flex min-h-svh w-full items-center justify-center p-6 md:p-10 z-10 relative'>
      <div className='absolute top-0 left-0 w-full h-full z-0 bg-linear-[170deg,_var(--teal-dark)_25%,_oklch(from_var(--seafoam-green)_l_c_h_/_0.4)_50%,_transparent_70%,_transparent_100%]' />

      <div className='w-full max-w-sm z-10'>
        <LoginForm />
        <LogoutButton />
      </div>
    </div>
  );
}
</file>

<file path="hooks/use-realtime-chat.tsx">
'use client'

import { createClient } from '@/lib/supabase/client'
import { useCallback, useEffect, useState, useRef } from 'react';
import type { Tables } from '@/types/database';
import {
  sendMessage as sendMessageAction,
  editMessage as editMessageAction,
  deleteMessage as deleteMessageAction,
} from '@/app/_actions/chat';

// Define RealtimeUser type (as it was in useRealtimePresenceRoom)
export type RealtimeUser = {
  id: string; // Typically the presence key, can be user ID
  name: string;
  image: string;
};

interface UseRealtimeChatProps {
  roomName: string;
  initialMessages?: ChatMessage[]; // Allow passing initial messages
  currentUserProfile: MessageSenderProfile;
}

export type MessageSenderProfile = Pick<Tables<'profiles'>, 'id' | 'username' | 'avatar_url'>;

export interface ChatMessage {
  id: number | string; // Can be clientSideId (string) initially, then dbId (number)
  clientSideId: string; // Stable client-generated UUID
  content: string;
  created_at: string;
  profile: MessageSenderProfile | null;
  isOptimistic: boolean; // Flag for optimistic state
  isEditPending?: boolean; // Flag for optimistic edit state
}

// const EVENT_MESSAGE_TYPE = 'message'; // Now unused
const EVENT_OPTIMISTIC_MESSAGE_RECEIVED = 'optimistic_message_received';
const EVENT_MESSAGE_CONFIRMED = 'message_confirmed';
const EVENT_OPTIMISTIC_MESSAGE_EDITED = 'optimistic_message_edited';
const EVENT_OPTIMISTIC_MESSAGE_DELETED = 'optimistic_message_deleted';
const EVENT_MESSAGE_EDIT_CONFIRMED = 'message_edit_confirmed';
const EVENT_MESSAGE_EDIT_FAILED = 'message_edit_failed';
const EVENT_MESSAGE_DELETE_CONFIRMED = 'message_delete_confirmed';
const EVENT_MESSAGE_DELETE_FAILED = 'message_delete_failed';

export function useRealtimeChat({
  roomName,
  currentUserProfile,
  initialMessages = [],
}: UseRealtimeChatProps) {
  const supabase = createClient();
  const [messages, setMessages] = useState<ChatMessage[]>(initialMessages);
  const [isLoadingInitialMessages, setIsLoadingInitialMessages] = useState(false);
  const [presentUsers, setPresentUsers] = useState<Record<string, RealtimeUser>>({});
  const [broadcastChannel, setBroadcastChannel] = useState<ReturnType<
    typeof supabase.channel
  > | null>(null);
  const currentBroadcastChannelRef = useRef<ReturnType<typeof supabase.channel> | null>(null); // Ref for current broadcast channel
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    if (initialMessages.length > 0 || !roomName) {
      return;
    }

    const fetchInitialMessages = async () => {
      setIsLoadingInitialMessages(true);
      console.log(`Fetching initial messages for room: ${roomName}`);
      try {
        const { data: fetchedMessagesData, error: messagesError } = await supabase
          .from('chat_messages')
          .select(
            `
            id,
            content,
            created_at,
            user_id,
            room_id,
            profile:profiles (
              id,
              username,
              avatar_url
            )
          `
          )
          .eq('room_id', roomName)
          .order('created_at', { ascending: true })
          .limit(50);

        if (messagesError) {
          console.error(`Error fetching initial messages for room ${roomName}:`, messagesError);
          setMessages([]);
        } else if (fetchedMessagesData) {
          const mappedMessages: ChatMessage[] = fetchedMessagesData
            .map((msg) => {
              let userProfile: MessageSenderProfile | null = null;
              if (msg.profile) {
                const profileData = Array.isArray(msg.profile) ? msg.profile[0] : msg.profile;
                if (profileData) {
                  userProfile = profileData as MessageSenderProfile;
                }
              }
              return {
                id: msg.id as number, // DB IDs are numbers
                clientSideId: msg.id.toString(), // Use DB ID as clientSideId for initial messages
                content: msg.content as string,
                created_at: msg.created_at || new Date().toISOString(),
                profile: userProfile,
                isOptimistic: false, // Initial messages are not optimistic
              };
            })
            .filter(Boolean) as ChatMessage[];
          setMessages(mappedMessages);
        }
      } catch (err) {
        console.error('Unexpected error fetching initial messages:', err);
        setMessages([]);
      }
      setIsLoadingInitialMessages(false);
    };

    fetchInitialMessages();
  }, [roomName, initialMessages.length, supabase]);

  useEffect(() => {
    if (!roomName) {
      console.warn('RealtimeChat: roomName is missing. Subscription cancelled.');
      return;
    }
    if (
      !currentUserProfile?.id ||
      !currentUserProfile?.username ||
      !currentUserProfile?.avatar_url
    ) {
      console.warn(
        'RealtimeChat: Missing essential profile info for presence/subscription. Subscription delayed.'
      );
      return;
    }

    // Channel for broadcasting new messages and presence
    const newBroadcastChannelInstance = supabase.channel(`room-${roomName}`, {
      config: {
        presence: { key: currentUserProfile.id },
      },
    });
    currentBroadcastChannelRef.current = newBroadcastChannelInstance; // Store current instance in ref

    // Listener for optimistic messages broadcasted by any client
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_OPTIMISTIC_MESSAGE_RECEIVED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return; // Stale channel
        const optimisticMsgPayload = payload.payload as ChatMessage;
        // Add to local state if this clientSideId isn't already present
        setMessages((current) =>
          current.find((m) => m.clientSideId === optimisticMsgPayload.clientSideId)
            ? current
            : [...current, optimisticMsgPayload]
        );
      }
    );

    // Listener for message confirmations broadcasted by the sender after DB persistence
    newBroadcastChannelInstance.on('broadcast', { event: EVENT_MESSAGE_CONFIRMED }, (payload) => {
      if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return; // Stale channel
      const { clientSideId, dbId, dbCreatedAt } = payload.payload as {
        clientSideId: string;
        dbId: number;
        dbCreatedAt: string;
      };
      setMessages((currentMsgs) =>
        currentMsgs.map((msg) =>
          msg.clientSideId === clientSideId
            ? {
                ...msg,
                id: dbId,
                created_at: dbCreatedAt,
                isOptimistic: false,
                isEditPending: false,
              } // Clear isEditPending on confirmation
            : msg
        )
      );
    });

    // Listener for optimistic message edits
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_OPTIMISTIC_MESSAGE_EDITED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
        const { clientSideId, newContent } = payload.payload as {
          clientSideId: string;
          newContent: string;
        };
        setMessages((currentMsgs) =>
          currentMsgs.map((msg) =>
            msg.clientSideId === clientSideId
              ? { ...msg, content: newContent, isEditPending: true }
              : msg
          )
        );
      }
    );

    // Listener for message edit confirmations
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_MESSAGE_EDIT_CONFIRMED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
        const { clientSideId, updatedContent /*,updatedAt*/ } = payload.payload as {
          clientSideId: string;
          updatedContent: string;
          updatedAt?: string;
        };
        setMessages((currentMsgs) =>
          currentMsgs.map((msg) =>
            msg.clientSideId === clientSideId
              ? {
                  ...msg,
                  content: updatedContent,
                  isEditPending: false /*, updated_at: updatedAt*/,
                }
              : msg
          )
        );
      }
    );

    // Listener for message edit failures
    newBroadcastChannelInstance.on('broadcast', { event: EVENT_MESSAGE_EDIT_FAILED }, (payload) => {
      if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
      const { clientSideId, originalContent } = payload.payload as {
        clientSideId: string;
        originalContent: string;
      };
      setMessages((currentMsgs) =>
        currentMsgs.map((msg) =>
          msg.clientSideId === clientSideId
            ? { ...msg, content: originalContent, isEditPending: false }
            : msg
        )
      );
    });

    // Listener for optimistic message deletes
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_OPTIMISTIC_MESSAGE_DELETED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
        const { clientSideId } = payload.payload as { clientSideId: string };
        setMessages((currentMsgs) =>
          currentMsgs.filter((msg) => msg.clientSideId !== clientSideId)
        );
      }
    );

    // Listener for message delete confirmations
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_MESSAGE_DELETE_CONFIRMED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
        // const { clientSideId } = payload.payload as { clientSideId: string };
        // Message should already be deleted optimistically. This is a confirmation.
        // No state change usually needed here unless you want to track confirmation specifically.
        console.log('Message delete confirmed via broadcast:', payload.payload.clientSideId);
      }
    );

    // Listener for message delete failures
    newBroadcastChannelInstance.on(
      'broadcast',
      { event: EVENT_MESSAGE_DELETE_FAILED },
      (payload) => {
        if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return;
        const { originalMessage } = payload.payload as { originalMessage: ChatMessage };
        // Add the message back if it's not already there (e.g., from a DB event that beat this broadcast)
        setMessages((currentMsgs) => {
          if (!currentMsgs.find((m) => m.clientSideId === originalMessage.clientSideId)) {
            // Sort messages by created_at after re-adding to maintain order
            return [...currentMsgs, originalMessage].sort(
              (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
            );
          }
          return currentMsgs;
        });
      }
    );

    newBroadcastChannelInstance.on('presence', { event: 'sync' }, () => {
      if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) return; // Stale channel
      const newState = newBroadcastChannelInstance.presenceState<{ name: string; image: string }>();
      const updatedUsers: Record<string, RealtimeUser> = {};
      for (const key in newState) {
        if (newState[key].length > 0) {
          updatedUsers[key] = {
            id: key,
            name: newState[key][0].name,
            image: newState[key][0].image,
          };
        }
      }
      setPresentUsers(updatedUsers);
    });

    newBroadcastChannelInstance.subscribe(async (status) => {
      if (currentBroadcastChannelRef.current !== newBroadcastChannelInstance) {
        // This callback is for a stale channel instance, do not proceed.
        // Also, don't set isConnected based on a stale channel.
        return;
      }

      if (status === 'SUBSCRIBED') {
        setIsConnected(true); // This channel is connected
        try {
          await newBroadcastChannelInstance.track({
            // TRACK CALLED HERE
            name: currentUserProfile.username!,
            image: currentUserProfile.avatar_url!,
          });
        } catch (trackError) {
          console.error('Error tracking presence:', trackError);
        }
      } else {
        // If broadcast channel is not subscribed or error, reflect in isConnected.
        // However, ensure this doesn't flip isConnected if dbChangesChannel is still fine (if they share isConnected)
        // For now, this setIsConnected(false) is specific to this channel's non-subscribed states.
        setIsConnected(false);
      }
    });
    setBroadcastChannel(newBroadcastChannelInstance); // Store the channel instance in state

    // Channel for listening to database changes (edit, delete, and INSERT as fallback)
    const newDbChangesChannelInstance = supabase
      .channel(`db-chat_messages-for-${roomName}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'chat_messages',
          filter: `room_id=eq.${roomName}`,
        },
        (payload) => {
        
          if (payload.eventType === 'UPDATE') {
            const updatedRecord = payload.new as Tables<'chat_messages'>;

            setMessages((currentMessages) =>
              currentMessages.map((msg) => {
                if (msg.id === updatedRecord.id) {
                  return {
                    ...msg,
                    id: updatedRecord.id,
                    content: updatedRecord.content,
                    created_at: updatedRecord.created_at ?? msg.created_at,
                    isEditPending: false, // DB update implies edit is no longer pending
                    isOptimistic: false, // DB update implies message is confirmed
                  };
                } else {
                  return msg;
                }
              })
            );
          } else if (payload.eventType === 'DELETE') {
            const deletedRecord = payload.old as Partial<
              Tables<'chat_messages'> & { id: number | string }
            >;
            if (deletedRecord && typeof deletedRecord.id !== 'undefined') {
              setMessages((currentMessages) =>
                currentMessages.filter((msg) => {
                  console.log(
                    `Comparing state msg.id (${msg.id} type: ${typeof msg.id}) with deletedRecord.id (${deletedRecord.id} type: ${typeof deletedRecord.id})`
                  );
                  return msg.id !== deletedRecord.id;
                })
              );
            } else {
              console.warn(
                'DELETE event received, but payload.old.id is missing or payload.old is null/undefined:',
                payload.old
              );
            }
          } else if (payload.eventType === 'INSERT') {
            // This INSERT handler is now primarily a fallback or for external insertions.
            // Optimistic messages should be confirmed via EVENT_MESSAGE_CONFIRMED broadcast.
            const dbRecord = payload.new as Tables<'chat_messages'> & {
              profile?: MessageSenderProfile | MessageSenderProfile[];
            };

            setMessages((currentMsgs) => {
              // Check if this message (by DB ID) is already confirmed in our state
              const alreadyConfirmed = currentMsgs.find(
                (m) => m.id === dbRecord.id && !m.isOptimistic
              );
              if (alreadyConfirmed) {
                return currentMsgs; // Already have it, no change needed
              }

              // Attempt to find and update a corresponding optimistic message
              // This heuristic is for robustness, in case confirmation broadcast was missed.
              const optimisticMatch = currentMsgs.find(
                (m) =>
                  m.isOptimistic &&
                  m.profile?.id === dbRecord.user_id && // Match sender
                  m.content === dbRecord.content // Match content (can be risky if user sends same message twice quickly)
                // A more robust match would involve passing clientSideId to DB and getting it back,
                // but current server action doesn't support that for direct DB events.
              );

              if (optimisticMatch) {
                return currentMsgs.map((msg) =>
                  msg.clientSideId === optimisticMatch.clientSideId
                    ? {
                        ...msg,
                        id: dbRecord.id,
                        created_at: dbRecord.created_at || msg.created_at,
                        isOptimistic: false,
                        // Profile should already be set from optimistic message
                      }
                    : msg
                );
              } else {
                // If no optimistic match, and not already confirmed, treat as a new message from DB.
                let userProfile: MessageSenderProfile | null = null;
                if (dbRecord.user_id === currentUserProfile.id) {
                  userProfile = currentUserProfile;
                } else if (dbRecord.profile) {
                  const profileData = Array.isArray(dbRecord.profile)
                    ? dbRecord.profile[0]
                    : dbRecord.profile;
                  if (
                    profileData &&
                    typeof profileData === 'object' &&
                    'id' in profileData &&
                    'username' in profileData
                  ) {
                    userProfile = profileData as MessageSenderProfile;
                  } else {
                    console.warn(
                      "DB INSERT event's profile data (other user) is not in expected format:",
                      dbRecord.profile
                    );
                  }
                } else if (dbRecord.user_id) {
                  console.warn(
                    `DB INSERT event for message ${dbRecord.id} from other user ${dbRecord.user_id} missing profile data. Profile will be null.`
                  );
                }

                const newMessageFromDb: ChatMessage = {
                  id: dbRecord.id,
                  clientSideId: dbRecord.id.toString(), // Use DB ID as clientSideId
                  content: dbRecord.content,
                  created_at: dbRecord.created_at || new Date().toISOString(),
                  profile: userProfile,
                  isOptimistic: false, // It's from the DB, so it's confirmed
                };
                return [...currentMsgs, newMessageFromDb];
              }
            });
          }
        }
      )
      .subscribe((status, err) => {
        if (status !== 'SUBSCRIBED' && err) {
          console.error(`DB Changes Channel error object for room ${roomName}:`, err);
        } else if (status !== 'SUBSCRIBED') {
          console.warn(
            `DB Changes Channel status is not SUBSCRIBED: ${status} for room ${roomName}`
          );
        }
      });

    return () => {
      // Cleanup for the specific instances created in this effect run
      if (newBroadcastChannelInstance) {
        // Check if it's still the current one before untracking, though removeChannel should handle it
        if (currentBroadcastChannelRef.current === newBroadcastChannelInstance) {
          // newBroadcastChannelInstance.untrack(); // Supabase client auto-untracks on removeChannel
          currentBroadcastChannelRef.current = null;
        }
        supabase.removeChannel(newBroadcastChannelInstance);
      }
      if (newDbChangesChannelInstance) {
        supabase.removeChannel(newDbChangesChannelInstance);
      }
      // setBroadcastChannel(null); // State will be updated if effect re-runs and creates a new one
      // setIsConnected(false); // Only set to false if both channels are truly down or on component unmount
      // setPresentUsers({}); // Resetting here might cause flicker if re-subscribing quickly
    };
  }, [
    roomName,
    currentUserProfile?.id,
    currentUserProfile?.username,
    currentUserProfile?.avatar_url,
    supabase,
  ]);

  const sendMessage = useCallback(
    async (content: string) => {
      if (!broadcastChannel || !isConnected || !roomName || !currentUserProfile?.id) {
        console.error(
          'Chat not connected, roomName missing, currentUserProfile.id missing, or broadcast channel unavailable'
        );
        return;
      }

      const clientGeneratedId = crypto.randomUUID();
      const optimisticMessage: ChatMessage = {
        id: clientGeneratedId, // Use clientGeneratedId as temporary ID
        clientSideId: clientGeneratedId,
        content,
        created_at: new Date().toISOString(),
        profile: currentUserProfile,
        isOptimistic: true,
      };

      // 1. Local optimistic update
      setMessages((current) => [...current, optimisticMessage]);

      // 2. Broadcast optimistic message
      try {
        await broadcastChannel.send({
          type: 'broadcast',
          event: EVENT_OPTIMISTIC_MESSAGE_RECEIVED,
          payload: optimisticMessage, // Send the whole optimistic message
        });
      } catch (error) {
        console.error('Error broadcasting optimistic message:', error);
        // Potentially revert local update if broadcast fails critically, though usually we'd still try to save
      }

      // 3. Persist to server
      const formData = new FormData();
      formData.append('roomId', roomName);
      formData.append('content', content);
      formData.append('clientSideId', clientGeneratedId); // Send clientSideId to server

      try {
        const result = await sendMessageAction(undefined, formData);

        if (result.success && result.data && result.data.id && result.data.originalClientSideId) {
          // 4. Broadcast confirmation
          const persistedMessage = result.data as Required<Tables<'chat_messages'>> & {
            originalClientSideId: string;
          };

          await broadcastChannel.send({
            type: 'broadcast',
            event: EVENT_MESSAGE_CONFIRMED,
            payload: {
              clientSideId: persistedMessage.originalClientSideId,
              dbId: persistedMessage.id,
              dbCreatedAt: persistedMessage.created_at,
            },
          });
          // The local state for the sender will be updated by its own EVENT_MESSAGE_CONFIRMED listener.
        } else {
          console.error(
            'Failed to persist message or missing ID/originalClientSideId in response:',
            result.error || 'Unknown error'
          );
          // Revert optimistic update on failure to persist
          setMessages((currentMsgs) =>
            currentMsgs.filter((msg) => msg.clientSideId !== clientGeneratedId)
          );
          // Optionally notify the user
        }
      } catch (error) {
        console.error('Error calling sendMessage action:', error);
        // Revert optimistic update on action error
        setMessages((currentMsgs) =>
          currentMsgs.filter((msg) => msg.clientSideId !== clientGeneratedId)
        );
        // Optionally notify the user
      }
    },
    [broadcastChannel, isConnected, roomName, currentUserProfile, sendMessageAction] // Added sendMessageAction
  );

  const handleEditMessageSubmit = useCallback(
    async (messageId: number | string, newContent: string) => {
      // Ensure we have a broadcast channel and are connected.
      if (!broadcastChannel || !isConnected) {
        console.error('Cannot edit message: Broadcast channel not available or not connected.');
        return;
      }

      const messageToEdit = messages.find(
        (msg) => msg.id === messageId || msg.clientSideId === messageId
      );

      if (!messageToEdit) {
        console.warn(`Message with ID/clientSideId ${messageId} not found for edit.`);
        return;
      }

      if (messageToEdit.content === newContent) {
        console.log("Content hasn't changed, no edit action needed.");
        return;
      }

      const originalContent = messageToEdit.content;
      const targetClientSideId = messageToEdit.clientSideId;

      // 1. Local optimistic update
      setMessages((currentMsgs) =>
        currentMsgs.map((msg) =>
          msg.clientSideId === targetClientSideId
            ? { ...msg, content: newContent, isEditPending: true }
            : msg
        )
      );

      // 2. Broadcast optimistic edit
      try {
        await broadcastChannel.send({
          type: 'broadcast',
          event: EVENT_OPTIMISTIC_MESSAGE_EDITED,
          payload: { clientSideId: targetClientSideId, newContent },
        });
      } catch (error) {
        console.error('Error broadcasting optimistic edit:', error);
        // Optionally revert local optimistic update if broadcast fails, or rely on server action failure
      }

      // 3. Call server action (messageId must be the DB id for the action)
      // If messageToEdit.id is still the clientSideId (string), it means it was an optimistic new message that hasn't been confirmed.
      // Editing such a message is complex. For now, we assume edit is on a confirmed message (id is number).
      if (typeof messageToEdit.id !== 'number') {
        console.warn(
          'Attempting to edit a message that may not have a DB ID yet. Reverting optimistic edit.'
        );
        setMessages((currentMsgs) =>
          currentMsgs.map((msg) =>
            msg.clientSideId === targetClientSideId
              ? { ...msg, content: originalContent, isEditPending: false }
              : msg
          )
        );
        // Optionally broadcast a revert for other clients if the optimistic edit was sent
        // This scenario (editing an unconfirmed message) should ideally be prevented by UI logic.
        return;
      }

      try {
        const result = await editMessageAction(messageToEdit.id as number, newContent);
        if (result.success) {
          // 4. Broadcast edit confirmation
          await broadcastChannel.send({
            type: 'broadcast',
            event: EVENT_MESSAGE_EDIT_CONFIRMED,
            payload: {
              clientSideId: targetClientSideId,
              updatedContent: newContent /*, updatedAt: result.data?.updated_at */,
            },
          });
        } else {
          console.error('Failed to edit message on server:', result.error);
          // Revert local optimistic update and broadcast failure
          setMessages((currentMsgs) =>
            currentMsgs.map((msg) =>
              msg.clientSideId === targetClientSideId
                ? { ...msg, content: originalContent, isEditPending: false }
                : msg
            )
          );
          await broadcastChannel.send({
            type: 'broadcast',
            event: EVENT_MESSAGE_EDIT_FAILED,
            payload: { clientSideId: targetClientSideId, originalContent },
          });
        }
      } catch (error) {
        console.error('Error calling editMessage action:', error);
        setMessages((currentMsgs) =>
          currentMsgs.map((msg) =>
            msg.clientSideId === targetClientSideId
              ? { ...msg, content: originalContent, isEditPending: false }
              : msg
          )
        );
        await broadcastChannel.send({
          type: 'broadcast',
          event: EVENT_MESSAGE_EDIT_FAILED,
          payload: { clientSideId: targetClientSideId, originalContent },
        });
      }
    },
    [messages, broadcastChannel, isConnected, editMessageAction]
  );

  const handleDeleteMessageConfirm = useCallback(
    async (messageId: number | string) => {
      if (!broadcastChannel || !isConnected) {
        console.error('Cannot delete message: Broadcast channel not available or not connected.');
        return;
      }

      const messageToDelete = messages.find(
        (msg) => msg.id === messageId || msg.clientSideId === messageId
      );

      if (!messageToDelete) {
        console.warn(`Message with ID/clientSideId ${messageId} not found for delete.`);
        return;
      }

      const targetClientSideId = messageToDelete.clientSideId;
      const originalMessageCopy = { ...messageToDelete }; // Keep a copy for potential revert

      // 1. Local optimistic update
      setMessages((currentMsgs) =>
        currentMsgs.filter((msg) => msg.clientSideId !== targetClientSideId)
      );

      // 2. Broadcast optimistic delete
      try {
        await broadcastChannel.send({
          type: 'broadcast',
          event: EVENT_OPTIMISTIC_MESSAGE_DELETED,
          payload: { clientSideId: targetClientSideId },
        });
      } catch (error) {
        console.error('Error broadcasting optimistic delete:', error);
        // Potentially revert local optimistic update if broadcast fails critically
      }

      // 3. Call server action (messageId must be the DB id)
      if (typeof messageToDelete.id !== 'number') {
        console.warn(
          'Attempting to delete a message that may not have a DB ID yet. Reverting optimistic delete.'
        );
        setMessages((currentMsgs) =>
          [...currentMsgs, originalMessageCopy].sort(
            (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          )
        );
        // No failure broadcast here as the optimistic delete might not have reached others or server call wasn't made.
        return;
      }

      try {
        const result = await deleteMessageAction(messageToDelete.id as number);
        if (result.success) {
          // 4. Broadcast delete confirmation
          await broadcastChannel.send({
            type: 'broadcast',
            event: EVENT_MESSAGE_DELETE_CONFIRMED,
            payload: { clientSideId: targetClientSideId },
          });
        } else {
          console.error('Failed to delete message on server:', result.error);
          // Revert local optimistic update and broadcast failure
          setMessages((currentMsgs) =>
            [...currentMsgs, originalMessageCopy].sort(
              (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
            )
          );
          await broadcastChannel.send({
            type: 'broadcast',
            event: EVENT_MESSAGE_DELETE_FAILED,
            payload: { originalMessage: originalMessageCopy },
          });
        }
      } catch (error) {
        console.error('Error calling deleteMessage action:', error);
        setMessages((currentMsgs) =>
          [...currentMsgs, originalMessageCopy].sort(
            (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          )
        );
        await broadcastChannel.send({
          type: 'broadcast',
          event: EVENT_MESSAGE_DELETE_FAILED,
          payload: { originalMessage: originalMessageCopy },
        });
      }
    },
    [messages, broadcastChannel, isConnected, deleteMessageAction]
  );

  return {
    messages,
    sendMessage,
    isConnected,
    presentUsers,
    handleEditMessageSubmit,
    handleDeleteMessageConfirm,
    isLoadingInitialMessages,
  };
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'i.scdn.co',
      },
      {
        protocol: 'https',
        hostname: 'res.cloudinary.com',
      },
      {
        protocol: 'https',
        hostname: 'image-cdn-ak.spotifycdn.com',
      },
      {
        protocol: 'https',
        hostname: 'mosaic.scdn.co',
      },
    ],
  },
  // reactStrictMode: false, // Temporarily disable for diagnosis
};

export default nextConfig;
</file>

<file path="types/database.ts">
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

export type Database = {
  public: {
    Tables: {
      chat_messages: {
        Row: {
          content: string;
          created_at: string | null;
          id: number;
          room_id: string;
          user_id: string;
        };
        Insert: {
          content: string;
          created_at?: string | null;
          id?: number;
          room_id: string;
          user_id: string;
        };
        Update: {
          content?: string;
          created_at?: string | null;
          id?: number;
          room_id?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'chat_messages_room_id_fkey';
            columns: ['room_id'];
            isOneToOne: false;
            referencedRelation: 'chat_rooms';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'chat_messages_user_id_fkey';
            columns: ['user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
      chat_rooms: {
        Row: {
          created_at: string | null;
          description: string | null;
          id: string;
          is_default_room: boolean | null;
          name: string;
        };
        Insert: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          is_default_room?: boolean | null;
          name: string;
        };
        Update: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          is_default_room?: boolean | null;
          name?: string;
        };
        Relationships: [];
      };
      playlist_track_artist_aggregates: {
        Row: {
          artists_json: Json;
          created_at: string;
          distinct_artist_count: number;
          id: string;
          last_aggregated_at: string;
          playlist_id: string;
          total_tracks: number;
          tracks_json: Json;
          user_id: string | null;
        };
        Insert: {
          artists_json?: Json;
          created_at?: string;
          distinct_artist_count?: number;
          id?: string;
          last_aggregated_at?: string;
          playlist_id: string;
          total_tracks?: number;
          tracks_json?: Json;
          user_id?: string | null;
        };
        Update: {
          artists_json?: Json;
          created_at?: string;
          distinct_artist_count?: number;
          id?: string;
          last_aggregated_at?: string;
          playlist_id?: string;
          total_tracks?: number;
          tracks_json?: Json;
          user_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: 'playlist_track_artist_aggregates_playlist_id_fkey';
            columns: ['playlist_id'];
            isOneToOne: true;
            referencedRelation: 'playlists';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'playlist_track_artist_aggregates_user_id_fkey';
            columns: ['user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
      playlist_tracks: {
        Row: {
          added_at: string | null;
          album_art_url: string | null;
          album_name: string | null;
          audio_features: Json | null;
          created_at: string;
          duration_ms: number | null;
          id: number;
          order_in_playlist: number;
          playlist_id: string;
          track_artists: Json | null;
          track_name: string;
          track_popularity: number | null;
          track_preview_url: string | null;
          track_spotify_id: string;
        };
        Insert: {
          added_at?: string | null;
          album_art_url?: string | null;
          album_name?: string | null;
          audio_features?: Json | null;
          created_at?: string;
          duration_ms?: number | null;
          id?: number;
          order_in_playlist: number;
          playlist_id: string;
          track_artists?: Json | null;
          track_name: string;
          track_popularity?: number | null;
          track_preview_url?: string | null;
          track_spotify_id: string;
        };
        Update: {
          added_at?: string | null;
          album_art_url?: string | null;
          album_name?: string | null;
          audio_features?: Json | null;
          created_at?: string;
          duration_ms?: number | null;
          id?: number;
          order_in_playlist?: number;
          playlist_id?: string;
          track_artists?: Json | null;
          track_name?: string;
          track_popularity?: number | null;
          track_preview_url?: string | null;
          track_spotify_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'playlist_tracks_playlist_id_fkey';
            columns: ['playlist_id'];
            isOneToOne: false;
            referencedRelation: 'playlists';
            referencedColumns: ['id'];
          },
        ];
      };
      playlists: {
        Row: {
          created_at: string;
          data_source: string | null;
          description: string | null;
          id: string;
          image_url: string | null;
          last_fetched_from_spotify_at: string | null;
          name: string;
          owner_spotify_user_id: string | null;
          snapshot_id: string | null;
          spotify_playlist_id: string;
          submitted_by_user_id: string | null;
          total_tracks: number | null;
          updated_at: string;
        };
        Insert: {
          created_at?: string;
          data_source?: string | null;
          description?: string | null;
          id?: string;
          image_url?: string | null;
          last_fetched_from_spotify_at?: string | null;
          name: string;
          owner_spotify_user_id?: string | null;
          snapshot_id?: string | null;
          spotify_playlist_id: string;
          submitted_by_user_id?: string | null;
          total_tracks?: number | null;
          updated_at?: string;
        };
        Update: {
          created_at?: string;
          data_source?: string | null;
          description?: string | null;
          id?: string;
          image_url?: string | null;
          last_fetched_from_spotify_at?: string | null;
          name?: string;
          owner_spotify_user_id?: string | null;
          snapshot_id?: string | null;
          spotify_playlist_id?: string;
          submitted_by_user_id?: string | null;
          total_tracks?: number | null;
          updated_at?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'playlists_submitted_by_user_id_fkey';
            columns: ['submitted_by_user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
      profiles: {
        Row: {
          avatar_url: string | null;
          id: string;
          spotify_user_id: string | null;
          updated_at: string | null;
          username: string | null;
        };
        Insert: {
          avatar_url?: string | null;
          id: string;
          spotify_user_id?: string | null;
          updated_at?: string | null;
          username?: string | null;
        };
        Update: {
          avatar_url?: string | null;
          id?: string;
          spotify_user_id?: string | null;
          updated_at?: string | null;
          username?: string | null;
        };
        Relationships: [];
      };
      user_playlist_matches: {
        Row: {
          id: string;
          matched_at: string;
          playlist_id: string;
          user_id: string;
        };
        Insert: {
          id?: string;
          matched_at?: string;
          playlist_id: string;
          user_id: string;
        };
        Update: {
          id?: string;
          matched_at?: string;
          playlist_id?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'user_playlist_matches_playlist_id_fkey';
            columns: ['playlist_id'];
            isOneToOne: false;
            referencedRelation: 'playlists';
            referencedColumns: ['id'];
          },
          {
            foreignKeyName: 'user_playlist_matches_user_id_fkey';
            columns: ['user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
      user_top_artists: {
        Row: {
          artist_spotify_id: string;
          fetched_at: string;
          genres: Json | null;
          image_url: string | null;
          name: string;
          popularity: number | null;
          user_id: string;
        };
        Insert: {
          artist_spotify_id: string;
          fetched_at?: string;
          genres?: Json | null;
          image_url?: string | null;
          name: string;
          popularity?: number | null;
          user_id: string;
        };
        Update: {
          artist_spotify_id?: string;
          fetched_at?: string;
          genres?: Json | null;
          image_url?: string | null;
          name?: string;
          popularity?: number | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'user_top_artists_user_id_fkey';
            columns: ['user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
      user_top_tracks: {
        Row: {
          album_image_url: string | null;
          album_name: string | null;
          album_spotify_id: string | null;
          artists: Json | null;
          duration_ms: number | null;
          fetched_at: string;
          name: string;
          popularity: number | null;
          preview_url: string | null;
          track_spotify_id: string;
          user_id: string;
        };
        Insert: {
          album_image_url?: string | null;
          album_name?: string | null;
          album_spotify_id?: string | null;
          artists?: Json | null;
          duration_ms?: number | null;
          fetched_at?: string;
          name: string;
          popularity?: number | null;
          preview_url?: string | null;
          track_spotify_id: string;
          user_id: string;
        };
        Update: {
          album_image_url?: string | null;
          album_name?: string | null;
          album_spotify_id?: string | null;
          artists?: Json | null;
          duration_ms?: number | null;
          fetched_at?: string;
          name?: string;
          popularity?: number | null;
          preview_url?: string | null;
          track_spotify_id?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: 'user_top_tracks_user_id_fkey';
            columns: ['user_id'];
            isOneToOne: false;
            referencedRelation: 'profiles';
            referencedColumns: ['id'];
          },
        ];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      calculate_jaccard_index_text_arrays: {
        Args: { array1: string[]; array2: string[] };
        Returns: number;
      };
      match_all_playlists: {
        Args: Record<PropertyKey, never>;
        Returns: undefined;
      };
      test_playlist_user_matching: {
        Args: { playlist_id_param: string };
        Returns: undefined;
      };
    };
    Enums: {
      room_role: 'DJ' | 'member';
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};

type DefaultSchema = Database[Extract<keyof Database, 'public'>];

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
        Database[DefaultSchemaTableNameOrOptions['schema']]['Views'])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
      Database[DefaultSchemaTableNameOrOptions['schema']]['Views'])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    ? (DefaultSchema['Tables'] & DefaultSchema['Views'])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema['Enums'] | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions['schema']]['Enums']
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions['schema']]['Enums'][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema['Enums']
    ? DefaultSchema['Enums'][DefaultSchemaEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema['CompositeTypes']
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema['CompositeTypes']
    ? DefaultSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]
    : never;

export const Constants = {
  public: {
    Enums: {
      room_role: ['DJ', 'member'],
    },
  },
} as const;
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import localFont from 'next/font/local';
import './globals.css';
import { Toaster } from '@/components/ui/sonner';
import Script from 'next/script';
import { Suspense } from 'react';
import { MusicProvider } from '@/music-context/music-context';
import { Nav } from '@/components/nav/nav';
import { createClient } from '@/lib/supabase/server';

export const metadata: Metadata = {
  title: 'Playlist Rooms',
  description: 'Real-time chat rooms for Spotify playlists',
};

const cabinetGrotesk = localFont({
  src: '../public/fonts/CabinetGrotesk-Variable.ttf',
  variable: '--font-cabinet-grotesk',
  display: 'swap',
});

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const supabase = await createClient();
  const user = await supabase.auth.getUser();

  return (
    <html lang='en' suppressHydrationWarning>
      <body className={`${cabinetGrotesk.variable} antialiased flex flex-col bg-sidepanels `}>
        <MusicProvider isDisabled={!user.data.user}>
          <main className='flex-grow max-w-screen-xl mx-auto w-full bg-background relative min-h-screen'>
            <Nav user={user.data.user} />
            <div className='absolute top-0 left-0 w-full h-full z-0 noise' />

            <Suspense fallback={<div>Loading...</div>}>{children}</Suspense>
          </main>
          <Toaster />
        </MusicProvider>
        <Script src='https://sdk.scdn.co/spotify-player.js' strategy='afterInteractive' />
      </body>
    </html>
  );
}
</file>

<file path="components/chat-message.tsx">
'use client';

import { cn } from '@/lib/utils';
import type { ChatMessage } from '@/hooks/use-realtime-chat';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import TextareaAutosize from 'react-textarea-autosize';
import { Edit2, Trash2, Check, X } from 'lucide-react';
import { useState, useEffect } from 'react';

interface ChatMessageItemProps {
  message: ChatMessage;
  isOwnMessage: boolean;
  showHeader: boolean;
  onEditSubmit: (messageId: number | string, newContent: string) => Promise<void>;
  onDeleteConfirm: (messageId: number | string) => Promise<void>;
}

export const ChatMessageItem = ({
  message,
  isOwnMessage,
  showHeader,
  onEditSubmit,
  onDeleteConfirm,
}: ChatMessageItemProps) => {
  const [showControls, setShowControls] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(message.content);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  let longPressTimeout: NodeJS.Timeout | null = null;

  // Determine if the message is still in its optimistic state (using client-side string ID)
  const isPendingSend = typeof message.id === 'string';

  useEffect(() => {
    if (!isEditing) {
      setEditText(message.content);
    }
  }, [message.content, isEditing]);

  const handleMouseEnter = () => {
    if (isOwnMessage && !isEditing) {
      setShowControls(true);
    }
  };

  const handleMouseLeave = () => {
    setShowControls(false);
  };

  const handleTouchStart = () => {
    if (isOwnMessage && !isEditing) {
      longPressTimeout = setTimeout(() => {
        setShowControls(true);
      }, 500);
    }
  };

  const handleTouchEnd = () => {
    if (longPressTimeout) {
      clearTimeout(longPressTimeout);
      longPressTimeout = null;
    }
  };

  const handleEditClick = () => {
    setIsEditing(true);
    setEditText(message.content);
    setShowControls(false);
  };

  const handleCancelEdit = () => {
    setIsEditing(false);
    setEditText(message.content);
  };

  const handleSaveEdit = () => {
    if (editText.trim() === '' || editText === message.content) {
      setIsEditing(false);
      setEditText(message.content);
      return;
    }
    onEditSubmit(message.id, editText.trim());
    setIsEditing(false);
  };

  const handleDeleteClick = () => {
    setShowControls(false);
    setShowDeleteConfirm(true);
  };

  const handleCancelDelete = () => {
    setShowDeleteConfirm(false);
  };

  const handleConfirmDelete = async () => {
    await onDeleteConfirm(message.id);
    setShowDeleteConfirm(false);
  };

  return (
    <div className={`flex mt-2 ${isOwnMessage ? 'justify-end' : 'justify-start'}`}>
      <div
        className={cn('max-w-[75%] w-fit flex flex-col gap-1 relative py-1', {
          'items-end': isOwnMessage,
          'pl-14': isOwnMessage,
        })}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
      >
        {showHeader && !isEditing && (
          <div
            className={cn('flex items-center gap-2 text-xs px-2 py-1', {
              'justify-end flex-row-reverse': isOwnMessage,
            })}
          >
            <Avatar className='h-6 w-6'>
              <AvatarImage
                className='object-cover'
                src={message.profile?.avatar_url || undefined}
                alt={message.profile?.username || 'U'}
              />
              <AvatarFallback className='text-xs'>
                {message.profile?.username
                  ?.split(' ')
                  ?.map((word) => word[0])
                  ?.join('')
                  ?.toUpperCase() || 'U'}
              </AvatarFallback>
            </Avatar>
            <span className={'font-medium'}>{message.profile?.username || 'User'}</span>
            <span className='text-foreground/50 text-xs'>
              {new Date(message.created_at).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
              })}
            </span>
          </div>
        )}

        <div className='relative'>
          {isEditing ? (
            <div className='w-full flex flex-col gap-1 py-1 px-1'>
              <TextareaAutosize
                value={editText}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                  setEditText(e.target.value)
                }
                className='text-sm resize-none border rounded-md p-2 border-primary focus:ring-primary focus:border-primary bg-background text-foreground min-w-2xs '
                minRows={1}
                autoFocus
              />
              <div className='flex justify-end gap-1 mt-1'>
                <Button
                  variant='ghost'
                  size='icon'
                  className='h-7 w-7 p-1'
                  onClick={handleCancelEdit}
                  aria-label='Cancel edit'
                >
                  <X className='h-4 w-4' />
                </Button>
                <Button
                  variant='ghost'
                  size='icon'
                  className='h-7 w-7 p-1 text-green-600 hover:text-green-600 hover:bg-green-600/10'
                  onClick={handleSaveEdit}
                  aria-label='Save edit'
                >
                  <Check className='h-4 w-4' />
                </Button>
              </div>
            </div>
          ) : (
            <div
              className={cn(
                'py-2 px-3 rounded-xl text-sm w-fit transition-opacity bg-chat-bg1',
                isOwnMessage ? 'bg-chat-bg2 ' : 'bg-muted text-foreground',
                isOwnMessage && (isPendingSend || message.isEditPending) && 'opacity-70'
              )}
            >
              {message.content}
            </div>
          )}

          {isOwnMessage && showControls && !isEditing && !showDeleteConfirm && (
            <div
              className={cn('absolute top-1 flex gap-1', isOwnMessage ? '-left-14' : '-right-14')}
            >
              <Button
                variant='ghost'
                size='icon'
                className='h-6 w-6 p-1'
                onClick={handleEditClick}
                aria-label='Edit message'
              >
                <Edit2 className='h-4 w-4' />
              </Button>
              <Button
                variant='ghost'
                size='icon'
                className='h-6 w-6 p-1 text-destructive hover:text-destructive hover:bg-destructive/10'
                onClick={handleDeleteClick}
                aria-label='Delete message'
              >
                <Trash2 className='h-4 w-4' />
              </Button>
            </div>
          )}

          {isOwnMessage && showDeleteConfirm && (
            <div
              className={cn(
                'absolute -top-2 flex flex-col items-end gap-1 p-2 rounded-md shadow-md bg-background border border-border',
                isOwnMessage ? 'left-[-150px] w-[140px]' : 'right-[-150px] w-[140px]'
              )}
            >
              <p className='text-xs text-foreground/80 text-center w-full'>Delete message?</p>
              <div className='flex gap-1 w-full justify-end'>
                <Button
                  variant='outline'
                  size='sm'
                  onClick={handleCancelDelete}
                  className='h-7 px-2 text-xs'
                >
                  <X className='h-3 w-3 mr-1' /> Cancel
                </Button>
                <Button
                  variant='destructive'
                  size='sm'
                  onClick={handleConfirmDelete}
                  className='h-7 px-2 text-xs'
                >
                  <Check className='h-3 w-3 mr-1' /> Confirm
                </Button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="components/login-form.tsx">
"use client";

import { cn } from "@/lib/utils";
import { createClient } from "@/lib/supabase/client";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useState } from "react";

export function LoginForm({
  className,
  ...props
}: React.ComponentPropsWithoutRef<"div">) {
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSocialLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    const supabase = createClient();
    setIsLoading(true);
    setError(null);

    try {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: 'spotify',
        options: {
          scopes:
            'user-read-email user-read-private, streaming, user-modify-playback-state, user-read-playback-state, playlist-modify-public, user-library-read, user-library-modify, user-top-read playlist-read-private',
          redirectTo: `${window.location.origin}/auth/oauth?next=/chat`,
        },
      });

      if (error) throw error;
    } catch (error: unknown) {
      setError(error instanceof Error ? error.message : 'An error occurred');
      setIsLoading(false);
    }
  };

  return (
    <div className={cn('flex flex-col gap-6', className)} {...props}>
      <Card>
        <CardHeader>
          <CardTitle className='text-2xl'>Welcome!</CardTitle>
          <CardDescription>Sign in to your account to continue</CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSocialLogin}>
            <div className='flex flex-col gap-6'>
              {error && <p className='text-sm text-destructive-500'>{error}</p>}
              <Button type='submit' className='w-full' disabled={isLoading}>
                {isLoading ? 'Logging in...' : 'Continue with Spotify'}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --font-cabinet: var(--font-cabinet-grotesk);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-accent2: var(--accent2);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-popover-secondary: var(--popover-secondary);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-warm-gray-medium: var(--warm-gray-medium);
  --color-warm-gray-light: var(--warm-gray-light);
  --color-sand-light: var(--sand-light);
  --color-sand-medium: var(--sand-medium);
  --color-sand-accent: var(--sand-accent);
  --color-sand-dark: var(--sand-dark);
  --color-spotify-green: var(--spotify-green);
  --color-teal-dark: var(--teal-dark);
  --color-seafoam-green: var(--seafoam-green);
  --color-peach: var(--peach);
  --color-sage-green: var(--sage-green);
  --color-sidepanels: var(--sidepanels);
  --color-chat-bg2: var(--chat-bg2);
  --color-chat-bg1: var(--chat-bg1);
}

:root {
  --radius: 0.625rem;

  --background: oklch(0.86 0.04 90);
  --foreground: oklch(0.25 0.06 245.64);
  --card: oklch(0.34 0.03 246);
  --card-foreground: oklch(0.97 0.01 124);
  --popover: oklch(0.34 0.03 246);
  --popover-foreground: oklch(0.97 0.01 124);
  --popover-secondary: oklch(0.31 0.03 245);
  --primary:  oklch(0.63 0.12 197.72);
  --primary-foreground: oklch(0.97 0.01 124);
  --secondary: oklch(0.77 0.01 92);
  --secondary-foreground: oklch(0.32 0.05 248);
  --muted: oklch(0.78 0.02 91);
  --muted-foreground: oklch(0.47 0.02 248);
  --accent: oklch(0.79 0.08 203);
  --accent-foreground: oklch(0.32 0.05 252);
  --accent2: oklch(0.75 0.13 209.38);
  --destructive: oklch(0.40 0.13 26);
  --destructive-foreground: oklch(0.99 0.00 0);
  --border: oklch(0.48 0.05 216);
  --input: oklch(0.34 0.03 246);
  --ring: oklch(0.58 0.11 250);
  --ring-active: oklch(0.52 0.07 198);
  
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --warm-gray-medium: oklch(0.77 0.02 83);
  --warm-gray-light: oklch(0.77 0.01 92);
  --sand-light: oklch(0.86 0.04 90);
  --sand-medium: oklch(0.84 0.02 93);
  --sand-accent: oklch(0.85 0.03 89);
  --sand-dark: oklch(0.82 0.02 88);
  --spotify-green: oklch(0.69 0.18 150);
  --teal-dark: oklch(0.61 0.11 184);
  --seafoam-green: oklch(0.82 0.08 171);
  --peach: oklch(0.75 0.06 57);
  --sage-green: oklch(0.79 0.03 134);
  --sidepanels: oklch(0.30 0.01 248);
  --chat-bg1: oklch(0.79 0.02 94.13);
  --chat-bg2: oklch(0.88 0.03 93.76);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  .font-cabinet {
    font-family: var(--font-cabinet);
  }
  body {
    @apply bg-background text-foreground font-cabinet;
  }
  .noise {
    background-image:
    url("data:image/svg+xml,%3Csvg viewBox='0 0 500 500' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    opacity: 0.5;
  }
  .scrollbar-hide {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
}

/* Marquee Animation */
@keyframes marquee {
  from {
    transform: translateX(0);
  }
  to {
    /* Translate by its own width plus the margin/gap */
    transform: translateX(calc(-100% - 1rem)); /* Adjust 1rem if the gap changes */
  }
}

.animate-marquee {
  animation: marquee var(--marquee-duration, 10s) linear infinite;
}

/* Custom scrollbar hiding utility */
</file>

<file path="components/realtime-chat.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChatMessageItem } from "@/components/chat-message";
import { useChatScroll } from "@/hooks/use-chat-scroll";
import { type ChatMessage, useRealtimeChat } from '@/hooks/use-realtime-chat';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Send } from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';
import type { MessageSenderProfile } from '@/hooks/use-realtime-chat';

interface RealtimeChatProps {
  roomName: string;
  currentUserProfile: MessageSenderProfile;
  onMessage?: (messages: ChatMessage[]) => void;
  initialMessages?: ChatMessage[];
}

/**
 * Realtime chat component
 * @param roomName - The name of the room to join. Each room is a unique chat.
 * @param currentUserProfile - The full profile object of the current user.
 * @param onMessage - The callback function to handle the messages. Useful if you want to store the messages in a database.
 * @param initialMessages - The initial messages to display in the chat. Useful if you want to display messages from a database.
 * @returns The chat component
 */
export const RealtimeChat = ({
  roomName,
  currentUserProfile,
  onMessage,
  initialMessages = [],
}: RealtimeChatProps) => {
  const containerRef = useRef<HTMLDivElement>(null);

  const { scrollToBottom } = useChatScroll(containerRef as React.RefObject<HTMLDivElement>);

  const {
    messages: allMessages,
    sendMessage,
    isConnected,
    handleEditMessageSubmit,
    handleDeleteMessageConfirm,
  } = useRealtimeChat({
    roomName,
    currentUserProfile,
    initialMessages,
  });
  const [newMessage, setNewMessage] = useState('');

  useEffect(() => {
    if (onMessage) {
      onMessage(allMessages);
    }
  }, [allMessages, onMessage]);

  useEffect(() => {
    // Scroll to bottom whenever messages change
    scrollToBottom();
  }, [allMessages, scrollToBottom]);

  const handleSendMessage = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();
      if (!newMessage.trim() || !isConnected) return;

      sendMessage(newMessage);
      setNewMessage('');
    },
    [newMessage, isConnected, sendMessage]
  );

  // console.log('RealtimeChat: presentUsers', presentUsers);
  // console.log('RealtimeChat: avatarsForStack', avatarsForStack);
  // console.log('RealtimeChat: isConnected', isConnected);

  return (
    <div className='flex flex-col pt-10 bg-background h-screen'>
      <div className='flex flex-col h-full w-full'>
        {/* Header area for Room Info / Presence */}

        {/* Messages Area */}
        <div
          ref={containerRef}
          className='flex-1 overflow-y-auto p-4 space-y-4 relative z-20 scrollbar-hide'
        >
          {allMessages.length === 0 ? (
            <div className='text-center text-sm text-muted-foreground'>
              No messages yet. Start the conversation!
            </div>
          ) : null}
          <div className='space-y-1'>
            {allMessages.map((message, index) => {
              const prevMessage = index > 0 ? allMessages[index - 1] : null;
              const showHeader =
                !prevMessage || prevMessage.profile?.username !== message.profile?.username;

              return (
                <div
                  key={message.clientSideId}
                  className='animate-in fade-in slide-in-from-bottom-4 duration-300 z-20 relative'
                >
                  <ChatMessageItem
                    message={message}
                    isOwnMessage={message.profile?.id === currentUserProfile.id}
                    showHeader={showHeader}
                    onEditSubmit={handleEditMessageSubmit}
                    onDeleteConfirm={handleDeleteMessageConfirm}
                  />
                </div>
              );
            })}
          </div>
        </div>

        {/* Input Area */}
        <form
          onSubmit={handleSendMessage}
          className='flex items-center w-full gap-2 border-t border-border p-4 z-20 relative'
        >
          <Input
            className={cn('rounded-full bg-background text-sm transition-all duration-300 flex-1')}
            type='text'
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder='Type a message...'
            disabled={!isConnected}
          />
          {isConnected && newMessage.trim() && (
            <Button
              className='aspect-square rounded-full animate-in fade-in slide-in-from-right-4 duration-300'
              type='submit'
              disabled={!isConnected}
            >
              <Send className='size-4' />
            </Button>
          )}
        </form>
      </div>
    </div>
  );
};
</file>

<file path="package.json">
{
  "name": "dmfm",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint --fix",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,md}\"",
    "check-format": "prettier --check \"**/*.{ts,tsx,js,jsx,json,md}\"",
    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest"
  },
  "dependencies": {
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-avatar": "^1.1.9",
    "@radix-ui/react-popover": "^1.1.13",
    "@radix-ui/react-slider": "^1.3.4",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.2.6",
    "@remixicon/react": "^4.6.0",
    "@spotify/web-api-ts-sdk": "^1.2.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.49.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.507.0",
    "motion": "^12.11.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-textarea-autosize": "^8.5.9",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@swc/core": "^1.11.24",
    "@swc/jest": "^0.2.38",
    "@tailwindcss/postcss": "^4.1.5",
    "@testing-library/react": "^16.3.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/spotify-web-playback-sdk": "^0.1.19",
    "@typescript-eslint/eslint-plugin": "^8.32.0",
    "@typescript-eslint/parser": "^8.32.0",
    "cross-env": "^7.0.3",
    "eslint": "^9.26.0",
    "eslint-config-next": "^15.3.2",
    "eslint-config-prettier": "^10.1.3",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-prettier": "^5.4.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "prettier": "^3.5.3",
    "prettier-plugin-tailwindcss": "^0.6.11",
    "tailwindcss": "^4.1.5",
    "ts-jest": "^29.3.2",
    "tw-animate-css": "^1.2.9",
    "typescript": "^5"
  }
}
</file>

</files>

'use server';

import { createClient } from '@/lib/supabase/server';
// import { cookies } from 'next/headers'; // createClient in server.ts handles this internally
import { z } from 'zod';
import type { Tables } from '@/types/database';
import type { TablesInsert } from '@/types/database';
import type { SupabaseClient } from '@supabase/supabase-js';

// Define the schema for input validation
const sendMessageSchema = z.object({
  roomId: z.string().uuid(),
  content: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
  clientSideId: z.string().uuid(),
});

// Schema for editing a message
const editMessageSchema = z.object({
  messageId: z.number().int().positive('Invalid message ID'),
  newContent: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
});

// Schema for deleting a message
const deleteMessageSchema = z.object({
  messageId: z.number().int().positive('Invalid message ID'),
});

export interface ActionResult<T = null> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    details?: string;
  };
  validationErrors?: Record<string, string[]>;
}

const MessageSchema = z.object({
  roomId: z.string().uuid('Invalid room ID format'),
  content: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
});

// Schema for validating sendMessage input
const MessageInputSchema = z.object({
  roomId: z.string().uuid('Invalid Room ID: Must be a valid UUID.'),
  content: z
    .string()
    .min(1, 'Message cannot be empty.')
    .max(1000, 'Message cannot exceed 1000 characters.'),
});

export async function sendMessage(
  prevState: ActionResult | null,
  formData: FormData
): Promise<ActionResult<{ id: number } | null>> {
  const supabase: SupabaseClient = await createClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return {
      success: false,
      error: { message: 'Authentication required. Please log in to send messages.' },
    };
  }

  const rawFormData = {
    roomId: formData.get('roomId'),
    content: formData.get('content'),
  };

  const validationResult = MessageInputSchema.safeParse(rawFormData);

  if (!validationResult.success) {
    const fieldErrors: Record<string, string[]> = {};
    validationResult.error.issues.forEach((issue) => {
      const fieldName = issue.path.map((p) => p.toString()).join('.');
      if (!fieldErrors[fieldName]) {
        fieldErrors[fieldName] = [];
      }
      fieldErrors[fieldName].push(issue.message);
    });
    return {
      success: false,
      error: { message: 'Validation failed. Please check your input.' },
      validationErrors: fieldErrors,
    };
  }

  const { roomId, content } = validationResult.data;

  type NewChatMessage = TablesInsert<'chat_messages'>;
  const newMessageData: NewChatMessage = {
    room_id: roomId,
    user_id: user.id,
    content: content,
    // id and created_at are generated by DB
  };

  try {
    const { data: insertedMessage, error: insertError } = await supabase
      .from('chat_messages')
      .insert(newMessageData)
      .select('id')
      .single();

    if (insertError) {
      console.error('Supabase insert error:', insertError);
      return {
        success: false,
        error: {
          message: 'Failed to send the message due to a database error.',
          details: insertError.message,
        },
      };
    }

    if (!insertedMessage) {
      console.error('Supabase insert error: No data returned after insert');
      return {
        success: false,
        error: { message: 'Failed to send the message. No confirmation from database.' },
      };
    }

    return { success: true, data: { id: insertedMessage.id } };
  } catch (e: unknown) {
    console.error('Unexpected error in sendMessage:', e);
    let errorMessage = 'An unexpected error occurred while sending your message.';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    return {
      success: false,
      error: { message: errorMessage },
    };
  }
}

export async function editMessage(messageId: number, newContent: string): Promise<ActionResult> {
  const supabase = await createClient();

  // 1. Get current user
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: { message: 'User not authenticated' } };
  }

  // 2. Validate input
  const validatedInput = editMessageSchema.safeParse({ messageId, newContent });

  if (!validatedInput.success) {
    return {
      success: false,
      error: {
        message: 'Invalid input: ' + validatedInput.error.issues.map((e) => e.message).join(', '),
      },
    };
  }

  const { messageId: validatedMessageId, newContent: validatedNewContent } = validatedInput.data;

  try {
    // 3. Verify ownership and update message
    const { data: existingMessage, error: fetchError } = await supabase
      .from('chat_messages')
      .select('id, user_id')
      .eq('id', validatedMessageId)
      .single();

    if (fetchError) {
      console.error('Error fetching message for edit:', fetchError);
      return { success: false, error: { message: 'Message not found or error fetching it.' } };
    }

    if (existingMessage.user_id !== user.id) {
      return { success: false, error: { message: 'User not authorized to edit this message.' } };
    }

    const { data: updatedMessageData, error: updateError } = await supabase
      .from('chat_messages')
      .update({ content: validatedNewContent }) // Consider adding updated_at if schema changes
      .eq('id', validatedMessageId)
      .select('id, created_at, content, user_id, room_id')
      .single();

    if (updateError) {
      console.error('Error updating message:', updateError);
      return {
        success: false,
        error: { message: 'Failed to edit message: ' + updateError.message },
      };
    }

    return { success: true, data: updatedMessageData };
  } catch (e: unknown) {
    let errorMessage = 'An unexpected error occurred during edit';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    console.error('Unexpected error in editMessage action:', e);
    return { success: false, error: { message: errorMessage } };
  }
}

export async function deleteMessage(messageId: number): Promise<ActionResult> {
  const supabase = await createClient();

  // 1. Get current user
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: { message: 'User not authenticated' } };
  }

  // 2. Validate input
  const validatedInput = deleteMessageSchema.safeParse({ messageId });

  if (!validatedInput.success) {
    return {
      success: false,
      error: {
        message: 'Invalid input: ' + validatedInput.error.issues.map((e) => e.message).join(', '),
      },
    };
  }

  const { messageId: validatedMessageId } = validatedInput.data;

  try {
    // 3. Verify ownership
    const { data: existingMessage, error: fetchError } = await supabase
      .from('chat_messages')
      .select('id, user_id')
      .eq('id', validatedMessageId)
      .single();

    if (fetchError) {
      console.error('Error fetching message for delete:', fetchError);
      return { success: false, error: { message: 'Message not found or error fetching it.' } };
    }

    if (existingMessage.user_id !== user.id) {
      return { success: false, error: { message: 'User not authorized to delete this message.' } };
    }

    // 4. Delete message
    const { error: deleteError } = await supabase
      .from('chat_messages')
      .delete()
      .eq('id', validatedMessageId);

    if (deleteError) {
      console.error('Error deleting message:', deleteError);
      return {
        success: false,
        error: { message: 'Failed to delete message: ' + deleteError.message },
      };
    }

    return { success: true, data: { id: validatedMessageId } }; // Return the ID of the deleted message
  } catch (e: unknown) {
    let errorMessage = 'An unexpected error occurred during delete';
    if (e instanceof Error) {
      errorMessage = e.message;
    }
    console.error('Unexpected error in deleteMessage action:', e);
    return { success: false, error: { message: errorMessage } };
  }
}
